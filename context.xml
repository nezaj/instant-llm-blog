This file is a merged representation of a subset of the codebase, containing specifically included files and files not matching ignore patterns, combined into a single document by Repomix. The content has been processed where security check has been disabled.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: client/packages/**/*, www/pages/docs/**/*.md
- Files matching these patterns are excluded: .github/**/*, server/resources/**/*, client/packages/core/__tests__/**/*, client/www/public/**/*, server/dev-resources/**/*
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Security check has been disabled - content may contain sensitive information
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
client/
  packages/
    admin/
      src/
        index.ts
        version.js
      .npmignore
      package.json
      README.md
      tsconfig.json
      tsconfig.module.json
    cli/
      bin/
        index.js
      src/
        util/
          fs.ts
          packageManager.js
        index.js
        toggle.ts
        version.js
      package.json
      README.md
      tsconfig.json
    core/
      __example__/
        standalone.esm.html
        standalone.umd.html
      src/
        model/
          instaqlResult.js
        utils/
          Deferred.js
          error.ts
          fetch.ts
          flags.ts
          linkIndex.ts
          log.ts
          object.js
          PersistedObject.js
          pick.js
          uuid.ts
          weakHash.ts
        authAPI.ts
        clientTypes.ts
        coreTypes.ts
        datalog.js
        devtool.ts
        helperTypes.ts
        index.ts
        IndexedDBStorage.js
        InMemoryStorage.js
        instaml.js
        instaql.js
        instatx.ts
        presence.ts
        queryTypes.ts
        Reactor.js
        sanityCheckQueries.ts
        schema.ts
        schemaTypes.ts
        StorageAPI.ts
        store.js
        version.js
        WindowNetworkListener.js
      .npmignore
      package.json
      README.md
      tsconfig.json
      tsconfig.module.json
      vite.config.ts
    react/
      __example__/
        standalone.esm.html
        standalone.umd.html
      src/
        Cursors.tsx
        index.ts
        init.ts
        InstantReactAbstractDatabase.ts
        InstantReactRoom.ts
        InstantReactWebDatabase.ts
        useQuery.ts
        useTimeout.ts
        version.js
      .npmignore
      package.json
      README.md
      tsconfig.json
      tsconfig.module.json
      vite.config.ts
    react-native/
      src/
        cli.ts
        index.ts
        NetworkListener.js
        Storage.js
        Storage.native.js
        version.js
      .npmignore
      package.json
      README.md
      tsconfig.json
      tsconfig.module.json
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="client/packages/admin/src/index.ts">
import {
  tx,
  lookup,
  getOps,
  i,
  id,
  txInit,
  version as coreVersion,
  type TransactionChunk,
  type AuthToken,
  type Exactly,

  // core types
  type User,
  type Query,

  // query types
  type QueryResponse,
  type InstaQLResponse,
  type InstaQLParams,
  type InstantQuery,
  type InstantQueryResult,
  type InstantSchema,
  type InstantSchemaDatabase,
  type InstantObject,
  type InstantEntity,
  type BackwardsCompatibleSchema,
  type IInstantDatabase,

  // schema types
  type AttrsDefs,
  type CardinalityKind,
  type DataAttrDef,
  type EntitiesDef,
  type EntitiesWithLinks,
  type EntityDef,
  type InstantGraph,
  type LinkAttrDef,
  type LinkDef,
  type LinksDef,
  type ResolveAttrs,
  type ValueTypes,
  type InstantSchemaDef,
  type InstantUnknownSchema,
  type InstaQLEntity,
  type InstaQLResult,
  type InstantRules,
  type UpdateParams,
  type LinkParams,

  // storage types
  type FileOpts,
  type UploadFileResponse,
  type DeleteFileResponse,
} from '@instantdb/core';

import version from './version';

type DebugCheckResult = {
  /** The ID of the record. */
  id: string;
  /** The namespace/table of the record. */
  entity: string;
  /** The value of the record. */
  record: Record<string, any>;
  /** The result of evaluating the corresponding permissions rule for a record. */
  check: any;
};

type Config = {
  appId: string;
  adminToken: string;
  apiURI?: string;
};

type InstantConfig<Schema extends InstantSchemaDef<any, any, any>> = {
  appId: string;
  adminToken: string;
  apiURI?: string;
  schema?: Schema;
};

type InstantConfigFilled<Schema extends InstantSchemaDef<any, any, any>> =
  InstantConfig<Schema> & { apiURI: string };

type FilledConfig = Config & { apiURI: string };

type ImpersonationOpts =
  | { email: string }
  | { token: AuthToken }
  | { guest: boolean };

function configWithDefaults(config: Config): FilledConfig {
  const defaultConfig = {
    apiURI: 'https://api.instantdb.com',
  };
  const r = { ...defaultConfig, ...config };
  return r;
}

function instantConfigWithDefaults<
  Schema extends InstantSchemaDef<any, any, any>,
>(config: InstantConfig<Schema>): InstantConfigFilled<Schema> {
  const defaultConfig = {
    apiURI: 'https://api.instantdb.com',
  };
  const r = { ...defaultConfig, ...config };
  return r;
}

function withImpersonation(
  headers: { [key: string]: string },
  opts: ImpersonationOpts,
) {
  if ('email' in opts) {
    headers['as-email'] = opts.email;
  } else if ('token' in opts) {
    headers['as-token'] = opts.token;
  } else if ('guest' in opts) {
    headers['as-guest'] = 'true';
  }
  return headers;
}

function authorizedHeaders(
  config: FilledConfig,
  impersonationOpts?: ImpersonationOpts,
) {
  const { adminToken, appId } = config;
  const headers = {
    'content-type': 'application/json',
    authorization: `Bearer ${adminToken}`,
    'app-id': appId,
  };
  return impersonationOpts
    ? withImpersonation(headers, impersonationOpts)
    : headers;
}

function isCloudflareWorkerRuntime() {
  return (
    // @ts-ignore
    typeof WebSocketPair !== 'undefined' ||
    // @ts-ignore
    (typeof navigator !== 'undefined' &&
      navigator.userAgent === 'Cloudflare-Workers') ||
    // @ts-ignore
    (typeof EdgeRuntime !== 'undefined' && EdgeRuntime === 'vercel')
  );
}

// (XXX): Cloudflare Workers don't support cache: "no-store"
// We need to set `cache: "no-store"` so Next.js doesn't cache the fetch
// To keep Cloudflare Workers working, we need to conditionally set the fetch options
// Once Cloudflare Workers support `cache: "no-store"`, we can remove this conditional
// https://github.com/cloudflare/workerd/issues/698

const FETCH_OPTS: RequestInit = isCloudflareWorkerRuntime()
  ? {}
  : { cache: 'no-store' };

async function jsonFetch(
  input: RequestInfo,
  init: RequestInit | undefined,
): Promise<any> {
  const headers = {
    ...(init.headers || {}),
    'Instant-Admin-Version': version,
    'Instant-Core-Version': coreVersion,
  };
  const res = await fetch(input, { ...FETCH_OPTS, ...init, headers });
  const json = await res.json();
  return res.status === 200
    ? Promise.resolve(json)
    : Promise.reject({ status: res.status, body: json });
}

/**
 *
 * The first step: init your application!
 *
 * Visit https://instantdb.com/dash to get your `appId` :)
 *
 * @example
 *  import { init } from "@instantdb/admin"
 *
 *  const db = init({
 *    appId: "my-app-id",
 *    adminToken: process.env.INSTANT_ADMIN_TOKEN
 *  })
 *
 *  // You can also provide a schema for type safety and editor autocomplete!
 *
 *  import { init } from "@instantdb/admin"
 *  import schema from ""../instant.schema.ts";
 *
 *  const db = init({
 *    appId: "my-app-id",
 *    adminToken: process.env.INSTANT_ADMIN_TOKEN,
 *    schema,
 *  })
 *  // To learn more: https://instantdb.com/docs/modeling-data
 */
function init<
  Schema extends InstantSchemaDef<any, any, any> = InstantUnknownSchema,
>(config: InstantConfig<Schema>) {
  return new InstantAdminDatabase<Schema>(config);
}

/**
 * @deprecated
 * `init_experimental` is deprecated. You can replace it with `init`.
 *
 * @example
 *
 * // Before
 * import { init_experimental } from "@instantdb/admin"
 * const db = init_experimental({  ...  });
 *
 * // After
 * import { init } from "@instantdb/admin"
 * const db = init({ ...  });
 */
const init_experimental = init;

/**
 *
 * The first step: init your application!
 *
 * Visit https://instantdb.com/dash to get your `appId` and `adminToken` :)
 *
 * @example
 *  const db = init({ appId: "my-app-id", adminToken: "my-admin-token" })
 */
class InstantAdmin<
  Schema extends InstantGraph<any, any> | {},
  WithCardinalityInference extends boolean,
> {
  config: FilledConfig;
  auth: Auth;
  storage: Storage;
  impersonationOpts?: ImpersonationOpts;

  public tx =
    txInit<
      Schema extends InstantGraph<any, any> ? Schema : InstantGraph<any, any>
    >();

  constructor(_config: Config) {
    this.config = configWithDefaults(_config);
    this.auth = new Auth(this.config);
    this.storage = new Storage(this.config);
  }

  /**
   * Sometimes you want to scope queries to a specific user.
   *
   * You can provide a user's auth token, email, or impersonate a guest.
   *
   * @see https://instantdb.com/docs/backend#impersonating-users
   * @example
   *  await db.asUser({email: "stopa@instantdb.com"}).query({ goals: {} })
   */
  asUser = (
    opts: ImpersonationOpts,
  ): InstantAdmin<Schema, WithCardinalityInference> => {
    const newClient = new InstantAdmin<Schema, WithCardinalityInference>({
      ...this.config,
    });
    newClient.impersonationOpts = opts;
    return newClient;
  };

  /**
   * Use this to query your data!
   *
   * @see https://instantdb.com/docs/instaql
   *
   * @example
   *  // fetch all goals
   *  await db.query({ goals: {} })
   *
   *  // goals where the title is "Get Fit"
   *  await db.query({ goals: { $: { where: { title: "Get Fit" } } } })
   *
   *  // all goals, _alongside_ their todos
   *  await db.query({ goals: { todos: {} } })
   */
  query = <
    Q extends Schema extends InstantGraph<any, any>
      ? InstaQLParams<Schema>
      : Exactly<Query, Q>,
  >(
    query: Q,
  ): Promise<QueryResponse<Q, Schema, WithCardinalityInference>> => {
    const withInference =
      'cardinalityInference' in this.config
        ? Boolean(this.config.cardinalityInference)
        : true;

    return jsonFetch(`${this.config.apiURI}/admin/query`, {
      method: 'POST',
      headers: authorizedHeaders(this.config, this.impersonationOpts),
      body: JSON.stringify({
        query: query,
        'inference?': withInference,
      }),
    });
  };

  /**
   * Use this to write data! You can create, update, delete, and link objects
   *
   * @see https://instantdb.com/docs/instaml
   *
   * @example
   *   // Create a new object in the `goals` namespace
   *   const goalId = id();
   *   db.transact(tx.goals[goalId].update({title: "Get fit"}))
   *
   *   // Update the title
   *   db.transact(tx.goals[goalId].update({title: "Get super fit"}))
   *
   *   // Delete it
   *   db.transact(tx.goals[goalId].delete())
   *
   *   // Or create an association:
   *   todoId = id();
   *   db.transact([
   *    tx.todos[todoId].update({ title: 'Go on a run' }),
   *    tx.goals[goalId].link({todos: todoId}),
   *  ])
   */
  transact = (
    inputChunks: TransactionChunk<any, any> | TransactionChunk<any, any>[],
  ) => {
    const chunks = Array.isArray(inputChunks) ? inputChunks : [inputChunks];
    const steps = chunks.flatMap((tx) => getOps(tx));
    return jsonFetch(`${this.config.apiURI}/admin/transact`, {
      method: 'POST',
      headers: authorizedHeaders(this.config, this.impersonationOpts),
      body: JSON.stringify({ steps: steps }),
    });
  };

  /**
   * Like `query`, but returns debugging information
   * for permissions checks along with the result.
   * Useful for inspecting the values returned by the permissions checks.
   * Note, this will return debug information for *all* entities
   * that match the query's `where` clauses.
   *
   * Requires a user/guest context to be set with `asUser`,
   * since permissions checks are user-specific.
   *
   * Accepts an optional configuration object with a `rules` key.
   * The provided rules will override the rules in the database for the query.
   *
   * @see https://instantdb.com/docs/instaql
   *
   * @example
   *  await db.asUser({ guest: true }).debugQuery(
   *    { goals: {} },
   *    { rules: { goals: { allow: { read: "auth.id != null" } } }
   *  )
   */
  debugQuery = async <Q extends Query>(
    query: Exactly<Query, Q>,
    opts?: { rules: any },
  ): Promise<{
    result: QueryResponse<Q, Schema, WithCardinalityInference>;
    checkResults: DebugCheckResult[];
  }> => {
    const response = await jsonFetch(
      `${this.config.apiURI}/admin/query_perms_check`,
      {
        method: 'POST',
        headers: authorizedHeaders(this.config, this.impersonationOpts),
        body: JSON.stringify({ query, 'rules-override': opts?.rules }),
      },
    );

    return {
      result: response.result,
      checkResults: response['check-results'],
    };
  };

  /**
   * Like `transact`, but does not write to the database.
   * Returns debugging information for permissions checks.
   * Useful for inspecting the values returned by the permissions checks.
   *
   * Requires a user/guest context to be set with `asUser`,
   * since permissions checks are user-specific.
   *
   * Accepts an optional configuration object with a `rules` key.
   * The provided rules will override the rules in the database for the duration of the transaction.
   *
   * @example
   *   const goalId = id();
   *   db.asUser({ guest: true }).debugTransact(
   *      [tx.goals[goalId].update({title: "Get fit"})],
   *      { rules: { goals: { allow: { update: "auth.id != null" } } }
   *   )
   */
  debugTransact = (
    inputChunks: TransactionChunk<any, any> | TransactionChunk<any, any>[],
    opts?: { rules?: any },
  ) => {
    const chunks = Array.isArray(inputChunks) ? inputChunks : [inputChunks];
    const steps = chunks.flatMap((tx) => getOps(tx));
    return jsonFetch(`${this.config.apiURI}/admin/transact_perms_check`, {
      method: 'POST',
      headers: authorizedHeaders(this.config, this.impersonationOpts),
      body: JSON.stringify({
        steps: steps,
        'rules-override': opts?.rules,
        // @ts-expect-error because we're using a private API (for now)
        'dangerously-commit-tx': opts?.__dangerouslyCommit,
      }),
    });
  };
}

class Auth {
  config: FilledConfig;

  constructor(config: FilledConfig) {
    this.config = config;
  }

  /**
   * Generates a magic code for the user with the given email,  used to sign in on the frontend.
   * This is useful for writing custom auth flows.
   *
   * @example
   *   try {
   *     const user = await db.auth.generateMagicCode({ email })
   *     // send an email to user with magic code
   *   } catch (err) {
   *     console.error("Failed to generate magic code:", err.message);
   *   }
   *
   * @see https://instantdb.com/docs/backend#generate-magic-code
   */
  generateMagicCode = async (email: string): Promise<{ code: string }> => {
    return jsonFetch(`${this.config.apiURI}/admin/magic_code`, {
      method: 'POST',
      headers: authorizedHeaders(this.config),
      body: JSON.stringify({ email }),
    });
  };

  /**
   * Creates a login token for the user with the given email.
   * If that user does not exist, we create one.
   *
   * This is often useful for writing custom auth flows.
   *
   * @example
   *   app.post('/custom_sign_in', async (req, res) => {
   *     // ... your custom flow for users
   *     const token = await db.auth.createToken(email)
   *     return res.status(200).send({ token })
   *   })
   *
   * @see https://instantdb.com/docs/backend#custom-auth
   */
  createToken = async (email: string): Promise<AuthToken> => {
    const ret: { user: { refresh_token: string } } = await jsonFetch(
      `${this.config.apiURI}/admin/refresh_tokens`,
      {
        method: 'POST',
        headers: authorizedHeaders(this.config),
        body: JSON.stringify({ email }),
      },
    );
    return ret.user.refresh_token;
  };

  /**
   * Verifies a given token and returns the associated user.
   *
   * This is often useful for writing custom endpoints, where you need
   * to authenticate users.
   *
   * @example
   *   app.post('/custom_endpoint', async (req, res) => {
   *     const user = await db.auth.verifyToken(req.headers['token'])
   *     if (!user) {
   *       return res.status(400).send('Uh oh, you are not authenticated')
   *     }
   *     // ...
   *   })
   * @see https://instantdb.com/docs/backend#custom-endpoints
   */
  verifyToken = async (token: AuthToken): Promise<User> => {
    const res = await jsonFetch(
      `${this.config.apiURI}/runtime/auth/verify_refresh_token`,
      {
        method: 'POST',
        headers: { 'content-type': 'application/json' },
        body: JSON.stringify({
          'app-id': this.config.appId,
          'refresh-token': token,
        }),
      },
    );
    return res.user;
  };

  /**
   * Retrieves an app user by id, email, or refresh token.
   *
   * @example
   *   try {
   *     const user = await db.auth.getUser({ email })
   *     console.log("Found user:", user)
   *   } catch (err) {
   *     console.error("Failed to retrieve user:", err.message);
   *   }
   *
   * @see https://instantdb.com/docs/backend#retrieve-a-user
   */
  getUser = async (
    params: { email: string } | { id: string } | { refresh_token: string },
  ): Promise<User> => {
    const qs = Object.entries(params)
      .map(([k, v]) => `${k}=${encodeURIComponent(v)}`)
      .join('&');

    const response: { user: User } = await jsonFetch(
      `${this.config.apiURI}/admin/users?${qs}`,
      {
        method: 'GET',
        headers: authorizedHeaders(this.config),
      },
    );

    return response.user;
  };

  /**
   * Deletes an app user by id, email, or refresh token.
   *
   * NB: This _only_ deletes the user; it does not delete all user data.
   * You will need to handle this manually.
   *
   * @example
   *   try {
   *     const deletedUser = await db.auth.deleteUser({ email })
   *     console.log("Deleted user:", deletedUser)
   *   } catch (err) {
   *     console.error("Failed to delete user:", err.message);
   *   }
   *
   * @see https://instantdb.com/docs/backend#delete-a-user
   */
  deleteUser = async (
    params: { email: string } | { id: string } | { refresh_token: string },
  ): Promise<User> => {
    const qs = Object.entries(params).map(([k, v]) => `${k}=${v}`);
    const response: { deleted: User } = await jsonFetch(
      `${this.config.apiURI}/admin/users?${qs}`,
      {
        method: 'DELETE',
        headers: authorizedHeaders(this.config),
      },
    );

    return response.deleted;
  };

  /**
   * Signs out the user with the given email.
   * This invalidates any tokens associated with the user.
   * If the user is not found, an error will be thrown.
   *
   * @example
   *   try {
   *     await auth.signOut("alyssa_p_hacker@instantdb.com");
   *     console.log("Successfully signed out");
   *   } catch (err) {
   *     console.error("Sign out failed:", err.message);
   *   }
   *
   * @see https://instantdb.com/docs/backend#sign-out
   */
  async signOut(email: string): Promise<void> {
    const config = this.config;
    await jsonFetch(`${config.apiURI}/admin/sign_out`, {
      method: 'POST',
      headers: authorizedHeaders(config),
      body: JSON.stringify({ email }),
    });
  }
}

type StorageFile = {
  key: string;
  name: string;
  size: number;
  etag: string;
  last_modified: number;
};

type DeleteManyFileResponse = {
  data: {
    ids: string[] | null;
  };
};

/**
 * Functions to manage file storage.
 */
class Storage {
  config: FilledConfig;

  constructor(config: FilledConfig) {
    this.config = config;
  }

  /**
   * Uploads file at the provided path.
   *
   * @see https://instantdb.com/docs/storage
   * @example
   *   const buffer = fs.readFileSync('demo.png');
   *   const isSuccess = await db.storage.uploadFile('photos/demo.png', buffer);
   */
  uploadFile = async (
    path: string,
    file: Buffer,
    metadata: FileOpts = {},
  ): Promise<UploadFileResponse> => {
    const headers = {
      ...authorizedHeaders(this.config),
      path,
      'content-type': metadata.contentType || 'application/octet-stream',
    };
    if (metadata.contentDisposition) {
      headers['content-disposition'] = metadata.contentDisposition;
    }

    const data = await jsonFetch(`${this.config.apiURI}/admin/storage/upload`, {
      method: 'PUT',
      headers,
      body: file,
    });

    return data;
  };

  /**
   * Deletes a file by its path name (e.g. "photos/demo.png").
   *
   * @see https://instantdb.com/docs/storage
   * @example
   *   await db.storage.delete("photos/demo.png");
   */
  delete = async (pathname: string): Promise<DeleteFileResponse> => {
    return jsonFetch(
      `${this.config.apiURI}/admin/storage/files?filename=${encodeURIComponent(
        pathname,
      )}`,
      {
        method: 'DELETE',
        headers: authorizedHeaders(this.config),
      },
    );
  };

  /**
   * Deletes multiple files by their path names (e.g. "photos/demo.png", "essays/demo.txt").
   *
   * @see https://instantdb.com/docs/storage
   * @example
   *   await db.storage.deleteMany(["images/1.png", "images/2.png", "images/3.png"]);
   */
  deleteMany = async (pathnames: string[]): Promise<DeleteManyFileResponse> => {
    return jsonFetch(`${this.config.apiURI}/admin/storage/files/delete`, {
      method: 'POST',
      headers: authorizedHeaders(this.config),
      body: JSON.stringify({ filenames: pathnames }),
    });
  };

  /**
   * @deprecated. This method will be removed in the future. Use `uploadFile`
   * instead
   */
  upload = async (
    pathname: string,
    file: Buffer,
    metadata: FileOpts = {},
  ): Promise<boolean> => {
    const { data: presignedUrl } = await jsonFetch(
      `${this.config.apiURI}/admin/storage/signed-upload-url`,
      {
        method: 'POST',
        headers: authorizedHeaders(this.config),
        body: JSON.stringify({
          app_id: this.config.appId,
          filename: pathname,
        }),
      },
    );
    const { ok } = await fetch(presignedUrl, {
      method: 'PUT',
      body: file,
      headers: {
        'Content-Type': metadata.contentType || 'application/octet-stream',
      },
    });

    return ok;
  };

  /**
   * @deprecated. This method will be removed in the future. Use `query` instead
   * @example
   * const files = await db.query({ $files: {}})
   */
  list = async (): Promise<StorageFile[]> => {
    const { data } = await jsonFetch(
      `${this.config.apiURI}/admin/storage/files`,
      {
        method: 'GET',
        headers: authorizedHeaders(this.config),
      },
    );

    return data;
  };

  /**
   * @deprecated. getDownloadUrl will be removed in the future.
   * Use `query` instead to query and fetch for valid urls
   *
   * db.useQuery({
   *   $files: {
   *     $: {
   *       where: {
   *         path: "moop.png"
   *       }
   *     }
   *   }
   * })
   */
  getDownloadUrl = async (pathname: string): Promise<string> => {
    const { data } = await jsonFetch(
      `${this.config.apiURI}/admin/storage/signed-download-url?app_id=${this.config.appId}&filename=${encodeURIComponent(pathname)}`,
      {
        method: 'GET',
        headers: authorizedHeaders(this.config),
      },
    );

    return data;
  };
}

/**
 *
 * The first step: init your application!
 *
 * Visit https://instantdb.com/dash to get your `appId` and `adminToken` :)
 *
 * @example
 *  const db = init({ appId: "my-app-id", adminToken: "my-admin-token" })
 */
class InstantAdminDatabase<Schema extends InstantSchemaDef<any, any, any>> {
  config: InstantConfigFilled<Schema>;
  auth: Auth;
  storage: Storage;
  impersonationOpts?: ImpersonationOpts;

  public tx = txInit<Schema>();

  constructor(_config: InstantConfig<Schema>) {
    this.config = instantConfigWithDefaults(_config);
    this.auth = new Auth(this.config);
    this.storage = new Storage(this.config);
  }

  /**
   * Sometimes you want to scope queries to a specific user.
   *
   * You can provide a user's auth token, email, or impersonate a guest.
   *
   * @see https://instantdb.com/docs/backend#impersonating-users
   * @example
   *  await db.asUser({email: "stopa@instantdb.com"}).query({ goals: {} })
   */
  asUser = (opts: ImpersonationOpts): InstantAdminDatabase<Schema> => {
    const newClient = new InstantAdminDatabase<Schema>({
      ...this.config,
    });
    newClient.impersonationOpts = opts;
    return newClient;
  };

  /**
   * Use this to query your data!
   *
   * @see https://instantdb.com/docs/instaql
   *
   * @example
   *  // fetch all goals
   *  await db.query({ goals: {} })
   *
   *  // goals where the title is "Get Fit"
   *  await db.query({ goals: { $: { where: { title: "Get Fit" } } } })
   *
   *  // all goals, _alongside_ their todos
   *  await db.query({ goals: { todos: {} } })
   */
  query = <Q extends InstaQLParams<Schema>>(
    query: Q,
  ): Promise<InstaQLResponse<Schema, Q>> => {
    return jsonFetch(`${this.config.apiURI}/admin/query`, {
      method: 'POST',
      headers: authorizedHeaders(this.config, this.impersonationOpts),
      body: JSON.stringify({
        query: query,
        'inference?': !!this.config.schema,
      }),
    });
  };

  /**
   * Use this to write data! You can create, update, delete, and link objects
   *
   * @see https://instantdb.com/docs/instaml
   *
   * @example
   *   // Create a new object in the `goals` namespace
   *   const goalId = id();
   *   db.transact(tx.goals[goalId].update({title: "Get fit"}))
   *
   *   // Update the title
   *   db.transact(tx.goals[goalId].update({title: "Get super fit"}))
   *
   *   // Delete it
   *   db.transact(tx.goals[goalId].delete())
   *
   *   // Or create an association:
   *   todoId = id();
   *   db.transact([
   *    tx.todos[todoId].update({ title: 'Go on a run' }),
   *    tx.goals[goalId].link({todos: todoId}),
   *  ])
   */
  transact = (
    inputChunks: TransactionChunk<any, any> | TransactionChunk<any, any>[],
  ) => {
    const chunks = Array.isArray(inputChunks) ? inputChunks : [inputChunks];
    const steps = chunks.flatMap((tx) => getOps(tx));
    return jsonFetch(`${this.config.apiURI}/admin/transact`, {
      method: 'POST',
      headers: authorizedHeaders(this.config, this.impersonationOpts),
      body: JSON.stringify({
        steps: steps,
        'throw-on-missing-attrs?': !!this.config.schema,
      }),
    });
  };

  /**
   * Like `query`, but returns debugging information
   * for permissions checks along with the result.
   * Useful for inspecting the values returned by the permissions checks.
   * Note, this will return debug information for *all* entities
   * that match the query's `where` clauses.
   *
   * Requires a user/guest context to be set with `asUser`,
   * since permissions checks are user-specific.
   *
   * Accepts an optional configuration object with a `rules` key.
   * The provided rules will override the rules in the database for the query.
   *
   * @see https://instantdb.com/docs/instaql
   *
   * @example
   *  await db.asUser({ guest: true }).debugQuery(
   *    { goals: {} },
   *    { rules: { goals: { allow: { read: "auth.id != null" } } }
   *  )
   */
  debugQuery = async <Q extends InstaQLParams<Schema>>(
    query: Q,
    opts?: { rules: any },
  ): Promise<{
    result: InstaQLResponse<Schema, Q>;
    checkResults: DebugCheckResult[];
  }> => {
    const response = await jsonFetch(
      `${this.config.apiURI}/admin/query_perms_check`,
      {
        method: 'POST',
        headers: authorizedHeaders(this.config, this.impersonationOpts),
        body: JSON.stringify({ query, 'rules-override': opts?.rules }),
      },
    );

    return {
      result: response.result,
      checkResults: response['check-results'],
    };
  };

  /**
   * Like `transact`, but does not write to the database.
   * Returns debugging information for permissions checks.
   * Useful for inspecting the values returned by the permissions checks.
   *
   * Requires a user/guest context to be set with `asUser`,
   * since permissions checks are user-specific.
   *
   * Accepts an optional configuration object with a `rules` key.
   * The provided rules will override the rules in the database for the duration of the transaction.
   *
   * @example
   *   const goalId = id();
   *   db.asUser({ guest: true }).debugTransact(
   *      [tx.goals[goalId].update({title: "Get fit"})],
   *      { rules: { goals: { allow: { update: "auth.id != null" } } }
   *   )
   */
  debugTransact = (
    inputChunks: TransactionChunk<any, any> | TransactionChunk<any, any>[],
    opts?: { rules?: any },
  ) => {
    const chunks = Array.isArray(inputChunks) ? inputChunks : [inputChunks];
    const steps = chunks.flatMap((tx) => getOps(tx));
    return jsonFetch(`${this.config.apiURI}/admin/transact_perms_check`, {
      method: 'POST',
      headers: authorizedHeaders(this.config, this.impersonationOpts),
      body: JSON.stringify({
        steps: steps,
        'rules-override': opts?.rules,
        // @ts-expect-error because we're using a private API (for now)
        'dangerously-commit-tx': opts?.__dangerouslyCommit,
      }),
    });
  };
}

export {
  init,
  init_experimental,
  id,
  tx,
  lookup,
  i,

  // types
  type Config,
  type ImpersonationOpts,
  type TransactionChunk,
  type DebugCheckResult,
  type InstantAdmin,
  type InstantAdminDatabase,

  // core types
  type User,
  type InstaQLParams,
  type Query,

  // query types
  type QueryResponse,
  type InstantQuery,
  type InstantQueryResult,
  type InstantSchema,
  type InstantSchemaDatabase,
  type IInstantDatabase,
  type InstantObject,
  type InstantEntity,
  type BackwardsCompatibleSchema,

  // schema types
  type AttrsDefs,
  type CardinalityKind,
  type DataAttrDef,
  type EntitiesDef,
  type EntitiesWithLinks,
  type EntityDef,
  type InstantGraph,
  type LinkAttrDef,
  type LinkDef,
  type LinksDef,
  type ResolveAttrs,
  type ValueTypes,
  type InstantSchemaDef,
  type InstantUnknownSchema,
  type InstaQLEntity,
  type InstaQLResult,
  type InstantRules,
  type UpdateParams,
  type LinkParams,

  // storage types
  type FileOpts,
  type UploadFileResponse,
  type DeleteFileResponse,
  type DeleteManyFileResponse,
};
</file>

<file path="client/packages/admin/src/version.js">
// Autogenerated by publish_packages.clj
const version = 'v0.17.22-dev';

export default version;
</file>

<file path="client/packages/admin/.npmignore">
.turbo
</file>

<file path="client/packages/admin/package.json">
{
  "name": "@instantdb/admin",
  "version": "v0.17.22",
  "description": "Admin SDK for Instant DB",
  "main": "dist/index.js",
  "module": "dist/module/index.js",
  "types": "dist/module/index.d.ts",
  "unpkg": "dist/index.js",
  "scripts": {
    "test": "vitest",
    "build": "rm -rf dist; npm run build:main && npm run build:module",
    "dev:main": "tsc -p tsconfig.json -w --skipLibCheck",
    "dev:module": "tsc -p tsconfig.module.json -w --skipLibCheck",
    "dev": "run-p dev:main dev:module",
    "build:main": "tsc -p tsconfig.json",
    "build:module": "tsc -p tsconfig.module.json",
    "publish-package": "pnpm publish --access public --no-git-checks"
  },
  "devDependencies": {
    "@babel/core": "^7.17.9",
    "@babel/preset-env": "^7.16.11",
    "@types/node": "^22.6.1",
    "npm-run-all": "^4.1.5",
    "typescript": "^5.5.4",
    "vitest": "^0.21.0"
  },
  "dependencies": {
    "@instantdb/core": "workspace:*"
  }
}
</file>

<file path="client/packages/admin/README.md">
<p align="center">
  <a href="https://instantdb.com">
    <img alt="Shows the Instant logo" src="https://instantdb.com/img/icon/android-chrome-512x512.png" width="10%">
  </a>
  <h1 align="center">@instantdb/admin</h1>
</p>

<p align="center">
  <a 
    href="https://discord.com/invite/VU53p7uQcE" >
    <img height=20 src="https://img.shields.io/discord/1031957483243188235" />
  </a>
  <img src="https://img.shields.io/github/stars/instantdb/instant" alt="stars">
</p>

<p align="center">
   <a href="https://www.instantdb.com/docs/backend">Get Started</a> · 
   <a href="https://instantdb.com/examples">Examples</a> · 
   <a href="https://instantdb.com/tutorial">Try the Demo</a> · 
   <a href="https://www.instantdb.com/docs/backend">Docs</a> · 
   <a href="https://discord.com/invite/VU53p7uQcE">Discord</a>
<p>

Welcome to [Instant's](http://instantdb.com) admin SDK.

```javascript
import { init, tx, id } from '@instantdb/admin';

const adminDB = init({
  appId: 'my-instant-app-id',
  adminToken: process.env.INSTANT_APP_ADMIN_TOKEN,
});

const data = await adminDB.query(
  { bookshelves: { books: {} } }, // wohoo!
);
```

# Get Started

Head on over to the [Instant on the Backend](https://www.instantdb.com/docs/backend) page in the docs to get started!

# Questions?

If you have any questions, feel free to drop us a line on our [Discord](https://discord.com/invite/VU53p7uQcE)
</file>

<file path="client/packages/admin/tsconfig.json">
{
  "extends": "../../tsconfig.base.json",
  "include": ["src"],
  "exclude": ["node_modules", "dist"],
  "compilerOptions": {
    "outDir": "dist",
    "rootDir": "src"
  }
}
</file>

<file path="client/packages/admin/tsconfig.module.json">
{
  "extends": "./tsconfig",
  "compilerOptions": {
    "module": "es2015",
    "outDir": "dist/module"
  }
}
</file>

<file path="client/packages/cli/bin/index.js">
#!/usr/bin/env node

import '../dist/index.js';
</file>

<file path="client/packages/cli/src/util/fs.ts">
import { PathLike } from 'fs';
import { readFile, stat } from 'fs/promises';

export async function pathExists(p: PathLike): Promise<boolean> {
  try {
    await stat(p);
    return true;
  } catch {
    return false;
  }
}

export async function readJsonFile<T = Record<string, any>>(
  p: PathLike,
): Promise<T | null> {
  if (!pathExists(p)) {
    return null;
  }

  try {
    const data = await readFile(p, 'utf-8');
    return JSON.parse(data);
  } catch (error) {}

  return null;
}
</file>

<file path="client/packages/cli/src/util/packageManager.js">
// Note:
// Extracted the main logic for `detectPackageManager` from:
// https://github.com/vercel/vercel/blob/eb7fe8a9266563cfeaf275cd77cd9fad3f17c92b/packages/build-utils/src/fs/run-user-scripts.ts

import { pathExists, readJsonFile } from './fs.js';
import path from 'path';

async function detectPackageManager(destPath) {
  const lockfileNames = {
    'yarn.lock': 'yarn',
    'package-lock.json': 'npm',
    'pnpm-lock.yaml': 'pnpm',
    'bun.lockb': 'bun',
  };

  for (const dir of traverseUpDirectories(destPath)) {
    for (const [lockfileName, cliType] of Object.entries(lockfileNames)) {
      const lockfilePath = path.join(dir, lockfileName);
      if (await pathExists(lockfilePath)) {
        return cliType;
      }
    }

    const packageJsonPath = path.join(dir, 'package.json');
    if (await pathExists(packageJsonPath)) {
      const packageJson = await readJsonFile(packageJsonPath);
      if (packageJson.packageManager) {
        const corepackPackageManager = parsePackageManagerField(
          packageJson.packageManager,
        );
        if (corepackPackageManager) {
          return corepackPackageManager.packageName;
        }
      }
    }

    if (dir === path.parse(dir).root) {
      break;
    }
  }

  return 'npm';
}

function* traverseUpDirectories(start) {
  let current = path.resolve(start);
  while (true) {
    yield current;
    const parent = path.dirname(current);
    if (parent === current) {
      break;
    }
    current = parent;
  }
}

function parsePackageManagerField(packageManager) {
  if (!packageManager) return null;
  const atIndex = packageManager.lastIndexOf('@');
  if (atIndex <= 0) return null; // '@' at position 0 is invalid
  const packageName = packageManager.slice(0, atIndex);
  const packageVersion = packageManager.slice(atIndex + 1);
  if (!packageName || !packageVersion) {
    return null;
  }
  return { packageName, packageVersion };
}

function getInstallCommand(packageManager, moduleName) {
  if (packageManager === 'npm') {
    return `npm install ${moduleName}`;
  } else {
    return `${packageManager} add ${moduleName}`;
  }
}

export { detectPackageManager, getInstallCommand };
</file>

<file path="client/packages/cli/src/index.js">
// @ts-check

import version from './version.js';
import { mkdir, writeFile, readFile } from 'fs/promises';
import path, { join } from 'path';
import { randomUUID } from 'crypto';
import jsonDiff from 'json-diff';
import dotenv from 'dotenv';
import chalk from 'chalk';
import { program, Option } from 'commander';
import { input, select } from '@inquirer/prompts';
import envPaths from 'env-paths';
import { loadConfig } from 'unconfig';
import { packageDirectory } from 'pkg-dir';
import openInBrowser from 'open';
import ora from 'ora';
import terminalLink from 'terminal-link';
import { exec } from 'child_process';
import { promisify } from 'util';
import {
  detectPackageManager,
  getInstallCommand,
} from './util/packageManager.js';
import { pathExists, readJsonFile } from './util/fs.js';
import prettier from 'prettier';
import toggle from './toggle.js';

const execAsync = promisify(exec);

// config
dotenv.config();

const dev = Boolean(process.env.INSTANT_CLI_DEV);
const verbose = Boolean(process.env.INSTANT_CLI_VERBOSE);

// logs

function warn(firstArg, ...rest) {
  console.warn(chalk.yellow('[warning]') + ' ' + firstArg, ...rest);
}

function error(firstArg, ...rest) {
  console.error(chalk.red('[error]') + ' ' + firstArg, ...rest);
}

// consts

const potentialEnvs = {
  catchall: 'INSTANT_APP_ID',
  next: 'NEXT_PUBLIC_INSTANT_APP_ID',
  svelte: 'PUBLIC_INSTANT_APP_ID',
  vite: 'VITE_INSTANT_APP_ID',
  expo: 'EXPO_PUBLIC_INSTANT_APP_ID',
  nuxt: 'NUXT_PUBLIC_INSTANT_APP_ID',
};

async function detectEnvType({ pkgDir }) {
  const packageJSON = await getPackageJson(pkgDir);
  if (!packageJSON) {
    return 'catchall';
  }
  if (packageJSON.dependencies?.next) {
    return 'next';
  }
  if (packageJSON.devDependencies?.svelte) {
    return 'svelte';
  }
  if (packageJSON.devDependencies?.vite) {
    return 'vite';
  }
  if (packageJSON.dependencies?.expo) {
    return 'expo';
  }
  if (packageJSON.dependencies?.nuxt) {
    return 'nuxt';
  }
  return 'catchall';
}

const instantDashOrigin = dev
  ? 'http://localhost:3000'
  : 'https://instantdb.com';

const instantBackendOrigin =
  process.env.INSTANT_CLI_API_URI ||
  (dev ? 'http://localhost:8888' : 'https://api.instantdb.com');

const PUSH_PULL_OPTIONS = new Set(['schema', 'perms', 'all']);

function convertArgToBagWithErrorLogging(arg) {
  if (!arg) {
    return { ok: true, bag: 'all' };
  } else if (PUSH_PULL_OPTIONS.has(arg.trim().toLowerCase())) {
    return { ok: true, bag: arg };
  } else {
    error(
      `${chalk.red(arg)} must be one of ${chalk.green(Array.from(PUSH_PULL_OPTIONS).join(', '))}`,
    );
    return { ok: false };
  }
}

// Note: Nov 20, 2024
// We can eventually deprecate this
// once we're confident that users no longer
// provide app ID as their first argument
function convertPushPullToCurrentFormat(cmdName, arg, opts) {
  if (arg && !PUSH_PULL_OPTIONS.has(arg) && !opts.app) {
    warnDeprecation(`${cmdName} ${arg}`, `${cmdName} --app ${arg}`);
    return { ok: true, bag: 'all', opts: { ...opts, app: arg } };
  }
  const { ok, bag } = convertArgToBagWithErrorLogging(arg);
  if (!ok) return { ok: false };
  return { ok: true, bag, opts };
}

async function packageDirectoryWithErrorLogging() {
  const pkgDir = await packageDirectory();
  if (!pkgDir) {
    error("Couldn't find your root directory. Is there a package.json file?");
    return;
  }
  return pkgDir;
}

// cli

// Header -- this shows up in every command
const logoChalk = chalk.bold('instant-cli');
const versionChalk = chalk.dim(`${version.trim()}`);
const headerChalk = `${logoChalk} ${versionChalk} ` + '\n';

// Help Footer -- this only shows up in help commands
const helpFooterChalk =
  '\n' +
  chalk.dim.bold('Want to learn more?') +
  '\n' +
  `Check out the docs: ${chalk.blueBright.underline('https://instantdb.com/docs')}
Join the Discord:   ${chalk.blueBright.underline('https://discord.com/invite/VU53p7uQcE')}
`.trim();

program.addHelpText('after', helpFooterChalk);

program.addHelpText('beforeAll', headerChalk);

function getLocalAndGlobalOptions(cmd, helper) {
  const mixOfLocalAndGlobal = helper.visibleOptions(cmd);
  const localOptionsFromMix = mixOfLocalAndGlobal.filter(
    (option) => !option.__global,
  );
  const globalOptionsFromMix = mixOfLocalAndGlobal.filter(
    (option) => option.__global,
  );
  const globalOptions = helper.visibleGlobalOptions(cmd);

  return [localOptionsFromMix, globalOptionsFromMix.concat(globalOptions)];
}

// custom `formatHelp`
// original: https://github.com/tj/commander.js/blob/master/lib/help.js
function formatHelp(cmd, helper) {
  const termWidth = helper.padWidth(cmd, helper);
  const helpWidth = helper.helpWidth || 80;
  const itemIndentWidth = 2;
  const itemSeparatorWidth = 2; // between term and description
  function formatItem(term, description) {
    if (description) {
      const fullText = `${term.padEnd(termWidth + itemSeparatorWidth)}${description}`;
      return helper.wrap(
        fullText,
        helpWidth - itemIndentWidth,
        termWidth + itemSeparatorWidth,
      );
    }
    return term;
  }
  function formatList(textArray) {
    return textArray.join('\n').replace(/^/gm, ' '.repeat(itemIndentWidth));
  }

  // Usage
  let output = [`${helper.commandUsage(cmd)}`, ''];

  // Description
  const commandDescription = helper.commandDescription(cmd);
  if (commandDescription.length > 0) {
    output = output.concat([helper.wrap(commandDescription, helpWidth, 0), '']);
  }

  // Arguments
  const argumentList = helper.visibleArguments(cmd).map((argument) => {
    return formatItem(
      helper.argumentTerm(argument),
      helper.argumentDescription(argument),
    );
  });
  if (argumentList.length > 0) {
    output = output.concat([
      chalk.dim.bold('Arguments'),
      formatList(argumentList),
      '',
    ]);
  }
  const [visibleOptions, visibleGlobalOptions] = getLocalAndGlobalOptions(
    cmd,
    helper,
  );

  // Options
  const optionList = visibleOptions.map((option) => {
    return formatItem(
      helper.optionTerm(option),
      helper.optionDescription(option),
    );
  });
  if (optionList.length > 0) {
    output = output.concat([
      chalk.dim.bold('Options'),
      formatList(optionList),
      '',
    ]);
  }
  // Commands
  const commandList = helper.visibleCommands(cmd).map((cmd) => {
    return formatItem(
      helper.subcommandTerm(cmd),
      helper.subcommandDescription(cmd),
    );
  });
  if (commandList.length > 0) {
    output = output.concat([
      chalk.dim.bold('Commands'),
      formatList(commandList),
      '',
    ]);
  }

  if (this.showGlobalOptions) {
    const globalOptionList = visibleGlobalOptions.map((option) => {
      return formatItem(
        helper.optionTerm(option),
        helper.optionDescription(option),
      );
    });
    if (globalOptionList.length > 0) {
      output = output.concat([
        chalk.dim.bold('Global Options'),
        formatList(globalOptionList),
        '',
      ]);
    }
  }

  return output.join('\n');
}

program.configureHelp({
  showGlobalOptions: true,
  formatHelp,
});

function globalOption(flags, description, argParser) {
  const opt = new Option(flags, description);
  if (argParser) {
    opt.argParser(argParser);
  }
  // @ts-ignore
  // __global does not exist on `Option`,
  // but we use it in `getLocalAndGlobalOptions`, to produce
  // our own custom list of local and global options.
  // For more info, see the original PR:
  // https://github.com/instantdb/instant/pull/505
  opt.__global = true;
  return opt;
}

function warnDeprecation(oldCmd, newCmd) {
  warn(
    chalk.yellow('`instant-cli ' + oldCmd + '` is deprecated.') +
      ' Use ' +
      chalk.green('`instant-cli ' + newCmd + '`') +
      ' instead.' +
      '\n',
  );
}

program
  .name('instant-cli')
  .addOption(globalOption('-t --token <token>', 'Auth token override'))
  .addOption(globalOption('-y --yes', "Answer 'yes' to all prompts"))
  .addOption(
    globalOption('-v --version', 'Print the version number', () => {
      console.log(version);
      process.exit(0);
    }),
  )
  .addHelpOption(globalOption('-h --help', 'Print the help text for a command'))
  .usage(`<command> ${chalk.dim('[options] [args]')}`);

program
  .command('login')
  .description('Log into your account')
  .option('-p --print', 'Prints the auth token into the console.')
  .action(async (opts) => {
    console.log("Let's log you in!");
    await login(opts);
  });

program
  .command('init')
  .description('Set up a new project.')
  .option(
    '-a --app <app-id>',
    'If you have an existing app ID, we can pull schema and perms from there.',
  )
  .action(async function (opts) {
    await handlePull('all', opts);
  });

// Note: Nov 20, 2024
// We can eventually delete this,
// once we know most people use the new pull and push commands
program
  .command('push-schema', { hidden: true })
  .argument('[app-id]')
  .description('Push schema to production.')
  .option(
    '--skip-check-types',
    "Don't check types on the server when pushing schema",
  )
  .action(async (appIdOrName, opts) => {
    warnDeprecation('push-schema', 'push schema');
    await handlePush('schema', { app: appIdOrName, ...opts });
  });

// Note: Nov 20, 2024
// We can eventually delete this,
// once we know most people use the new pull and push commands
program
  .command('push-perms', { hidden: true })
  .argument('[app-id]')
  .description('Push perms to production.')
  .action(async (appIdOrName) => {
    warnDeprecation('push-perms', 'push perms');
    await handlePush('perms', { app: appIdOrName });
  });

program
  .command('push')
  .argument(
    '[schema|perms|all]',
    'Which configuration to push. Defaults to `all`',
  )
  .option(
    '-a --app <app-id>',
    'App ID to push too. Defaults to *_INSTANT_APP_ID in .env',
  )
  .option(
    '--skip-check-types',
    "Don't check types on the server when pushing schema",
  )
  .description('Push schema and perm files to production.')
  .action(async function (arg, inputOpts) {
    const ret = convertPushPullToCurrentFormat('push', arg, inputOpts);
    if (!ret.ok) return;
    const { bag, opts } = ret;
    await handlePush(bag, opts);
  });

// Note: Nov 20, 2024
// We can eventually delete this,
// once we know most people use the new pull and push commands
program
  .command('pull-schema', { hidden: true })
  .argument('[app-id]')
  .description('Generate instant.schema.ts from production')
  .action(async (appIdOrName) => {
    warnDeprecation('pull-schema', 'pull schema');
    await handlePull('schema', { app: appIdOrName });
  });

// Note: Nov 20, 2024
// We can eventually delete this,
// once we know most people use the new pull and push commands
program
  .command('pull-perms', { hidden: true })
  .argument('[app-id]')
  .description('Generate instant.perms.ts from production.')
  .action(async (appIdOrName) => {
    warnDeprecation('pull-perms', 'pull perms');
    await handlePull('perms', { app: appIdOrName });
  });

program
  .command('pull')
  .argument(
    '[schema|perms|all]',
    'Which configuration to push. Defaults to `all`',
  )
  .option(
    '-a --app <app-id>',
    'App ID to push to. Defaults to *_INSTANT_APP_ID in .env',
  )
  .description('Pull schema and perm files from production.')
  .action(async function (arg, inputOpts) {
    const ret = convertPushPullToCurrentFormat('pull', arg, inputOpts);
    if (!ret.ok) return;
    const { bag, opts } = ret;
    await handlePull(bag, opts);
  });

program.parse(process.argv);

// command actions
async function handlePush(bag, opts) {
  const pkgAndAuthInfo = await resolvePackageAndAuthInfoWithErrorLogging();
  if (!pkgAndAuthInfo) return;
  const { ok, appId } = await detectOrCreateAppAndWriteToEnv(
    pkgAndAuthInfo,
    opts,
  );
  if (!ok) return;
  await push(bag, appId, opts);
}

async function push(bag, appId, opts) {
  if (bag === 'schema' || bag === 'all') {
    const { ok } = await pushSchema(appId, opts);
    if (!ok) return;
  }
  if (bag === 'perms' || bag === 'all') {
    await pushPerms(appId);
  }
}

function printDotEnvInfo(envType, appId) {
  console.log(`\nPicked app ${chalk.green(appId)}!\n`);
  console.log(
    `To use this app automatically from now on, update your ${chalk.green('`.env`')} file:`,
  );
  const picked = potentialEnvs[envType];
  const rest = { ...potentialEnvs };
  delete rest[envType];
  console.log(`  ${chalk.green(picked)}=${appId}`);
  const otherEnvs = Object.values(rest);
  otherEnvs.sort();
  const otherEnvStr = otherEnvs.map((x) => '  ' + chalk.green(x)).join('\n');
  console.log(`Alternative names: \n${otherEnvStr} \n`);
  console.log(terminalLink('Dashboard', appDashUrl(appId)) + '\n');
}

async function handleEnvFile(pkgAndAuthInfo, appId) {
  const { pkgDir } = pkgAndAuthInfo;
  const envType = await detectEnvType(pkgAndAuthInfo);
  const envName = potentialEnvs[envType];

  const hasEnvFile = await pathExists(join(pkgDir, '.env'));
  if (hasEnvFile) {
    printDotEnvInfo(envType, appId);
    return;
  }
  console.log(
    `\nLooks like you don't have a ${chalk.green('`.env`')} file yet.`,
  );
  console.log(
    `If we set ${chalk.green('`' + envName + '`')}, we can remember the app that you chose for all future commands.`,
  );
  const ok = await promptOk(
    'Want us to create this env file for you?',
    /*defaultAnswer=*/ true,
  );
  if (!ok) {
    console.log(
      `No .env file created. You can always set ${chalk.green('`' + envName + '`')} later. \n`,
    );
    return;
  }
  await writeFile(join(pkgDir, '.env'), `${envName}=${appId}`, 'utf-8');
  console.log(`Created ${chalk.green('`.env`')} file!`);
}

async function detectOrCreateAppAndWriteToEnv(pkgAndAuthInfo, opts) {
  const ret = await detectOrCreateAppWithErrorLogging(opts);
  if (!ret.ok) return ret;
  const { appId, source } = ret;
  if (source === 'created' || source === 'imported') {
    await handleEnvFile(pkgAndAuthInfo, appId);
  }
  return ret;
}

async function handlePull(bag, opts) {
  const pkgAndAuthInfo = await resolvePackageAndAuthInfoWithErrorLogging();
  if (!pkgAndAuthInfo) return;
  const { ok, appId } = await detectOrCreateAppAndWriteToEnv(
    pkgAndAuthInfo,
    opts,
  );
  if (!ok) return;
  await pull(bag, appId, pkgAndAuthInfo);
}

async function pull(bag, appId, pkgAndAuthInfo) {
  if (bag === 'schema' || bag === 'all') {
    const { ok } = await pullSchema(appId, pkgAndAuthInfo);
    if (!ok) return;
  }
  if (bag === 'perms' || bag === 'all') {
    await pullPerms(appId, pkgAndAuthInfo);
  }
}

async function login(options) {
  const registerRes = await fetchJson({
    method: 'POST',
    path: '/dash/cli/auth/register',
    debugName: 'Login register',
    errorMessage: 'Failed to register login.',
    noAuth: true,
  });

  if (!registerRes.ok) return;

  const { secret, ticket } = registerRes.data;

  const ok = await promptOk(
    `This will open instantdb.com in your browser, OK to proceed?`,
    /*defaultAnswer=*/ true,
  );

  if (!ok) return;

  openInBrowser(`${instantDashOrigin}/dash?ticket=${ticket}`);

  console.log('Waiting for authentication...');
  const authTokenRes = await waitForAuthToken({ secret });
  if (!authTokenRes) {
    return;
  }

  const { token, email } = authTokenRes;

  if (options.print) {
    console.log(chalk.red('[Do not share] Your Instant auth token:', token));
  } else {
    await saveConfigAuthToken(token);
    console.log(chalk.green(`Successfully logged in as ${email}!`));
  }
  return token;
}

async function getOrInstallInstantModuleWithErrorLogging(pkgDir) {
  const pkgJson = await getPackageJSONWithErrorLogging(pkgDir);
  if (!pkgJson) {
    return;
  }
  console.log('Checking for an Instant SDK...');
  const instantModuleName = await getInstantModuleName(pkgJson);
  if (instantModuleName) {
    console.log(
      `Found ${chalk.green(instantModuleName)} in your package.json.`,
    );
    return instantModuleName;
  }
  console.log(
    "Couldn't find an Instant SDK in your package.json, let's install one!",
  );
  const moduleName = await select({
    message: 'Which package would you like to use?',
    choices: [
      { name: '@instantdb/react', value: '@instantdb/react' },
      { name: '@instantdb/react-native', value: '@instantdb/react-native' },
      { name: '@instantdb/core', value: '@instantdb/core' },
      { name: '@instantdb/admin', value: '@instantdb/admin' },
    ],
  });

  const packageManager = await detectPackageManager(pkgDir);
  const installCommand = getInstallCommand(packageManager, moduleName);

  const spinner = ora(
    `Installing ${moduleName} using ${packageManager}...`,
  ).start();

  try {
    await execAsync(installCommand, pkgDir);
    spinner.succeed(`Installed ${moduleName} using ${packageManager}.`);
  } catch (e) {
    spinner.fail(`Failed to install ${moduleName} using ${packageManager}.`);
    error(e.message);
    return;
  }

  return moduleName;
}

async function promptCreateApp() {
  const id = randomUUID();
  const token = randomUUID();
  const _title = await input({
    message: 'What would you like to call it?',
    default: 'My cool app',
    required: true,
  }).catch(() => null);

  const title = _title?.trim();

  if (!title) {
    error('No name provided. Exiting.');
    return { ok: false };
  }
  const app = { id, title, admin_token: token };
  const appRes = await fetchJson({
    method: 'POST',
    path: '/dash/apps',
    debugName: 'App create',
    errorMessage: 'Failed to create app.',
    body: app,
  });

  if (!appRes.ok) return { ok: false };
  return {
    ok: true,
    appId: id,
    appTitle: title,
    source: 'created',
  };
}

async function promptImportAppOrCreateApp() {
  const res = await fetchJson({
    debugName: 'Fetching apps',
    method: 'GET',
    path: '/dash',
    errorMessage: 'Failed to fetch apps.',
  });
  if (!res.ok) {
    return { ok: false };
  }
  const { apps } = res.data;
  if (!apps.length) {
    const ok = await promptOk(
      "You don't have any apps. Want to create a new one?",
      /*defaultAnswer=*/ true,
    );
    if (!ok) return { ok: false };
    return await promptCreateApp();
  }

  apps.sort((a, b) => +new Date(b.created_at) - +new Date(a.created_at));

  const choice = await select({
    message: 'Which app would you like to import?',
    choices: res.data.apps.map((app) => {
      return { name: `${app.title} (${app.id})`, value: app.id };
    }),
  }).catch(() => null);
  if (!choice) return { ok: false };
  return { ok: true, appId: choice, source: 'imported' };
}

async function detectOrCreateAppWithErrorLogging(opts) {
  const fromOpts = await detectAppIdFromOptsWithErrorLogging(opts);
  if (!fromOpts.ok) return fromOpts;
  if (fromOpts.appId) {
    return { ok: true, appId: fromOpts.appId, source: 'opts' };
  }

  const fromEnv = detectAppIdFromEnvWithErrorLogging();
  if (!fromEnv.ok) return fromEnv;
  if (fromEnv.found) {
    const { envName, value } = fromEnv.found;
    console.log(`Found ${chalk.green(envName)}: ${value}`);
    return { ok: true, appId: value, source: 'env' };
  }

  const action = await select({
    message: 'What would you like to do?',
    choices: [
      { name: 'Create a new app', value: 'create' },
      { name: 'Import an existing app', value: 'import' },
    ],
  }).catch(() => null);

  if (action === 'create') {
    return await promptCreateApp();
  }

  return await promptImportAppOrCreateApp();
}

async function writeTypescript(path, content, encoding) {
  const prettierConfig = await prettier.resolveConfig(path);
  const formattedCode = await prettier.format(content, {
    ...prettierConfig,
    parser: 'typescript',
  });
  return await writeFile(path, formattedCode, encoding);
}

async function getInstantModuleName(pkgJson) {
  const deps = pkgJson.dependencies || {};
  const instantModuleName = [
    '@instantdb/react',
    '@instantdb/react-native',
    '@instantdb/core',
    '@instantdb/admin',
  ].find((name) => deps[name]);
  return instantModuleName;
}

async function getPackageJson(pkgDir) {
  return await readJsonFile(join(pkgDir, 'package.json'));
}

async function getPackageJSONWithErrorLogging(pkgDir) {
  const pkgJson = await getPackageJson(pkgDir);
  if (!pkgJson) {
    error(`Couldn't find a packge.json file in: ${pkgDir}. Please add one.`);
    return;
  }
  return pkgJson;
}

async function resolvePackageAndAuthInfoWithErrorLogging() {
  const pkgDir = await packageDirectoryWithErrorLogging();
  if (!pkgDir) {
    return;
  }
  const instantModuleName =
    await getOrInstallInstantModuleWithErrorLogging(pkgDir);
  if (!instantModuleName) {
    return;
  }
  const authToken = await readAuthTokenOrLoginWithErrorLogging();
  if (!authToken) {
    return;
  }
  return { pkgDir, instantModuleName, authToken };
}

async function pullSchema(appId, { pkgDir, instantModuleName }) {
  console.log('Pulling schema...');

  const pullRes = await fetchJson({
    path: `/dash/apps/${appId}/schema/pull`,
    debugName: 'Schema pull',
    errorMessage: 'Failed to pull schema.',
  });

  if (!pullRes.ok) return pullRes;

  if (
    !countEntities(pullRes.data.schema.refs) &&
    !countEntities(pullRes.data.schema.blobs)
  ) {
    console.log('Schema is empty. Skipping.');
    return { ok: true };
  }
  const prev = await readLocalSchemaFile();
  if (prev) {
    const shouldContinue = await promptOk(
      'This will overwrite your local instant.schema file, OK to proceed?',
    );

    if (!shouldContinue) return { ok: true };
  }

  const schemaPath = join(pkgDir, getSchemaPathToWrite(prev?.path));

  await writeTypescript(
    schemaPath,
    generateSchemaTypescriptFile(
      prev?.schema,
      pullRes.data.schema,
      instantModuleName,
    ),
    'utf-8',
  );

  console.log('✅ Wrote schema to instant.schema.ts');

  return { ok: true };
}

async function pullPerms(appId, { pkgDir, instantModuleName }) {
  console.log('Pulling perms...');

  const pullRes = await fetchJson({
    path: `/dash/apps/${appId}/perms/pull`,
    debugName: 'Perms pull',
    errorMessage: 'Failed to pull perms.',
  });

  if (!pullRes.ok) return;
  const prev = await readLocalPermsFile();
  if (prev) {
    const shouldContinue = await promptOk(
      'This will overwrite your local instant.perms file, OK to proceed?',
    );

    if (!shouldContinue) return { ok: true };
  }

  const permsPath = join(pkgDir, getPermsPathToWrite(prev?.path));
  await writeTypescript(
    permsPath,
    generatePermsTypescriptFile(pullRes.data.perms || {}, instantModuleName),
    'utf-8',
  );

  console.log('✅ Wrote permissions to instant.perms.ts');

  return true;
}

function indexingJobCompletedActionMessage(job) {
  if (job.job_type === 'check-data-type') {
    return `setting type of ${job.attr_name} to ${job.checked_data_type}`;
  }
  if (job.job_type === 'remove-data-type') {
    return `removing type from ${job.attr_name}`;
  }
  if (job.job_type === 'index') {
    return `adding index to ${job.attr_name}`;
  }
  if (job.job_type === 'remove-index') {
    return `removing index from ${job.attr_name}`;
  }
  if (job.job_type === 'unique') {
    return `adding uniqueness constraint to ${job.attr_name}`;
  }
  if (job.job_type === 'remove-unique') {
    return `removing uniqueness constraint from ${job.attr_name}`;
  }
}

function truncate(s, maxLen) {
  if (s.length > maxLen) {
    return `${s.substr(0, maxLen - 3)}...`;
  }
  return s;
}

function formatSamples(triples_samples) {
  return triples_samples.slice(0, 3).map((t) => {
    return { ...t, value: truncate(JSON.stringify(t.value), 32) };
  });
}

function indexingJobCompletedMessage(job) {
  const actionMessage = indexingJobCompletedActionMessage(job);
  if (job.job_status === 'canceled') {
    return `Canceled ${actionMessage} before it could finish.`;
  }
  if (job.job_status === 'completed') {
    return `Finished ${actionMessage}.`;
  }
  if (job.job_status === 'errored') {
    if (job.invalid_triples_sample?.length) {
      const [etype, label] = job.attr_name.split('.');
      const samples = formatSamples(job.invalid_triples_sample);
      const longestValue = samples.reduce(
        (acc, { value }) => Math.max(acc, value.length),
        // Start with length of label
        label.length,
      );

      let msg = `${chalk.red('INVALID DATA')} ${actionMessage}.\n`;
      if (job.invalid_unique_value) {
        msg += `  Found multiple entities with value ${truncate(JSON.stringify(job.invalid_unique_value), 64)}.\n`;
      }
      if (job.error === 'triple-too-large-error') {
        msg += `  Some of the existing data is too large to index.\n`;
      }
      msg += `  First few examples:\n`;
      msg += `  ${chalk.bold('id')}${' '.repeat(35)}| ${chalk.bold(label)}${' '.repeat(longestValue - label.length)} | ${chalk.bold('type')}\n`;
      msg += `  ${'-'.repeat(37)}|${'-'.repeat(longestValue + 2)}|--------\n`;
      for (const triple of samples) {
        const urlParams = new URLSearchParams({
          s: 'main',
          app: job.app_id,
          t: 'explorer',
          ns: etype,
          where: JSON.stringify(['id', triple.entity_id]),
        });
        const url = new URL(instantDashOrigin);
        url.pathname = '/dash';
        url.search = urlParams.toString();

        const link = terminalLink(triple.entity_id, url.toString(), {
          fallback: () => triple.entity_id,
        });
        msg += `  ${link} | ${triple.value}${' '.repeat(longestValue - triple.value.length)} | ${triple.json_type}\n`;
      }
      return msg;
    }
    return `Error ${actionMessage}.`;
  }
}

function joinInSentence(items) {
  if (items.length === 0) {
    return '';
  }
  if (items.length === 1) {
    return items[0];
  }
  if (items.length === 2) {
    return `${items[0]} and ${items[1]}`;
  }
  return `${items.slice(0, -1).join(', ')}, and ${items[items.length - 1]}`;
}

function jobGroupDescription(jobs) {
  const actions = new Set();
  const jobActions = {
    'check-data-type': 'updating types',
    'remove-data-type': 'updating types',
    index: 'updating indexes',
    'remove-index': 'updating indexes',
    unique: 'updating uniqueness constraints',
    'remove-unique': 'updating uniqueness constraints',
  };
  for (const job of jobs) {
    actions.add(jobActions[job.job_type]);
  }
  return joinInSentence([...actions].sort()) || 'updating schema';
}

async function waitForIndexingJobsToFinish(appId, data) {
  const spinner = ora({
    text: 'checking data types',
  }).start();
  const groupId = data['group-id'];
  let jobs = data.jobs;
  let waitMs = 20;
  let lastUpdatedAt = new Date(0);

  const completedIds = new Set();

  const completedMessages = [];
  const errorMessages = [];

  while (true) {
    let stillRunning = false;
    let updated = false;
    let workEstimateTotal = 0;
    let workCompletedTotal = 0;

    for (const job of jobs) {
      const updatedAt = new Date(job.updated_at);
      if (updatedAt > lastUpdatedAt) {
        updated = true;
        lastUpdatedAt = updatedAt;
      }
      if (job.job_status === 'waiting' || job.job_status === 'processing') {
        stillRunning = true;
        // Default estimate to high value to prevent % from jumping around
        workEstimateTotal += job.work_estimate ?? 50000;
        workCompletedTotal += job.work_completed ?? 0;
      } else {
        if (!completedIds.has(job.id)) {
          completedIds.add(job.id);
          const msg = indexingJobCompletedMessage(job);
          if (job.job_status === 'errored') {
            errorMessages.push(msg);
          } else {
            completedMessages.push(msg);
          }
        }
      }
    }
    if (!stillRunning) {
      break;
    }
    if (workEstimateTotal) {
      const percent = Math.floor(
        (workCompletedTotal / workEstimateTotal) * 100,
      );
      spinner.text = `${jobGroupDescription(jobs)} ${percent}%`;
    }
    if (completedMessages.length) {
      spinner.prefixText = completedMessages.join('\n') + '\n';
    }
    waitMs = updated ? 1 : Math.min(10000, waitMs * 2);
    await sleep(waitMs);
    const res = await fetchJson({
      debugName: 'Check indexing status',
      method: 'GET',
      path: `/dash/apps/${appId}/indexing-jobs/group/${groupId}`,
      errorMessage: 'Failed to check indexing status.',
    });
    if (!res.ok) {
      break;
    }
    jobs = res.data.jobs;
  }
  spinner.stopAndPersist({
    text: '',
    prefixText: completedMessages.join('\n'),
  });

  // Log errors at the end so that they're easier to see.
  if (errorMessages.length) {
    for (const msg of errorMessages) {
      console.log(msg);
    }
    console.log(chalk.red('Some steps failed while updating schema.'));
    process.exit(1);
  }
}

async function pushSchema(appId, opts) {
  const res = await readLocalSchemaFileWithErrorLogging();
  if (!res) return { ok: false };
  const { schema } = res;
  console.log('Planning schema...');

  const planRes = await fetchJson({
    method: 'POST',
    path: `/dash/apps/${appId}/schema/push/plan`,
    debugName: 'Schema plan',
    errorMessage: 'Failed to update schema.',
    body: {
      schema,
      check_types: !opts?.skipCheckTypes,
      supports_background_updates: true,
    },
  });

  if (!planRes.ok) return planRes;

  if (!planRes.data.steps.length) {
    console.log('No schema changes detected. Skipping.');
    return { ok: true };
  }

  console.log(
    'The following changes will be applied to your production schema:',
  );

  for (const [action, attr] of planRes.data.steps) {
    switch (action) {
      case 'add-attr':
      case 'update-attr': {
        const valueType = attr['value-type'];
        const isAdd = action === 'add-attr';
        if (valueType === 'blob' && attrFwdLabel(attr) === 'id') {
          console.log(
            `${isAdd ? chalk.magenta('ADD ENTITY') : chalk.magenta('UPDATE ENTITY')} ${attrFwdName(attr)}`,
          );
          break;
        }

        if (valueType === 'blob') {
          console.log(
            `${isAdd ? chalk.green('ADD ATTR') : chalk.blue('UPDATE ATTR')} ${attrFwdName(attr)} :: unique=${attr['unique?']}, indexed=${attr['index?']}`,
          );
          break;
        }

        console.log(
          `${isAdd ? chalk.green('ADD LINK') : chalk.blue('UPDATE LINK')} ${attrFwdName(attr)} <=> ${attrRevName(attr)}`,
        );
        break;
      }
      case 'check-data-type': {
        console.log(
          `${chalk.green('CHECK TYPE')} ${attrFwdName(attr)} => ${attr['checked-data-type']}`,
        );
        break;
      }
      case 'remove-data-type': {
        console.log(`${chalk.red('REMOVE TYPE')} ${attrFwdName(attr)} => any`);
        break;
      }
      case 'index': {
        console.log('%s on %s', chalk.green('ADD INDEX'), attrFwdName(attr));
        break;
      }
      case 'remove-index': {
        console.log('%s on %s', chalk.red('REMOVE INDEX'), attrFwdName(attr));
        break;
      }
      case 'unique': {
        console.log(
          '%s to %s',
          chalk.green('ADD UNIQUE CONSTRAINT'),
          attrFwdName(attr),
        );
        break;
      }
      case 'remove-unique': {
        console.log(
          '%s from %s',
          chalk.red('REMOVE UNIQUE CONSTRAINT'),
          attrFwdName(attr),
        );
        break;
      }
    }
  }

  const okPush = await promptOk('OK to proceed?');
  if (!okPush) return { ok: true };

  const applyRes = await fetchJson({
    method: 'POST',
    path: `/dash/apps/${appId}/schema/push/apply`,
    debugName: 'Schema apply',
    errorMessage: 'Failed to update schema.',
    body: {
      schema,
      check_types: !opts?.skipCheckTypes,
      supports_background_updates: true,
    },
  });

  if (!applyRes.ok) return applyRes;

  if (applyRes.data['indexing-jobs']) {
    await waitForIndexingJobsToFinish(appId, applyRes.data['indexing-jobs']);
  }

  console.log(chalk.green('Schema updated!'));

  return { ok: true };
}

async function pushPerms(appId) {
  const res = await readLocalPermsFileWithErrorLogging();
  if (!res) {
    return;
  }

  console.log('Planning perms...');

  const prodPerms = await fetchJson({
    path: `/dash/apps/${appId}/perms/pull`,
    debugName: 'Perms pull',
    errorMessage: 'Failed to pull perms.',
  });

  if (!prodPerms.ok) return;

  const diffedStr = jsonDiff.diffString(
    prodPerms.data.perms || {},
    res.perms || {},
  );
  if (!diffedStr.length) {
    console.log('No perms changes detected. Exiting.');
    return;
  }

  console.log('The following changes will be applied to your perms:');
  console.log(diffedStr);

  const okPush = await promptOk('OK to proceed?');
  if (!okPush) return;

  const permsRes = await fetchJson({
    method: 'POST',
    path: `/dash/apps/${appId}/rules`,
    debugName: 'Schema apply',
    errorMessage: 'Failed to update schema.',
    body: {
      code: res.perms,
    },
  });

  if (!permsRes.ok) return;

  console.log(chalk.green('Permissions updated!'));

  return true;
}

async function waitForAuthToken({ secret }) {
  for (let i = 1; i <= 120; i++) {
    await sleep(1000);
    const authCheckRes = await fetchJson({
      method: 'POST',
      debugName: 'Auth check',
      errorMessage: 'Failed to check auth status.',
      path: '/dash/cli/auth/check',
      body: { secret },
      noAuth: true,
      noLogError: true,
    });
    if (authCheckRes.ok) {
      return authCheckRes.data;
    }
    if (authCheckRes.data?.hint.errors?.[0]?.issue === 'waiting-for-user') {
      continue;
    }
    error('Failed to authenticate ');
    prettyPrintJSONErr(authCheckRes.data);
    return;
  }
  error('Timed out waiting for authentication');
  return null;
}

// resources

/**
 * Fetches JSON data from a specified path using the POST method.
 *
 * @param {Object} options
 * @param {string} options.debugName
 * @param {string} options.errorMessage
 * @param {string} options.path
 * @param {'POST' | 'GET'} [options.method]
 * @param {Object} [options.body=undefined]
 * @param {boolean} [options.noAuth]
 * @param {boolean} [options.noLogError]
 * @returns {Promise<{ ok: boolean; data: any }>}
 */
async function fetchJson({
  debugName,
  errorMessage,
  path,
  body,
  method,
  noAuth,
  noLogError,
}) {
  const withAuth = !noAuth;
  const withErrorLogging = !noLogError;
  let authToken = null;
  if (withAuth) {
    authToken = await readConfigAuthTokenWithErrorLogging();
    if (!authToken) {
      return { ok: false, data: undefined };
    }
  }
  const timeoutMs = 1000 * 60 * 5; // 5 minutes

  try {
    const res = await fetch(`${instantBackendOrigin}${path}`, {
      method: method ?? 'GET',
      headers: {
        ...(withAuth ? { Authorization: `Bearer ${authToken}` } : {}),
        'Content-Type': 'application/json',
        'Instant-CLI-Version': version,
      },
      body: body ? JSON.stringify(body) : undefined,
      signal: AbortSignal.timeout(timeoutMs),
    });

    if (verbose) {
      console.log(debugName, 'response:', res.status, res.statusText);
    }

    let data;
    try {
      data = await res.json();
    } catch {
      data = null;
    }
    if (verbose && data) {
      console.log(debugName, 'json:', JSON.stringify(data, null, 2));
    }
    if (!res.ok) {
      if (withErrorLogging) {
        error(errorMessage);
        prettyPrintJSONErr(data);
      }
      return { ok: false, data };
    }

    return { ok: true, data };
  } catch (err) {
    if (withErrorLogging) {
      if (err.name === 'AbortError') {
        error(
          `Timeout: It took more than ${timeoutMs / 60000} minutes to get the result.`,
        );
      } else {
        error(`Error: type: ${err.name}, message: ${err.message}`);
      }
    }
    return { ok: false, data: null };
  }
}

function prettyPrintJSONErr(data) {
  if (data?.message) {
    error(data.message);
  }
  if (Array.isArray(data?.hint?.errors)) {
    for (const err of data.hint.errors) {
      error(`${err.in ? err.in.join('->') + ': ' : ''}${err.message}`);
    }
  }
  if (!data) {
    error('Failed to parse error response');
  }
}

async function promptOk(message, defaultAnswer = false) {
  const options = program.opts();

  if (options.yes) return true;
  return await toggle({
    message,
    default: defaultAnswer,
    theme: {
      style: {
        highlight: (x) => chalk.underline.blue(x),
        answer: (x) => chalk.underline.blue(x),
      },
    },
  }).catch(() => false);
}

/**
 * We need to do a bit of a hack of `@instantdb/react-native`.
 *
 * If a user writes import { i } from '@instantdb/react-native'
 *
 * We will fail to evaluate the file. This is because
 * `@instantdb/react-native` brings in `react-native`, which
 * does not run in a node context.
 *
 * To bypass this, we have a 'cli' module inside `react-native`, which
 * has all the necessary imports
 */
function transformImports(code) {
  return code.replace(
    /"@instantdb\/react-native"/g,
    '"@instantdb/react-native/dist/cli"',
  );
}

function getEnvPermsPathWithLogging() {
  const path = process.env.INSTANT_PERMS_FILE_PATH;
  if (path) {
    console.log(
      `Using INSTANT_PERMS_FILE_PATH=${chalk.green(process.env.INSTANT_PERMS_FILE_PATH)}`,
    );
  }
  return path;
}

function getPermsReadCandidates() {
  const existing = getEnvPermsPathWithLogging();
  if (existing) return [{ files: existing, transform: transformImports }];
  return [
    {
      files: 'instant.perms',
      extensions: ['ts', 'mts', 'cts', 'js', 'mjs', 'cjs'],
      transform: transformImports,
    },
    {
      files: 'src/instant.perms',
      extensions: ['ts', 'mts', 'cts', 'js', 'mjs', 'cjs'],
      transform: transformImports,
    },
    {
      files: 'app/instant.perms',
      extensions: ['ts', 'mts', 'cts', 'js', 'mjs', 'cjs'],
      transform: transformImports,
    },
  ];
}

function getPermsPathToWrite(existingPath) {
  if (existingPath) return existingPath;
  if (process.env.INSTANT_PERMS_FILE_PATH) {
    return process.env.INSTANT_PERMS_FILE_PATH;
  }
  return 'instant.perms.ts';
}

async function readLocalPermsFile() {
  const readCandidates = getPermsReadCandidates();
  const res = await loadConfig({
    sources: readCandidates,
    merge: false,
  });
  if (!res.config) return;
  const relativePath = path.relative(process.cwd(), res.sources[0]);
  return { path: relativePath, perms: res.config };
}

async function readLocalPermsFileWithErrorLogging() {
  const res = await readLocalPermsFile();
  if (!res) {
    error(
      `We couldn't find your ${chalk.yellow('`instant.perms.ts`')} file. Make sure it's in the root directory.`,
    );
  }
  return res;
}

function getEnvSchemaPathWithLogging() {
  const path = process.env.INSTANT_SCHEMA_FILE_PATH;
  if (path) {
    console.log(
      `Using INSTANT_SCHEMA_FILE_PATH=${chalk.green(process.env.INSTANT_SCHEMA_FILE_PATH)}`,
    );
  }
  return path;
}

function getSchemaReadCandidates() {
  const existing = getEnvSchemaPathWithLogging();
  if (existing) return [{ files: existing, transform: transformImports }];
  return [
    {
      files: 'instant.schema',
      extensions: ['ts', 'mts', 'cts', 'js', 'mjs', 'cjs'],
      transform: transformImports,
    },
    {
      files: 'src/instant.schema',
      extensions: ['ts', 'mts', 'cts', 'js', 'mjs', 'cjs'],
      transform: transformImports,
    },
    {
      files: 'app/instant.schema',
      extensions: ['ts', 'mts', 'cts', 'js', 'mjs', 'cjs'],
      transform: transformImports,
    },
  ];
}

function getSchemaPathToWrite(existingPath) {
  if (existingPath) return existingPath;
  if (process.env.INSTANT_SCHEMA_FILE_PATH) {
    return process.env.INSTANT_SCHEMA_FILE_PATH;
  }
  return 'instant.schema.ts';
}

async function readLocalSchemaFile() {
  const readCandidates = getSchemaReadCandidates();
  const res = await loadConfig({
    sources: readCandidates,
    merge: false,
  });
  if (!res.config) return;
  const relativePath = path.relative(process.cwd(), res.sources[0]);
  return { path: relativePath, schema: res.config };
}

async function readInstantConfigFile() {
  return (
    await loadConfig({
      sources: [
        // load from `instant.config.xx`
        {
          files: 'instant.config',
          extensions: ['ts', 'mts', 'cts', 'js', 'mjs', 'cjs', 'json'],
        },
      ],
      // if false, the only the first matched will be loaded
      // if true, all matched will be loaded and deep merged
      merge: false,
    })
  ).config;
}

async function readLocalSchemaFileWithErrorLogging() {
  const res = await readLocalSchemaFile();

  if (!res) {
    error(
      `We couldn't find your ${chalk.yellow('`instant.schema.ts`')} file. Make sure it's in the root directory.`,
    );
    return;
  }

  if (res.schema?.constructor?.name !== 'InstantSchemaDef') {
    error("We couldn't find your schema export.");
    error(
      'In your ' +
        chalk.green('`instant.schema.ts`') +
        ' file, make sure you ' +
        chalk.green('`export default schema`'),
    );
    return;
  }

  return res;
}

async function readConfigAuthToken() {
  const options = program.opts();
  if (options.token) {
    return options.token;
  }

  if (process.env.INSTANT_CLI_AUTH_TOKEN) {
    return process.env.INSTANT_CLI_AUTH_TOKEN;
  }

  const authToken = await readFile(
    getAuthPaths().authConfigFilePath,
    'utf-8',
  ).catch(() => null);

  return authToken;
}

async function readConfigAuthTokenWithErrorLogging() {
  const token = await readConfigAuthToken();
  if (!token) {
    error(
      `Looks like you are not logged in. Please log in with ${chalk.green('`instant-cli login`')}`,
    );
  }
  return token;
}

async function readAuthTokenOrLoginWithErrorLogging() {
  const token = await readConfigAuthToken();
  if (token) return token;
  console.log(`Looks like you are not logged in...`);
  console.log(`Let's log in!`);
  return await login({});
}

async function saveConfigAuthToken(authToken) {
  const authPaths = getAuthPaths();

  await mkdir(authPaths.appConfigDirPath, {
    recursive: true,
  });

  return writeFile(authPaths.authConfigFilePath, authToken, 'utf-8');
}

function getAuthPaths() {
  const key = `instantdb-${dev ? 'dev' : 'prod'}`;
  const { config: appConfigDirPath } = envPaths(key);
  const authConfigFilePath = join(appConfigDirPath, 'a');

  return { authConfigFilePath, appConfigDirPath };
}

// utils

function sleep(ms) {
  return new Promise((resolve) => setTimeout(resolve, ms));
}

function countEntities(o) {
  return Object.keys(o).length;
}

function sortedEntries(o) {
  return Object.entries(o).sort(([a], [b]) => a.localeCompare(b));
}

function capitalizeFirstLetter(string) {
  return string.charAt(0).toUpperCase() + string.slice(1);
}

// attr helpers

function attrFwdLabel(attr) {
  return attr['forward-identity']?.[2];
}

function attrFwdEtype(attr) {
  return attr['forward-identity']?.[1];
}

function attrRevLabel(attr) {
  return attr['reverse-identity']?.[2];
}

function attrRevEtype(attr) {
  return attr['reverse-identity']?.[1];
}

function attrFwdName(attr) {
  return `${attrFwdEtype(attr)}.${attrFwdLabel(attr)}`;
}

function attrRevName(attr) {
  if (attr['reverse-identity']) {
    return `${attrRevEtype(attr)}.${attrRevLabel(attr)}`;
  }
}

// templates and constants

export const rels = {
  'many-false': ['many', 'many'],
  'one-true': ['one', 'one'],
  'many-true': ['many', 'one'],
  'one-false': ['one', 'many'],
};

const uuidRegex =
  /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;
function isUUID(uuid) {
  return uuidRegex.test(uuid);
}

async function detectAppIdFromOptsWithErrorLogging(opts) {
  if (!opts.app) return { ok: true };
  const appId = opts.app;
  const config = await readInstantConfigFile();
  const nameMatch = config?.apps?.[appId];
  const namedAppId = nameMatch?.id && isUUID(nameMatch.id) ? nameMatch : null;
  const uuidAppId = appId && isUUID(appId) ? appId : null;

  if (nameMatch && !namedAppId) {
    error(`Expected \`${appId}\` to point to a UUID, but got ${nameMatch.id}.`);
    return { ok: false };
  }
  if (!namedAppId && !uuidAppId) {
    error(`Expected App ID to be a UUID, but got: ${chalk.red(appId)}`);
    return { ok: false };
  }
  return { ok: true, appId: namedAppId || uuidAppId };
}

function detectAppIdFromEnvWithErrorLogging() {
  const found = Object.keys(potentialEnvs)
    .map((type) => {
      const envName = potentialEnvs[type];
      const value = process.env[envName];
      return { type, envName, value };
    })
    .find(({ value }) => !!value);
  if (found && !isUUID(found.value)) {
    error(
      `Found ${chalk.green('`' + found.envName + '`')} but it's not a valid UUID.`,
    );
    return { ok: false, found };
  }
  return { ok: true, found };
}

function appDashUrl(id) {
  return `${instantDashOrigin}/dash?s=main&t=home&app=${id}`;
}

function generatePermsTypescriptFile(perms, instantModuleName) {
  const rulesTxt =
    perms && Object.keys(perms).length
      ? JSON.stringify(perms, null, 2)
      : `
{
  /**
   * Welcome to Instant's permission system!
   * Right now your rules are empty. To start filling them in, check out the docs:
   * https://www.instantdb.com/docs/permissions
   *
   * Here's an example to give you a feel:
   * posts: {
   *   allow: {
   *     view: "true",
   *     create: "isOwner",
   *     update: "isOwner",
   *     delete: "isOwner",
   *   },
   *   bind: ["isOwner", "auth.id != null && auth.id == data.ownerId"],
   * },
   */
}
`.trim();
  return `
// Docs: https://www.instantdb.com/docs/permissions

import type { InstantRules } from "${instantModuleName ?? '@instantdb/core'}";

const rules = ${rulesTxt} satisfies InstantRules;

export default rules;
  `.trim();
}

function inferredType(config) {
  const inferredList = config['inferred-types'];
  const hasJustOne = inferredList?.length === 1;
  if (!hasJustOne) return null;
  return inferredList[0];
}

function deriveClientType(attr) {
  if (attr['checked-data-type']) {
    return { type: attr['checked-data-type'], origin: 'checked' };
  }
  const inferred = inferredType(attr);
  if (inferred) {
    return { type: inferred, origin: 'inferred' };
  }
  return { type: 'any', origin: 'unknown' };
}

function schemaBlobToCodeStr(name, attrs) {
  // a block of code for each entity
  return [
    `  `,
    `"${name}"`,
    `: `,
    `i.entity`,
    `({`,
    `\n`,
    // a line of code for each attribute in the entity
    sortedEntries(attrs)
      .filter(([name]) => name !== 'id')
      .map(([name, config]) => {
        const { type } = deriveClientType(config);

        return [
          `    `,
          `"${name}"`,
          `: `,
          `i.${type}()`,
          config['unique?'] ? '.unique()' : '',
          config['index?'] ? '.indexed()' : '',
          `,`,
        ].join('');
      })
      .join('\n'),
    `\n`,
    `  `,
    `})`,
    `,`,
  ].join('');
}

/**
 * Note:
 * This is _very_ similar to `schemaBlobToCodeStr`.
 *
 * Right now, the frontend and backend have slightly different data structures for storing entity info.
 *
 * The backend returns {etype: attrs}, where attr keep things like `value-type`
 * The frontend stores {etype: EntityDef}, where EntityDef has a `valueType` field.
 *
 * For now, keeping the two functions separate.
 */
function entityDefToCodeStr(name, edef) {
  // a block of code for each entity
  return [
    `  `,
    `"${name}"`,
    `: `,
    `i.entity`,
    `({`,
    `\n`,
    // a line of code for each attribute in the entity
    sortedEntries(edef.attrs)
      .map(([name, attr]) => {
        const type = attr['valueType'] || 'any';

        return [
          `    `,
          `"${name}"`,
          `: `,
          `i.${type}()`,
          attr?.config['unique'] ? '.unique()' : '',
          attr?.config['indexed'] ? '.indexed()' : '',
          `,`,
        ].join('');
      })
      .join('\n'),
    `\n`,
    `  `,
    `})`,
    `,`,
  ].join('');
}

function roomDefToCodeStr(room) {
  let ret = '{';
  if (room.presence) {
    ret += `${entityDefToCodeStr('presence', room.presence)}`;
  }
  if (room.topics) {
    ret += `topics: {`;
    for (const [topicName, topicConfig] of Object.entries(room.topics)) {
      ret += entityDefToCodeStr(topicName, topicConfig);
    }
    ret += `}`;
  }
  ret += '}';
  return ret;
}

function roomsCodeStr(rooms) {
  let ret = '{';
  for (const [roomType, roomDef] of Object.entries(rooms)) {
    ret += `"${roomType}": ${roomDefToCodeStr(roomDef)},`;
  }
  ret += '}';
  return ret;
}

function easyPlural(strn, n) {
  return n === 1 ? strn : strn + 's';
}

function generateSchemaTypescriptFile(
  prevSchema,
  newSchema,
  instantModuleName,
) {
  // entities
  const entitiesEntriesCode = sortedEntries(newSchema.blobs)
    .map(([name, attrs]) => schemaBlobToCodeStr(name, attrs))
    .join('\n');
  const inferredAttrs = Object.values(newSchema.blobs)
    .flatMap(Object.values)
    .filter(
      (attr) =>
        attrFwdLabel(attr) !== 'id' &&
        deriveClientType(attr).origin === 'inferred',
    );

  const entitiesObjCode = `{\n${entitiesEntriesCode}\n}`;
  const etypes = Object.keys(newSchema.blobs);
  const hasOnlyUserTable = etypes.length === 1 && etypes[0] === '$users';
  const entitiesComment =
    inferredAttrs.length > 0
      ? `// We inferred ${inferredAttrs.length} ${easyPlural('attribute', inferredAttrs.length)}!
// Take a look at this schema, and if everything looks good,
// run \`push schema\` again to enforce the types.`
      : hasOnlyUserTable
        ? `
// This section lets you define entities: think \`posts\`, \`comments\`, etc
// Take a look at the docs to learn more:
// https://www.instantdb.com/docs/modeling-data#2-attributes
`.trim()
        : '';

  // links
  const linksEntries = Object.fromEntries(
    sortedEntries(newSchema.refs).map(([_name, config]) => {
      const [, fe, flabel] = config['forward-identity'];
      const [, re, rlabel] = config['reverse-identity'];
      const [fhas, rhas] = rels[`${config.cardinality}-${config['unique?']}`];
      return [
        `${fe}${capitalizeFirstLetter(flabel)}`,
        {
          forward: {
            on: fe,
            has: fhas,
            label: flabel,
          },
          reverse: {
            on: re,
            has: rhas,
            label: rlabel,
          },
        },
      ];
    }),
  );
  const linksEntriesCode = JSON.stringify(linksEntries, null, '  ').trim();
  const hasNoLinks = Object.keys(linksEntries).length === 0;
  const linksComment = hasNoLinks
    ? `
  // You can define links here.
  // For example, if \`posts\` should have many \`comments\`.
  // More in the docs:
  // https://www.instantdb.com/docs/modeling-data#3-links
  `.trim()
    : '';

  // rooms
  const rooms = prevSchema?.rooms || {};
  const roomsCode = roomsCodeStr(rooms);
  const roomsComment =
    Object.keys(rooms).length === 0
      ? `
// If you use presence, you can define a room schema here
// https://www.instantdb.com/docs/presence-and-topics#typesafety
  `.trim()
      : '';

  const kv = (k, v, comment) => {
    return comment
      ? `
        ${comment}
        ${k}: ${v}
      `.trim()
      : `${k}: ${v}`;
  };

  return `
import { i } from "${instantModuleName ?? '@instantdb/core'}";

const _schema = i.schema({
  ${kv('entities', entitiesObjCode, entitiesComment)},
  ${kv('links', linksEntriesCode, linksComment)},
  ${kv('rooms', roomsCode, roomsComment)}
});

// This helps Typescript display nicer intellisense
type _AppSchema = typeof _schema;
interface AppSchema extends _AppSchema {}
const schema: AppSchema = _schema;

export type { AppSchema }
export default schema;
`;
}
</file>

<file path="client/packages/cli/src/toggle.ts">
// From:
// https://github.com/skarahoda/inquirer-toggle
import type { Theme } from '@inquirer/core';
import type { Prompt } from '@inquirer/type';

import {
  isDownKey,
  isUpKey,
  useKeypress,
  useState,
  isEnterKey,
} from '@inquirer/core';
import { createPrompt, usePrefix, makeTheme } from '@inquirer/core';
import ansiEscapes from 'ansi-escapes';

type InquirerToggleConfig = {
  message: string;
  default?: boolean | undefined;
  theme?: {
    active?: string;
    inactive?: string;
    prefix?: Theme['prefix'];
    style?: {
      message?: Theme['style']['message'];
      answer?: Theme['style']['answer'];
      highlight?: Theme['style']['highlight'];
    };
  };
};

function isLeftKey(key) {
  return key.name === 'left';
}

function isRightKey(key) {
  return key.name === 'right';
}

const prompt: Prompt<boolean, InquirerToggleConfig> = createPrompt<
  boolean,
  InquirerToggleConfig
>((config, done) => {
  const theme = makeTheme({ active: 'yes', inactive: 'no' }, config.theme);
  const prefix = usePrefix({ theme });
  const [value, setValue] = useState(config.default ?? false);
  const [isDone, setIsDone] = useState(false);

  useKeypress((key) => {
    if (isEnterKey(key)) {
      setIsDone(true);
      done(value);
    } else if (
      isLeftKey(key) ||
      isRightKey(key) ||
      isUpKey(key) ||
      isDownKey(key)
    ) {
      setValue(!value);
    }
  });
  const message = theme.style.message(config.message);

  if (isDone) {
    return `${prefix} ${message} ${theme.style.answer(value ? theme.active : theme.inactive)}`;
  }

  const activeMessage = value
    ? theme.style.highlight(theme.active)
    : theme.active;
  const inactiveMessage = value
    ? theme.inactive
    : theme.style.highlight(theme.inactive);
  return `${prefix} ${message} ${inactiveMessage} / ${activeMessage}${ansiEscapes.cursorHide}`;
});

export default prompt;
</file>

<file path="client/packages/cli/src/version.js">
// Autogenerated by publish_packages.clj
const version = 'v0.17.22-dev';

export default version;
</file>

<file path="client/packages/cli/package.json">
{
  "name": "instant-cli",
  "type": "module",
  "version": "v0.17.22",
  "description": "Instant's CLI",
  "bin": {
    "instant-cli": "bin/index.js"
  },
  "dependencies": {
    "@inquirer/core": "9.0.10",
    "@inquirer/prompts": "5.3.8",
    "ansi-escapes": "4.3.2",
    "chalk": "^5.3.0",
    "commander": "^12.1.0",
    "dotenv": "^16.3.1",
    "env-paths": "^3.0.0",
    "inquirer": "^10.1.6",
    "json-diff": "^1.0.6",
    "open": "^10.1.0",
    "ora": "^8.1.1",
    "pkg-dir": "^8.0.0",
    "prettier": "^3.3.3",
    "terminal-link": "^3.0.0",
    "unconfig": "^0.5.5"
  },
  "scripts": {
    "test": "vitest",
    "build": "rm -rf dist; tsc -p tsconfig.json",
    "dev": "tsc -p tsconfig.json -w --skipLibCheck",
    "publish-package": "pnpm publish --access public --no-git-checks"
  },
  "devDependencies": {
    "@babel/core": "^7.17.9",
    "@babel/preset-env": "^7.16.11",
    "@inquirer/type": "^3.0.2",
    "@types/json-diff": "^1.0.3",
    "@types/node": "^22.6.1",
    "npm-run-all": "^4.1.5",
    "typescript": "^5.5.4"
  }
}
</file>

<file path="client/packages/cli/README.md">
<p align="center">
  <a href="https://instantdb.com">
    <img alt="Shows the Instant logo" src="https://instantdb.com/img/icon/android-chrome-512x512.png" width="10%">
  </a>
  <h1 align="center">instant-cli (beta)</h1>
</p>

<p align="center">
  <a 
    href="https://discord.com/invite/VU53p7uQcE" >
    <img height=20 src="https://img.shields.io/discord/1031957483243188235" />
  </a>
  <img src="https://img.shields.io/github/stars/instantdb/instant" alt="stars">
</p>

<p align="center">
   <a href="https://www.instantdb.com/docs/start-vanilla">Get Started</a> · 
   <a href="https://instantdb.com/examples">Examples</a> · 
   <a href="https://instantdb.com/tutorial">Try the Demo</a> · 
   <a href="https://www.instantdb.com/docs/start-vanilla">Docs</a> · 
   <a href="https://discord.com/invite/VU53p7uQcE">Discord</a>
<p>

Welcome to [Instant's](http://instantdb.com) command line tool. You can create apps, write schema, and push permissions.

```javascript
npx instant-cli init
```

## Get Started

Start by peeking at the [instant-cli docs](https://www.instantdb.com/docs/cli).

# Questions?

If you have any questions, feel free to drop us a line on our [Discord](https://discord.com/invite/VU53p7uQcE)
</file>

<file path="client/packages/cli/tsconfig.json">
{
  "extends": "../../tsconfig.base.json",
  "compilerOptions": {
    "module": "NodeNext",
    "moduleResolution": "nodenext",
    "outDir": "dist",
    "rootDir": "src",
    "skipLibCheck": true // `unconfig` currently imports a broken type from `@antfu/utils`
    // remove once fixed
  },
  "include": ["src"],
  "exclude": ["node_modules", "dist"]
}
</file>

<file path="client/packages/core/__example__/standalone.esm.html">
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Instant Core ESM standalone example/test</title>
  </head>
  <body>
    <!-- make sure to run `build:standalone` first! -->
    <!-- easiest way to test this is with `python3 -m http.server` in the root directory of this project -->
    <script type="module">
      import { init } from "/dist/standalone/index.mjs";

      const query = {};

      const db = init({
        appId: new URL(location.href).searchParams.get("app_id"),
      });

      const unsub = db.subscribeQuery(query, console.log);
    </script>
  </body>
</html>
</file>

<file path="client/packages/core/__example__/standalone.umd.html">
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Instant Core UMD standalone example/test</title>
  </head>
  <body>
    <!-- make sure to run `build:standalone` first! -->
    <script src="../dist/standalone/index.umd.js"></script>
    <script>
      const query = {};

      const db = instant.init({
        appId: new URL(location.href).searchParams.get("app_id"),
      });

      const unsub = db.subscribeQuery(query, console.log);
    </script>
  </body>
</html>
</file>

<file path="client/packages/core/src/model/instaqlResult.js">
function _extractTriplesHelper(idNodes, acc = []) {
  idNodes.forEach((idNode) => {
    const { data } = idNode;
    const { 'datalog-result': datalogResult } = data;
    const { 'join-rows': joinRows } = datalogResult;
    for (const rows of joinRows) {
      for (const triple of rows) {
        acc.push(triple);
      }
    }
    _extractTriplesHelper(idNode['child-nodes'], acc);
  });
}

/**
 * Marshall instaql-result into list of triples. Instaql-result may have
 * multiple datalog-results, each datalog-result may have multiple join-rows
 * and each join-row may have triples.The union of these triples may have
 * duplicates, so we dedup them.
 */
export function extractTriples(idNodes) {
  const triples = [];
  _extractTriplesHelper(idNodes, triples);
  return triples;
}
</file>

<file path="client/packages/core/src/utils/Deferred.js">
export class Deferred {
  promise;
  _resolve;
  _reject;

  constructor() {
    this.promise = new Promise((resolve, reject) => {
      this._resolve = resolve;
      this._reject = reject;
    });
  }

  resolve(value) {
    this._resolve(value);
  }

  reject(reason) {
    this._reject(reason);
  }
}
</file>

<file path="client/packages/core/src/utils/error.ts">
export function assert(condition: any, msg?: string): asserts condition {
  if (!condition) {
    throw new Error('[assertion error] ' + msg);
  }
}

export function assertUnreachable(_x: never): never {
  throw new Error('[assertion error] TS should prevent us from reaching here');
}
</file>

<file path="client/packages/core/src/utils/fetch.ts">
export async function jsonFetch(
  input: RequestInfo,
  init: RequestInit | undefined,
): Promise<any> {
  const res = await fetch(input, init);
  const json = await res.json();
  return res.status === 200
    ? Promise.resolve(json)
    : Promise.reject({ status: res.status, body: json });
}
</file>

<file path="client/packages/core/src/utils/flags.ts">
let devBackend = false;
let instantLogs = false;
let devtoolLocalDashboard = false;

if (
  typeof window !== 'undefined' &&
  typeof window.localStorage !== 'undefined'
) {
  devBackend = !!window.localStorage.getItem('devBackend');
  instantLogs = !!window.localStorage.getItem('__instantLogging');
  devtoolLocalDashboard = !!window.localStorage.getItem('__devtoolLocalDash');
}

export { devBackend, instantLogs, devtoolLocalDashboard };
</file>

<file path="client/packages/core/src/utils/linkIndex.ts">
import type { InstantGraph, LinkDef, LinksDef } from '../schemaTypes';

export type LinkIndex = Record<
  string,
  Record<
    string,
    {
      isForward: boolean;
      isSingular: boolean;
      link: LinkDef<any, any, any, any, any, any, any>;
    }
  >
>;

export function createLinkIndex(schema: InstantGraph<any, LinksDef<{}>>) {
  return Object.values(schema.links).reduce((linkIndex, link) => {
    linkIndex[link.forward.on] ??= {};
    linkIndex[link.forward.on][link.forward.label] = {
      isForward: true,
      isSingular: link.forward.has === 'one',
      link,
    };

    linkIndex[link.reverse.on] ??= {};
    linkIndex[link.reverse.on][link.reverse.label] = {
      isForward: false,
      isSingular: link.reverse.has === 'one',
      link,
    };

    return linkIndex;
  }, {} as LinkIndex);
}
</file>

<file path="client/packages/core/src/utils/log.ts">
import * as flags from './flags';

const isEnabled = flags.devBackend || flags.instantLogs;

const log = {
  info: isEnabled ? console.info.bind(console) : () => {},
  debug: isEnabled ? console.debug.bind(console) : () => {},
  error: isEnabled ? console.error.bind(console) : () => {},
};

export default log;
</file>

<file path="client/packages/core/src/utils/object.js">
export function areObjectKeysEqual(a, b) {
  const ak = Object.keys(a);
  const bk = Object.keys(b);
  return (
    ak.length === bk.length && Object.keys(a).every((k) => b.hasOwnProperty(k))
  );
}

export function areObjectsShallowEqual(obj1, obj2) {
  return (
    Object.keys(obj1).length === Object.keys(obj2).length &&
    Object.keys(obj1).every(
      (key) => obj2.hasOwnProperty(key) && obj1[key] === obj2[key],
    )
  );
}

export function areObjectsDeepEqual(obj1, obj2) {
  if (
    typeof obj1 !== 'object' ||
    typeof obj2 !== 'object' ||
    obj1 === null ||
    obj2 === null
  ) {
    return obj1 === obj2;
  }

  if (!areObjectKeysEqual(obj1, obj2)) {
    return false;
  }

  return Object.keys(obj1).every((key) =>
    areObjectsDeepEqual(obj1[key], obj2[key]),
  );
}

export function immutableDeepMerge(target, source) {
  if (!isObject(target) || !isObject(source)) {
    return source;
  }

  const result = {};

  for (const key of Object.keys(target)) {
    if (source[key] === null) continue;

    result[key] = target[key];
  }

  for (const key of Object.keys(source)) {
    if (source[key] === null) continue;

    const areBothObjects = isObject(target[key]) && isObject(source[key]);

    result[key] = areBothObjects
      ? immutableDeepMerge(target[key], source[key])
      : source[key];
  }

  return result;
}

export function immutableDeepReplace(target, replaceValue, replacementValue) {
  if (!isObject(target)) {
    return target;
  }

  const result = {};

  for (const [key, value] of Object.entries(target)) {
    result[key] = isObject(value)
      ? immutableDeepReplace(value, replaceValue, replacementValue)
      : value === replaceValue
        ? replacementValue
        : value;
  }

  return result;
}

export function isObject(val) {
  return typeof val === 'object' && val !== null && !Array.isArray(val);
}

export function assocIn(obj, path, value) {
  if (path.length === 0) {
    return value;
  }

  let current = obj || {};
  for (let i = 0; i < path.length - 1; i++) {
    const key = path[i];
    if (!(key in current) || typeof current[key] !== 'object') {
      current[key] = typeof path[i + 1] === 'number' ? [] : {};
    }
    current = current[key];
  }

  current[path[path.length - 1]] = value;
  return obj;
}

export function dissocIn(obj, path) {
  if (path.length === 0) {
    return undefined;
  }

  const [key, ...restPath] = path;

  if (!(key in obj)) {
    return obj;
  }

  if (restPath.length === 0) {
    delete obj[key];
    return isEmpty(obj) ? undefined : obj;
  }

  const child = dissocIn(obj[key], restPath);

  if (child === undefined) {
    delete obj[key];
    return isEmpty(obj) ? undefined : obj;
  }

  return obj;
}

function isEmpty(obj) {
  return obj && Object.keys(obj).length === 0;
}
</file>

<file path="client/packages/core/src/utils/PersistedObject.js">
// PersistedObjects save data outside of memory.
//
// When we load a persisted object, it's possible we call `set`
// before we finish loading. To address we handle set in two ways:
//
// 1. Before load
// We simply update currentValue in memory
//
// 2. After load
// We update currentValue in memory and in storage
//
// Each PersistedObject provides it's own `onMerge`
// function to handle the merge of data from storage and memory
// on load
export class PersistedObject {
  _subs = [];

  constructor(
    persister,
    key,
    defaultValue,
    onMerge,
    toJSON = (x) => {
      return JSON.stringify(x);
    },
    fromJSON = (x) => {
      return JSON.parse(x);
    },
    saveThrottleMs = 100,
  ) {
    this._persister = persister;
    this._key = key;

    this._onMerge = onMerge;

    this._loadedCbs = [];
    this._isLoading = true;
    this.currentValue = defaultValue;
    this.toJSON = toJSON;
    this.fromJSON = fromJSON;
    this._saveThrottleMs = saveThrottleMs;
    this._pendingSaveCbs = [];
    this._version = 0;

    this._load();
  }

  async _load() {
    const fromStorage = this.fromJSON(await this._persister.getItem(this._key));
    this._isLoading = false;

    this._onMerge(fromStorage, this.currentValue);
    for (const cb of this._loadedCbs) {
      cb();
    }
  }

  async waitForLoaded() {
    if (!this._isLoading) {
      return;
    }
    const loadedPromise = new Promise((resolve) => {
      this._loadedCbs.push(resolve);
    });
    await loadedPromise;
  }

  isLoading() {
    return this._isLoading;
  }

  version() {
    return this._version;
  }

  async waitForSync() {
    if (!this._nextSave) {
      return;
    }
    const syncedPromise = new Promise((resolve) => {
      this._pendingSaveCbs.push(resolve);
    });
    await syncedPromise;
  }

  _writeToStorage() {
    this._persister.setItem(this._key, this.toJSON(this.currentValue));
    for (const cb of this._pendingSaveCbs) {
      cb();
    }
    this._pendingSaveCbs.length = 0;
  }

  async flush() {
    if (!this._nextSave) {
      return;
    }
    clearTimeout(this._nextSave);
    this._writeToStorage();
  }

  _enqueuePersist(cb) {
    if (this._nextSave) {
      if (cb) {
        this._pendingSaveCbs.push(cb);
      }
      return;
    }
    this._nextSave = setTimeout(() => {
      this._nextSave = null;
      this._writeToStorage();
    }, this._saveThrottleMs);
  }

  set(f, cb) {
    this._version++;
    this.currentValue = f(this.currentValue);
    if (this._isLoading) {
      this._loadedCbs.push(() => this._enqueuePersist(cb));
    } else {
      this._enqueuePersist(cb);
    }
    for (const sub of this._subs) {
      sub(this.currentValue);
    }
  }

  subscribe(cb) {
    this._subs.push(cb);
    cb(this.currentValue);

    return () => {
      this._subs = this._subs.filter((x) => x !== cb);
    };
  }
}
</file>

<file path="client/packages/core/src/utils/pick.js">
export function pick(obj, keys) {
  if (!keys) return obj;

  const ret = {};
  keys.forEach((key) => {
    ret[key] = obj[key];
  });
  return ret;
}
</file>

<file path="client/packages/core/src/utils/uuid.ts">
import { v4 } from 'uuid';

function uuidToByteArray(uuid: string) {
  const hex = uuid.replace(/-/g, '');
  const bytes = [];
  for (let i = 0; i < hex.length; i += 2) {
    bytes.push(parseInt(hex.substring(i, i + 2), 16));
  }
  return bytes;
}

function compareByteArrays(a, b) {
  for (let i = 0; i < a.length; i++) {
    if (a[i] < b[i]) return -1;
    if (a[i] > b[i]) return 1;
  }
  return 0;
}

export function uuidCompare(uuid_a: string, uuid_b: string) {
  return compareByteArrays(uuidToByteArray(uuid_a), uuidToByteArray(uuid_b));
}

function id(): string {
  return v4();
}

export default id;
</file>

<file path="client/packages/core/src/utils/weakHash.ts">
/**
 *
 * Unique Hashing implementation inspired by djb2/fnv1a algorithms,
 * where we are not concerned with the hash being decoded.
 * Focuses on speed while maintaining good hash distribution
 *
 * Note: We could also use something like Murmurhash instead
 * https://github.com/jensyt/imurmurhash-js/blob/master/imurmurhash.js
 *
 * @param {any} input - Value to hash
 * @returns {string} - Hash in hex format
 */
export default function weakHash(input: any): string {
  // Handle primitives without JSON stringify for better performance
  if (typeof input === 'number') {
    // Use a larger number space for numeric values
    return (Math.abs(input * 2654435761) >>> 0).toString(16);
  }
  if (typeof input === 'boolean') return input ? '1' : '0';
  if (input === null) return 'null';
  if (input === undefined) return 'undefined';

  // For strings, use FNV-1a algorithm
  if (typeof input === 'string') {
    let hash = 0x811c9dc5; // FNV offset basis (32 bit)
    for (let i = 0; i < input.length; i++) {
      hash ^= input.charCodeAt(i);
      hash +=
        (hash << 1) + (hash << 4) + (hash << 7) + (hash << 8) + (hash << 24);
      hash = hash >>> 0; // Convert to unsigned 32-bit after each iteration
    }
    return hash.toString(16);
  }

  // For arrays, hash elements directly
  if (Array.isArray(input)) {
    let hash = 0x811c9dc5;
    for (let i = 0; i < input.length; i++) {
      // Add array position to hash calculation
      hash ^= (i + 1) * 2654435761;
      // Recursively hash array elements
      const elementHash = weakHash(input[i]);
      // Mix the element hash into the running hash
      for (let j = 0; j < elementHash.length; j++) {
        hash ^= elementHash.charCodeAt(j);
        hash *= 16777619; // FNV prime (32 bit)
        hash = hash >>> 0;
      }
    }
    return hash.toString(16);
  }

  // For objects, hash keys and values
  if (typeof input === 'object') {
    let hash = 0x811c9dc5;
    const keys = Object.keys(input).sort(); // Sort for consistency

    for (let i = 0; i < keys.length; i++) {
      const key = keys[i];
      // Hash the key using string hash
      const keyHash = weakHash(key);
      hash ^= parseInt(keyHash, 16);
      hash *= 16777619;
      hash = hash >>> 0;

      // Hash the value recursively
      const valueHash = weakHash(input[key]);
      hash ^= parseInt(valueHash, 16);
      hash *= 16777619;
      hash = hash >>> 0;
    }
    return hash.toString(16);
  }

  // Fallback for other types
  return weakHash(String(input));
}
</file>

<file path="client/packages/core/src/authAPI.ts">
import { User } from './clientTypes';
import { jsonFetch } from './utils/fetch';

type SharedInput = {
  apiURI: string;
  appId: string;
};

export type SendMagicCodeParams = { email: string };
export type SendMagicCodeResponse = {
  sent: true;
};

export function sendMagicCode({
  apiURI,
  appId,
  email,
}: SharedInput & SendMagicCodeParams): Promise<SendMagicCodeResponse> {
  return jsonFetch(`${apiURI}/runtime/auth/send_magic_code`, {
    method: 'POST',
    headers: { 'content-type': 'application/json' },
    body: JSON.stringify({ 'app-id': appId, email }),
  });
}

export type VerifyMagicCodeParams = { email: string; code: string };
export type VerifyResponse = {
  user: User;
};
export async function verifyMagicCode({
  apiURI,
  appId,
  email,
  code,
}: SharedInput & VerifyMagicCodeParams): Promise<VerifyResponse> {
  const res = await jsonFetch(`${apiURI}/runtime/auth/verify_magic_code`, {
    method: 'POST',
    headers: { 'content-type': 'application/json' },
    body: JSON.stringify({ 'app-id': appId, email, code }),
  });
  return res;
}

export type VerifyRefreshTokenParams = { refreshToken: string };
export async function verifyRefreshToken({
  apiURI,
  appId,
  refreshToken,
}: SharedInput & VerifyRefreshTokenParams): Promise<VerifyResponse> {
  const res = await jsonFetch(`${apiURI}/runtime/auth/verify_refresh_token`, {
    method: 'POST',
    headers: { 'content-type': 'application/json' },
    body: JSON.stringify({
      'app-id': appId,
      'refresh-token': refreshToken,
    }),
  });
  return res;
}

export type ExchangeCodeForTokenParams = {
  code: string;
  codeVerifier?: string;
};

export async function exchangeCodeForToken({
  apiURI,
  appId,
  code,
  codeVerifier,
}: SharedInput & ExchangeCodeForTokenParams): Promise<VerifyResponse> {
  const res = await jsonFetch(`${apiURI}/runtime/oauth/token`, {
    method: 'POST',
    headers: { 'content-type': 'application/json' },
    body: JSON.stringify({
      app_id: appId,
      code: code,
      code_verifier: codeVerifier,
    }),
  });
  return res;
}

export type SignInWithIdTokenParams = {
  nonce?: string;
  idToken: string;
  clientName: string;
  refreshToken?: string;
};

export async function signInWithIdToken({
  apiURI,
  appId,
  nonce,
  idToken,
  clientName,
  refreshToken,
}: SharedInput & SignInWithIdTokenParams): Promise<VerifyResponse> {
  const res = await jsonFetch(`${apiURI}/runtime/oauth/id_token`, {
    method: 'POST',
    headers: { 'content-type': 'application/json' },
    body: JSON.stringify({
      app_id: appId,
      nonce,
      id_token: idToken,
      client_name: clientName,
      refresh_token: refreshToken,
    }),
  });
  return res;
}

export type SignoutParams = { refreshToken: string };
export async function signOut({
  apiURI,
  appId,
  refreshToken,
}: SharedInput & SignoutParams): Promise<{}> {
  const res = await jsonFetch(`${apiURI}/runtime/signout`, {
    method: 'POST',
    headers: {
      'content-type': 'application/json',
    },
    body: JSON.stringify({
      app_id: appId,
      refresh_token: refreshToken,
    }),
  });
  return res;
}
</file>

<file path="client/packages/core/src/clientTypes.ts">
export type User = { id: string; email: string; refresh_token: string };

export type AuthResult =
  | { user: User | undefined; error: undefined }
  | { user: undefined; error: { message: string } };

export type AuthState =
  | { isLoading: true; error: undefined; user: undefined }
  | { isLoading: false; error: { message: string }; user: undefined }
  | { isLoading: false; error: undefined; user: User | null };

export type ConnectionStatus =
  | 'connecting'
  | 'opened'
  | 'authenticated'
  | 'closed'
  | 'errored';
</file>

<file path="client/packages/core/src/coreTypes.ts">
import { TxChunk } from './instatx';
import { RoomSchemaShape } from './presence';
import type { IContainEntitiesAndLinks, InstantSchemaDef } from './schemaTypes';

export interface IDatabase<
  Schema extends IContainEntitiesAndLinks<any, any> | {} = {},
  _RoomSchema extends RoomSchemaShape = {},
  WithCardinalityInference extends boolean = false,
> {
  tx: TxChunk<
    Schema extends IContainEntitiesAndLinks<any, any>
      ? Schema
      : InstantSchemaDef<any, any, any>
  >;

  withCardinalityInference?: WithCardinalityInference;
}

export interface IInstantDatabase<
  Schema extends InstantSchemaDef<any, any, any>,
> {
  tx: TxChunk<Schema>;
}

export type DevtoolPosition =
  | 'bottom-left'
  | 'bottom-right'
  | 'top-right'
  | 'top-left';

export type DevtoolConfig = {
  /**
   * Position of the devtool panel on the screen
   * @default 'bottom-right'
   */
  position?: DevtoolPosition;

  /**
   * Hosts where the devtool should be shown
   * @default ['localhost']
   */
  allowedHosts?: string[];
};

export type StrictDevtoolConfig = {
  position: DevtoolPosition;
  allowedHosts: string[];
};
</file>

<file path="client/packages/core/src/datalog.js">
// 1. patternMatch
import { getTriples } from './store.js';

function isVariable(x) {
  return typeof x === 'string' && x.startsWith('?');
}

function matchVariable(variable, triplePart, context) {
  if (context.hasOwnProperty(variable)) {
    const bound = context[variable];
    return matchPart(bound, triplePart, context);
  }
  return { ...context, [variable]: triplePart };
}

function matchExact(patternPart, triplePart, context) {
  return patternPart === triplePart ? context : null;
}

function matcherForPatternPart(patternPart) {
  switch (typeof patternPart) {
    case 'string':
      return patternPart.startsWith('?') ? matchVariable : matchExact;
    default:
      return matchExact;
  }
}

const validArgMapProps = [
  'in',
  '$in',
  '$not',
  '$isNull',
  '$comparator', // covers all of $gt, $lt, etc.
];

// Checks if an object is an args map
function isArgsMap(patternPart) {
  for (const prop of validArgMapProps) {
    if (patternPart.hasOwnProperty(prop)) {
      return true;
    }
  }
  return false;
}

function matchPart(patternPart, triplePart, context) {
  if (!context) return null;
  if (typeof patternPart === 'object') {
    // This is an args map, so we'll have already fitered the triples
    // in `getRelevantTriples`
    if (isArgsMap(patternPart)) {
      return context;
    }
    return null;
  }
  const matcher = matcherForPatternPart(patternPart);
  return matcher(patternPart, triplePart, context);
}

export function matchPattern(pattern, triple, context) {
  return pattern.reduce((context, patternPart, idx) => {
    const triplePart = triple[idx];
    return matchPart(patternPart, triplePart, context);
  }, context);
}

// 2. querySingle

export function querySingle(store, pattern, context) {
  return relevantTriples(store, pattern, context)
    .map((triple) => matchPattern(pattern, triple, context))
    .filter((x) => x);
}

// 3. queryWhere

function queryPattern(store, pattern, contexts) {
  if (pattern.or) {
    return pattern.or.patterns.flatMap((patterns) => {
      return queryWhere(store, patterns, contexts);
    });
  }
  if (pattern.and) {
    return pattern.and.patterns.reduce((contexts, patterns) => {
      return queryWhere(store, patterns, contexts);
    }, contexts);
  }
  return contexts.flatMap((context) => querySingle(store, pattern, context));
}

export function queryWhere(store, patterns, contexts = [{}]) {
  return patterns.reduce((contexts, pattern) => {
    return queryPattern(store, pattern, contexts);
  }, contexts);
}

// 4. query

function actualize(context, find) {
  if (Array.isArray(find)) {
    return find.map((findPart) => actualize(context, findPart));
  }
  return isVariable(find) ? context[find] : find;
}

export function query(store, { find, where }) {
  const contexts = queryWhere(store, where);
  return contexts.map((context) => actualize(context, find));
}

// 5. Index

function relevantTriples(store, pattern, context) {
  return getTriples(store, actualize(context, pattern));
}
</file>

<file path="client/packages/core/src/devtool.ts">
import {
  DevtoolConfig,
  DevtoolPosition,
  StrictDevtoolConfig,
} from './coreTypes';
import * as flags from './utils/flags';

type Devtool = { dispose: () => void };

let currentDevtool: Devtool | undefined;

export function createDevtool(appId: string, config: StrictDevtoolConfig) {
  currentDevtool?.dispose();

  const iframeContrainer = createIframeContainer(config);
  const toggler = createToggler(config, toggleView);
  const iframe = createIframe(getSrc(appId));

  function onPostMessage(event: MessageEvent) {
    if (event.source !== iframe.element.contentWindow) return;

    if (event.data?.type === 'close' && iframeContrainer.isVisible()) {
      toggleView();
    }
  }

  function onKeyDown(event: KeyboardEvent) {
    const isToggleShortcut =
      event.shiftKey && event.ctrlKey && event.key === '0';
    const isEsc = event.key === 'Escape' || event.key === 'Esc';

    if (isToggleShortcut) {
      toggleView();
    } else if (isEsc && iframeContrainer.isVisible()) {
      toggleView();
    }
  }

  function toggleView() {
    if (iframeContrainer.isVisible()) {
      iframeContrainer.element.style.display = 'none';
    } else {
      iframeContrainer.element.style.display = 'block';

      // lazily render iframe on first open
      if (!iframeContrainer.element.contains(iframe.element)) {
        iframeContrainer.element.appendChild(iframe.element);
      }
    }
  }

  function dispose() {
    iframeContrainer.element.remove();
    toggler.element.remove();
    removeEventListener('keydown', onKeyDown);
    removeEventListener('message', onPostMessage);
  }

  function create() {
    document.body.appendChild(iframeContrainer.element);
    document.body.appendChild(toggler.element);
    addEventListener('keydown', onKeyDown);
    addEventListener('message', onPostMessage);

    currentDevtool = {
      dispose,
    };
  }

  return create();
}

function getSrc(appId: string) {
  const useLocalDashboard = flags.devBackend || flags.devtoolLocalDashboard;
  const src = `${useLocalDashboard ? 'http://localhost:3000' : 'https://instantdb.com'}/_devtool?appId=${appId}`;
  return src;
}

function createIframe(src: string) {
  const element = document.createElement('iframe');

  element.src = src;
  element.className = 'instant-devtool-iframe';
  Object.assign(element.style, {
    width: '100%',
    height: '100%',
    backgroundColor: 'white',
    border: 'none',
  } as Partial<CSSStyleDeclaration>);
  return { element };
}

function createToggler(
  config: DevtoolConfig,
  onClick: (this: HTMLButtonElement, ev: MouseEvent) => any,
) {
  const logoSVG = `
    <svg width="32" height="32" viewBox="0 0 512 512" fill="none" xmlns="http://www.w3.org/2000/svg">
      <rect width="512" height="512" fill="black"/>
      <rect x="97.0973" y="91.3297" width="140" height="330" fill="white"/>
    </svg>
  `;
  const element = document.createElement('button');
  element.innerHTML = logoSVG;
  element.className = 'instant-devtool-toggler';
  Object.assign(element.style, {
    // pos
    position: 'fixed',
    ...cssPositionForToggler(config.position),
    height: '32px',
    width: '32px',
    // layout
    display: 'flex',
    alignItems: 'center',
    justifyContent: 'center',
    zIndex: '9010',
    // look
    padding: '0',
    margin: '0',
    border: 'none',
    cursor: 'pointer',
  } as Partial<CSSStyleDeclaration>);
  element.addEventListener('click', onClick);
  return { element };
}

function cssPositionForToggler(position: DevtoolPosition) {
  switch (position) {
    case 'bottom-left':
      return { bottom: '24px', left: '24px' };
    case 'bottom-right':
      return { bottom: '24px', right: '24px' };
    case 'top-right':
      return { top: '24px', right: '24px' };
    case 'top-left':
      return { top: '24px', left: '24px' };
  }
}

function cssPositionForIframeContainer(position: DevtoolPosition) {
  switch (position) {
    case 'bottom-left':
      return { bottom: '24px', right: '24px', left: '60px', top: '72px' };
    case 'bottom-right':
      return { bottom: '24px', left: '24px', right: '60px', top: '72px' };
    case 'top-right':
      return { top: '24px', left: '24px', right: '60px', bottom: '72px' };
    case 'top-left':
      return { top: '24px', right: '24px', left: '60px', bottom: '72px' };
  }
}

function createIframeContainer(config: DevtoolConfig) {
  const element = document.createElement('div');
  Object.assign(element.style, {
    position: 'fixed',
    ...cssPositionForIframeContainer(config.position),
    display: 'block',
    borderRadius: '4px',
    border: '1px #ccc solid',
    boxShadow: '0px 0px 8px #00000044',
    backgroundColor: '#eee',
    zIndex: '999990',
  } as Partial<CSSStyleDeclaration>);
  element.style.display = 'none';
  element.className = 'instant-devtool-container';
  function isVisible() {
    return element.style.display !== 'none';
  }
  return { element, isVisible };
}
</file>

<file path="client/packages/core/src/helperTypes.ts">
import type {
  InstaQLEntity,
  InstaQLResult,
  InstaQLParams,
  Remove$,
} from './queryTypes';
import type { IContainEntitiesAndLinks, InstantSchemaDef } from './schemaTypes';
import type { IInstantDatabase } from './coreTypes';

/**
 * @deprecated
 * `InstantQuery` is deprecated. Use `InstaQLParams` instead.
 *
 * @example
 *  // Before
 *  const db = init_experimental({ ...config, schema });
 *  type DB = typeof db;
 *  const myQuery = { ... } satisfies InstantQuery<DB>;
 *
 *  // After
 *  type Schema = typeof schema;
 *  const myQuery = { ... } satisfies InstaQLParams<Schema>;
 */
export type InstantQuery<DB extends IInstantDatabase<any>> =
  DB extends IInstantDatabase<infer Schema> ? InstaQLParams<Schema> : never;

/**
 * @deprecated
 * `InstantQueryResult` is deprecated. Use `InstaQLResult` instead.
 *
 * @example
 * // Before
 * const db = init_experimental({ ...config, schema });
 * type DB = typeof db;
 * type MyQueryResult = InstantQueryResult<DB, typeof myQuery>;
 *
 * // After
 * type Schema = typeof schema;
 * type MyQueryResult = InstaQLResult<Schema, typeof myQuery>;
 */
export type InstantQueryResult<DB extends IInstantDatabase<any>, Q> =
  DB extends IInstantDatabase<infer Schema>
    ? InstaQLResult<Schema, Remove$<Q>>
    : never;
/**
 * @deprecated
 * `InstantSchema` is deprecated. Use typeof schema directly:
 * @example
 * // Before
 * const db = init_experimental({ ...config, schema });
 * type Schema = InstantSchema<typeof db>;
 *
 * // After
 * type Schema = typeof schema;
 */
export type InstantSchema<DB extends IInstantDatabase<any>> =
  DB extends IInstantDatabase<infer Schema> ? Schema : never;

/**
 * @deprecated
 * `InstantEntity` is deprecated. Use `InstaQLEntity` instead.
 *
 * @example
 * // Before
 * const db = init_experimental({ ...config, schema });
 * type DB = typeof db;
 * type MyEntity = InstantEntity<DB, "myEntityName">;
 *
 * // After
 * type Schema = typeof schema;
 * type MyEntity = InstaQLEntity<Schema, "myEntityName">;
 */
export type InstantEntity<
  DB extends IInstantDatabase<any>,
  EntityName extends DB extends IInstantDatabase<infer Schema>
    ? Schema extends IContainEntitiesAndLinks<infer Entities, any>
      ? keyof Entities
      : never
    : never,
  Query extends
    | (DB extends IInstantDatabase<infer Schema>
        ? Schema extends IContainEntitiesAndLinks<infer Entities, any>
          ? {
              [QueryPropName in keyof Entities[EntityName]['links']]?: any;
            }
          : never
        : never)
    | {} = {},
> =
  DB extends IInstantDatabase<infer Schema>
    ? InstaQLEntity<Schema, EntityName, Query>
    : never;

/**
 * @deprecated
 * `InstantSchemaDatabase` is deprecated. You generally don't need to
 * create a return type for a DB. But, if you like you can use `IInstantDatabase`:
 *
 * @example
 * // Before
 * type DB = InstantSchemaDatabase<typeof schema>;
 *
 * // After
 * type DB = IInstantDatabase<typeof schema>;
 */
export type InstantSchemaDatabase<
  Schema extends InstantSchemaDef<any, any, any>,
  _T1 extends any = any,
  _T2 extends any = any,
> = IInstantDatabase<Schema>;
</file>

<file path="client/packages/core/src/index.ts">
import Reactor from './Reactor';
import {
  tx,
  txInit,
  lookup,
  getOps,
  type TxChunk,
  type TransactionChunk,
} from './instatx';
import weakHash from './utils/weakHash';
import id from './utils/uuid';
import IndexedDBStorage from './IndexedDBStorage';
import WindowNetworkListener from './WindowNetworkListener';
import { i } from './schema';
import { createDevtool } from './devtool';
import version from './version';

import type {
  PresenceOpts,
  PresenceResponse,
  PresenceSlice,
  RoomSchemaShape,
} from './presence';
import type {
  DevtoolConfig,
  IDatabase,
  IInstantDatabase,
  StrictDevtoolConfig,
} from './coreTypes';
import type {
  Query,
  QueryResponse,
  InstaQLResponse,
  PageInfoResponse,
  Exactly,
  InstantObject,
  InstaQLParams,
  InstaQLQueryParams,
  InstaQLEntity,
  InstaQLResult,
} from './queryTypes';
import type {
  AuthState,
  User,
  AuthResult,
  ConnectionStatus,
} from './clientTypes';
import type {
  InstantQuery,
  InstantQueryResult,
  InstantSchema,
  InstantEntity,
  InstantSchemaDatabase,
} from './helperTypes';
import type {
  AttrsDefs,
  CardinalityKind,
  DataAttrDef,
  EntitiesDef,
  EntitiesWithLinks,
  EntityDef,
  RoomsDef,
  InstantSchemaDef,
  InstantGraph,
  LinkAttrDef,
  LinkDef,
  LinksDef,
  PresenceOf,
  ResolveAttrs,
  RoomsOf,
  TopicsOf,
  ValueTypes,
  InstantUnknownSchema,
  BackwardsCompatibleSchema,
  UpdateParams,
  LinkParams,
} from './schemaTypes';
import type { UploadFileResponse, DeleteFileResponse } from './StorageAPI';

import type {
  ExchangeCodeForTokenParams,
  SendMagicCodeParams,
  SendMagicCodeResponse,
  SignInWithIdTokenParams,
  VerifyMagicCodeParams,
  VerifyResponse,
} from './authAPI';

const defaultOpenDevtool = true;

// types

export type Config = {
  appId: string;
  websocketURI?: string;
  apiURI?: string;
  devtool?: boolean | DevtoolConfig;
};

export type InstantConfig<S extends InstantSchemaDef<any, any, any>> = {
  appId: string;
  websocketURI?: string;
  apiURI?: string;
  devtool?: boolean | DevtoolConfig;
  schema?: S;
};

export type ConfigWithSchema<S extends InstantGraph<any, any>> = Config & {
  schema: S;
};

export type TransactionResult = {
  status: 'synced' | 'enqueued';
  clientId: string;
};

export type PublishTopic<TopicsByKey> = <Key extends keyof TopicsByKey>(
  topic: Key,
  data: TopicsByKey[Key],
) => void;

export type SubscribeTopic<PresenceShape, TopicsByKey> = <
  Key extends keyof TopicsByKey,
>(
  topic: Key,
  onEvent: (event: TopicsByKey[Key], peer: PresenceShape) => void,
) => () => void;

export type GetPresence<PresenceShape> = <Keys extends keyof PresenceShape>(
  opts: PresenceOpts<PresenceShape, Keys>,
) => PresenceResponse<PresenceShape, Keys>;

export type SubscribePresence<PresenceShape> = <
  Keys extends keyof PresenceShape,
>(
  opts: PresenceOpts<PresenceShape, Keys>,
  onChange: (slice: PresenceResponse<PresenceShape, Keys>) => void,
) => () => void;

export type RoomHandle<PresenceShape, TopicsByKey> = {
  leaveRoom: () => void;
  publishTopic: PublishTopic<TopicsByKey>;
  subscribeTopic: SubscribeTopic<PresenceShape, TopicsByKey>;
  publishPresence: (data: Partial<PresenceShape>) => void;
  getPresence: GetPresence<PresenceShape>;
  subscribePresence: SubscribePresence<PresenceShape>;
};

type AuthToken = string;

type SubscriptionState<Q, Schema, WithCardinalityInference extends boolean> =
  | { error: { message: string }; data: undefined; pageInfo: undefined }
  | {
      error: undefined;
      data: QueryResponse<Q, Schema, WithCardinalityInference>;
      pageInfo: PageInfoResponse<Q>;
    };

type InstaQLSubscriptionState<Schema, Q> =
  | { error: { message: string }; data: undefined; pageInfo: undefined }
  | {
      error: undefined;
      data: InstaQLResponse<Schema, Q>;
      pageInfo: PageInfoResponse<Q>;
    };

type LifecycleSubscriptionState<
  Q,
  Schema,
  WithCardinalityInference extends boolean,
> = SubscriptionState<Q, Schema, WithCardinalityInference> & {
  isLoading: boolean;
};

type InstaQLLifecycleState<Schema, Q> = InstaQLSubscriptionState<Schema, Q> & {
  isLoading: boolean;
};

type UnsubscribeFn = () => void;

// consts

const defaultConfig = {
  apiURI: 'https://api.instantdb.com',
  websocketURI: 'wss://api.instantdb.com/runtime/session',
};

// hmr
function initGlobalInstantCoreStore(): Record<string, any> {
  globalThis.__instantDbStore = globalThis.__instantDbStore ?? {};
  return globalThis.__instantDbStore;
}

const globalInstantCoreStore = initGlobalInstantCoreStore();

/**
 * Functions to log users in and out.
 *
 * @see https://instantdb.com/docs/auth
 */
class Auth {
  constructor(private db: Reactor) {}

  /**
   * Sends a magic code to the user's email address.
   *
   * Once you send the magic code, see {@link auth.signInWithMagicCode} to let the
   * user verify.
   *
   * @see https://instantdb.com/docs/auth
   * @example
   *  db.auth.sendMagicCode({email: "example@gmail.com"})
   *    .catch((err) => console.error(err.body?.message))
   */
  sendMagicCode = (
    params: SendMagicCodeParams,
  ): Promise<SendMagicCodeResponse> => {
    return this.db.sendMagicCode(params);
  };

  /**
   * Verify a magic code that was sent to the user's email address.
   *
   * @see https://instantdb.com/docs/auth
   *
   * @example
   *  db.auth.signInWithMagicCode({email: "example@gmail.com", code: "123456"})
   *       .catch((err) => console.error(err.body?.message))
   */
  signInWithMagicCode = (
    params: VerifyMagicCodeParams,
  ): Promise<VerifyResponse> => {
    return this.db.signInWithMagicCode(params);
  };

  /**
   * Sign in a user with a refresh token
   *
   * @see https://instantdb.com/docs/backend#frontend-auth-sign-in-with-token
   *
   * @example
   *   // Get the token from your backend
   *   const token = await fetch('/signin', ...);
   *   //Sign in
   *   db.auth.signInWithToken(token);
   */
  signInWithToken = (token: AuthToken): Promise<VerifyResponse> => {
    return this.db.signInWithCustomToken(token);
  };

  /**
   * Create an authorization url to sign in with an external provider
   *
   * @see https://instantdb.com/docs/auth
   *
   * @example
   *   // Get the authorization url from your backend
   *   const url = db.auth.createAuthorizationUrl({
   *     clientName: "google",
   *     redirectURL: window.location.href,
   *   });
   *
   *   // Put it in a sign in link
   *   <a href={url}>Log in with Google</a>
   */
  createAuthorizationURL = (params: {
    clientName: string;
    redirectURL: string;
  }): string => {
    return this.db.createAuthorizationURL(params);
  };

  /**
   * Sign in with the id_token from an external provider like Google
   *
   * @see https://instantdb.com/docs/auth
   * @example
   *   db.auth
   *  .signInWithIdToken({
   *    // Token from external service
   *    idToken: id_token,
   *    // The name you gave the client when you registered it with Instant
   *    clientName: "google",
   *    // The nonce, if any, that you used when you initiated the auth flow
   *    // with the external service.
   *    nonce: your_nonce
   *  })
   *  .catch((err) => console.error(err.body?.message));
   *
   */
  signInWithIdToken = (
    params: SignInWithIdTokenParams,
  ): Promise<VerifyResponse> => {
    return this.db.signInWithIdToken(params);
  };

  /**
   * Sign in with the id_token from an external provider like Google
   *
   * @see https://instantdb.com/docs/auth
   * @example
   *   db.auth
   *  .exchangeOAuthCode({
   *    // code received in redirect from OAuth callback
   *    code: code
   *    // The PKCE code_verifier, if any, that you used when you
   *    // initiated the auth flow
   *    codeVerifier: your_code_verifier
   *  })
   *  .catch((err) => console.error(err.body?.message));
   *
   */
  exchangeOAuthCode = (params: ExchangeCodeForTokenParams) => {
    return this.db.exchangeCodeForToken(params);
  };

  /**
   * OpenID Discovery path for use with tools like
   * expo-auth-session that use auto-discovery of
   * OAuth parameters.
   *
   * @see https://instantdb.com/docs/auth
   * @example
   *   const discovery = useAutoDiscovery(
   *     db.auth.issuerURI()
   *   );
   */
  issuerURI = (): string => {
    return this.db.issuerURI();
  };

  /**
   * Sign out the current user
   */
  signOut = (): Promise<void> => {
    return this.db.signOut();
  };
}

type FileOpts = {
  contentType?: string;
  contentDisposition?: string;
};

/**
 * Functions to manage file storage.
 */
class Storage {
  constructor(private db: Reactor) {}

  /**
   * Uploads file at the provided path.
   *
   * @see https://instantdb.com/docs/storage
   * @example
   *   const [file] = e.target.files; // result of file input
   *   const data = await db.storage.uploadFile('photos/demo.png', file);
   */
  uploadFile = (
    path: string,
    file: File,
    opts: FileOpts = {},
  ): Promise<UploadFileResponse> => {
    return this.db.uploadFile(path, file, opts);
  };

  /**
   * Deletes a file by path name.
   *
   * @see https://instantdb.com/docs/storage
   * @example
   *   await db.storage.delete('photos/demo.png');
   */
  delete = (pathname: string) => {
    return this.db.deleteFile(pathname);
  };

  // Deprecated Storage API (Jan 2025)
  // ---------------------------------

  /**
   * @deprecated. Use `db.storage.uploadFile` instead
   * remove in the future.
   */
  upload = (pathname: string, file: File) => {
    return this.db.upload(pathname, file);
  };

  /**
   * @deprecated Use `db.storage.uploadFile` instead
   */
  put = this.upload;

  /**
   * @deprecated. getDownloadUrl will be removed in the future.
   * Use `useQuery` instead to query and fetch for valid urls
   *
   * db.useQuery({
   *   $files: {
   *     $: {
   *       where: {
   *         path: "moop.png"
   *       }
   *     }
   *   }
   * })
   */
  getDownloadUrl = (pathname: string) => {
    return this.db.getDownloadUrl(pathname);
  };
}

// util

function coerceQuery(o: any) {
  // stringify and parse to remove undefined values
  return JSON.parse(JSON.stringify(o));
}

class InstantCoreDatabase<Schema extends InstantSchemaDef<any, any, any>>
  implements IInstantDatabase<Schema>
{
  public _reactor: Reactor<RoomsOf<Schema>>;
  public auth: Auth;
  public storage: Storage;

  public tx = txInit<Schema>();

  constructor(reactor: Reactor<RoomsOf<Schema>>) {
    this._reactor = reactor;
    this.auth = new Auth(this._reactor);
    this.storage = new Storage(this._reactor);
  }

  /**
   * Use this to write data! You can create, update, delete, and link objects
   *
   * @see https://instantdb.com/docs/instaml
   *
   * @example
   *   // Create a new object in the `goals` namespace
   *   const goalId = id();
   *   db.transact(tx.goals[goalId].update({title: "Get fit"}))
   *
   *   // Update the title
   *   db.transact(tx.goals[goalId].update({title: "Get super fit"}))
   *
   *   // Delete it
   *   db.transact(tx.goals[goalId].delete())
   *
   *   // Or create an association:
   *   todoId = id();
   *   db.transact([
   *    tx.todos[todoId].update({ title: 'Go on a run' }),
   *    tx.goals[goalId].link({todos: todoId}),
   *  ])
   */
  transact(
    chunks: TransactionChunk<any, any> | TransactionChunk<any, any>[],
  ): Promise<TransactionResult> {
    return this._reactor.pushTx(chunks);
  }

  getLocalId(name: string): Promise<string> {
    return this._reactor.getLocalId(name);
  }

  /**
   * Use this to query your data!
   *
   * @see https://instantdb.com/docs/instaql
   *
   * @example
   *  // listen to all goals
   *  db.subscribeQuery({ goals: {} }, (resp) => {
   *    console.log(resp.data.goals)
   *  })
   *
   *  // goals where the title is "Get Fit"
   *  db.subscribeQuery(
   *    { goals: { $: { where: { title: "Get Fit" } } } },
   *    (resp) => {
   *      console.log(resp.data.goals)
   *    }
   *  )
   *
   *  // all goals, _alongside_ their todos
   *  db.subscribeQuery({ goals: { todos: {} } }, (resp) => {
   *    console.log(resp.data.goals)
   *  });
   */
  subscribeQuery<Q extends InstaQLParams<Schema>>(
    query: Q,
    cb: (resp: InstaQLSubscriptionState<Schema, Q>) => void,
  ) {
    return this._reactor.subscribeQuery(query, cb);
  }

  /**
   * Listen for the logged in state. This is useful
   * for deciding when to show a login screen.
   *
   * @see https://instantdb.com/docs/auth
   * @example
   *   const unsub = db.subscribeAuth((auth) => {
   *     if (auth.user) {
   *     console.log('logged in as', auth.user.email)
   *    } else {
   *      console.log('logged out')
   *    }
   *  })
   */
  subscribeAuth(cb: (auth: AuthResult) => void): UnsubscribeFn {
    return this._reactor.subscribeAuth(cb);
  }

  /**
   * One time query for the logged in state. This is useful
   * for scenarios where you want to know the current auth
   * state without subscribing to changes.
   *
   * @see https://instantdb.com/docs/auth
   * @example
   *   const user = await db.getAuth();
   *   console.log('logged in as', user.email)
   */
  getAuth(): Promise<User | null> {
    return this._reactor.getAuth();
  }

  /**
   * Listen for connection status changes to Instant. This is useful
   * for building things like connectivity indicators
   *
   * @see https://www.instantdb.com/docs/patterns#connection-status
   * @example
   *   const unsub = db.subscribeConnectionStatus((status) => {
   *     const connectionState =
   *       status === 'connecting' || status === 'opened'
   *         ? 'authenticating'
   *       : status === 'authenticated'
   *         ? 'connected'
   *       : status === 'closed'
   *         ? 'closed'
   *       : status === 'errored'
   *         ? 'errored'
   *       : 'unexpected state';
   *
   *     console.log('Connection status:', connectionState);
   *   });
   */
  subscribeConnectionStatus(
    cb: (status: ConnectionStatus) => void,
  ): UnsubscribeFn {
    return this._reactor.subscribeConnectionStatus(cb);
  }

  /**
   * Join a room to publish and subscribe to topics and presence.
   *
   * @see https://instantdb.com/docs/presence-and-topics
   * @example
   * // init
   * const db = init();
   * const room = db.joinRoom(roomType, roomId);
   * // usage
   * const unsubscribeTopic = room.subscribeTopic("foo", console.log);
   * const unsubscribePresence = room.subscribePresence({}, console.log);
   * room.publishTopic("hello", { message: "hello world!" });
   * room.publishPresence({ name: "joe" });
   * // later
   * unsubscribePresence();
   * unsubscribeTopic();
   * room.leaveRoom();
   */
  joinRoom<RoomType extends keyof RoomsOf<Schema>>(
    roomType: RoomType = '_defaultRoomType' as RoomType,
    roomId: string = '_defaultRoomId',
  ): RoomHandle<PresenceOf<Schema, RoomType>, TopicsOf<Schema, RoomType>> {
    const leaveRoom = this._reactor.joinRoom(roomId);

    return {
      leaveRoom,
      subscribeTopic: (topic, onEvent) =>
        this._reactor.subscribeTopic(roomId, topic, onEvent),
      subscribePresence: (opts, onChange) =>
        this._reactor.subscribePresence(roomType, roomId, opts, onChange),
      publishTopic: (topic, data) =>
        this._reactor.publishTopic({ roomType, roomId, topic, data }),
      publishPresence: (data) =>
        this._reactor.publishPresence(roomType, roomId, data),
      getPresence: (opts) => this._reactor.getPresence(roomType, roomId, opts),
    };
  }

  shutdown() {
    delete globalInstantCoreStore[this._reactor.config.appId];
    this._reactor.shutdown();
  }

  /**
   * Use this for one-off queries.
   * Returns local data if available, otherwise fetches from the server.
   * Because we want to avoid stale data, this method will throw an error
   * if the user is offline or there is no active connection to the server.
   *
   * @see https://instantdb.com/docs/instaql
   *
   * @example
   *
   *  const resp = await db.queryOnce({ goals: {} });
   *  console.log(resp.data.goals)
   */
  queryOnce<Q extends InstaQLParams<Schema>>(
    query: Q,
  ): Promise<{
    data: InstaQLResponse<Schema, Q>;
    pageInfo: PageInfoResponse<Q>;
  }> {
    return this._reactor.queryOnce(query);
  }
}

/**
 *
 * The first step: init your application!
 *
 * Visit https://instantdb.com/dash to get your `appId` :)
 *
 * @example
 *  import { init } from "@instantdb/core"
 *
 *  const db = init({ appId: "my-app-id" })
 *
 *  // You can also provide a schema for type safety and editor autocomplete!
 *
 *  import { init } from "@instantdb/core"
 *  import schema from ""../instant.schema.ts";
 *
 *  const db = init({ appId: "my-app-id", schema })
 *
 *  // To learn more: https://instantdb.com/docs/modeling-data
 */
function init<
  Schema extends InstantSchemaDef<any, any, any> = InstantUnknownSchema,
>(
  config: InstantConfig<Schema>,
  Storage?: any,
  NetworkListener?: any,
  versions?: { [key: string]: string },
): InstantCoreDatabase<Schema> {
  const existingClient = globalInstantCoreStore[
    config.appId
  ] as InstantCoreDatabase<any>;

  if (existingClient) {
    return existingClient;
  }

  const reactor = new Reactor<RoomsOf<Schema>>(
    {
      ...defaultConfig,
      ...config,
      cardinalityInference: config.schema ? true : false,
    },
    Storage || IndexedDBStorage,
    NetworkListener || WindowNetworkListener,
    { ...(versions || {}), '@instantdb/core': version },
  );

  const client = new InstantCoreDatabase<any>(reactor);
  globalInstantCoreStore[config.appId] = client;

  handleDevtool(config.appId, config.devtool);

  return client;
}

function handleDevtool(appId: string, devtool: boolean | DevtoolConfig) {
  if (typeof window === 'undefined' || typeof window.location === 'undefined') {
    return;
  }

  if (typeof devtool === 'boolean' && !devtool) {
    return;
  }

  const config: StrictDevtoolConfig = {
    position: 'bottom-right' as const,
    allowedHosts: ['localhost'],
    ...(typeof devtool === 'object' ? devtool : {}),
  };

  if (!config.allowedHosts.includes(window.location.hostname)) {
    return;
  }

  createDevtool(appId, config);
}

type InstantRules = {
  [EntityName: string]: {
    allow: {
      view?: string;
      create?: string;
      update?: string;
      delete?: string;
      $default?: string;
    };
    bind?: string[];
  };
};

/**
 * @deprecated
 * `init_experimental` is deprecated. You can replace it with `init`.
 *
 * @example
 *
 * // Before
 * import { init_experimental } from "@instantdb/core"
 * const db = init_experimental({  ...  });
 *
 * // After
 * import { init } from "@instantdb/core"
 * const db = init({ ...  });
 */
const init_experimental = init;

export {
  // bada bing bada boom
  init,
  init_experimental,
  id,
  tx,
  txInit,
  lookup,

  // cli
  i,

  // util
  getOps,
  coerceQuery,
  weakHash,
  IndexedDBStorage,
  WindowNetworkListener,
  InstantCoreDatabase,
  Auth,
  Storage,
  version,

  // og types
  type IDatabase,
  type RoomSchemaShape,
  type Query,
  type QueryResponse,
  type InstaQLResponse,
  type PageInfoResponse,
  type InstantObject,
  type Exactly,
  type TransactionChunk,
  type AuthState,
  type ConnectionStatus,
  type User,
  type AuthToken,
  type TxChunk,
  type SubscriptionState,
  type InstaQLSubscriptionState,
  type LifecycleSubscriptionState,
  type InstaQLLifecycleState,

  // presence types
  type PresenceOpts,
  type PresenceSlice,
  type PresenceResponse,

  // new query types
  type InstaQLParams,
  type InstaQLQueryParams,
  type InstantQuery,
  type InstantQueryResult,
  type InstantSchema,
  type InstantEntity,
  type InstantSchemaDatabase,

  // schema types
  type AttrsDefs,
  type CardinalityKind,
  type DataAttrDef,
  type EntitiesDef,
  type EntitiesWithLinks,
  type EntityDef,
  type RoomsDef,
  type InstantGraph,
  type LinkAttrDef,
  type LinkDef,
  type LinksDef,
  type ResolveAttrs,
  type ValueTypes,
  type RoomsOf,
  type PresenceOf,
  type TopicsOf,
  type InstaQLEntity,
  type InstaQLResult,
  type InstantSchemaDef,
  type InstantUnknownSchema,
  type IInstantDatabase,
  type BackwardsCompatibleSchema,
  type InstantRules,
  type UpdateParams,
  type LinkParams,

  // auth types
  type ExchangeCodeForTokenParams,
  type SendMagicCodeParams,
  type SendMagicCodeResponse,
  type SignInWithIdTokenParams,
  type VerifyMagicCodeParams,
  type VerifyResponse,

  // storage types
  type FileOpts,
  type UploadFileResponse,
  type DeleteFileResponse,
};
</file>

<file path="client/packages/core/src/IndexedDBStorage.js">
export default class IndexedDBStorage {
  constructor(dbName) {
    this.dbName = dbName;
    this._storeName = 'kv';
    this._dbPromise = this._init();
  }

  _init() {
    return new Promise((resolve, reject) => {
      const request = indexedDB.open(this.dbName, 1);

      request.onerror = (event) => {
        reject(event);
      };

      request.onsuccess = (event) => {
        resolve(event.target.result);
      };

      request.onupgradeneeded = (event) => {
        const db = event.target.result;
        db.createObjectStore(this._storeName);
      };
    });
  }

  async getItem(k) {
    const db = await this._dbPromise;
    return new Promise((resolve, reject) => {
      const transaction = db.transaction([this._storeName], 'readonly');
      const objectStore = transaction.objectStore(this._storeName);
      const request = objectStore.get(k);
      request.onerror = (event) => {
        reject(event);
      };
      request.onsuccess = (_event) => {
        if (request.result) {
          resolve(request.result);
        } else {
          resolve(null);
        }
      };
    });
  }

  async setItem(k, v) {
    const db = await this._dbPromise;
    return new Promise((resolve, reject) => {
      const transaction = db.transaction([this._storeName], 'readwrite');
      const objectStore = transaction.objectStore(this._storeName);
      const request = objectStore.put(v, k);

      request.onerror = (event) => {
        reject(event);
      };

      request.onsuccess = (_event) => {
        resolve();
      };
    });
  }
}
</file>

<file path="client/packages/core/src/InMemoryStorage.js">
export default class InMemoryStorage {
  constructor(dbName) {
    this.dbName = dbName;
    this.store = new Map();
  }

  async getItem(k) {
    return this.store.get(k) ?? null;
  }

  async setItem(k, v) {
    this.store.set(k, v);
  }
}
</file>

<file path="client/packages/core/src/instaml.js">
import { getOps, isLookup, parseLookup } from './instatx';
import { immutableDeepReplace } from './utils/object';
import uuid from './utils/uuid';

// Rewrites optimistic attrs with the attrs we get back from the server.
export function rewriteStep(attrMapping, txStep) {
  const { attrIdMap, refSwapAttrIds } = attrMapping;
  const rewritten = [];
  for (const part of txStep) {
    const newValue = attrIdMap[part];

    if (newValue) {
      // Rewrites attr id
      rewritten.push(newValue);
    } else if (Array.isArray(part) && part.length == 2 && attrIdMap[part[0]]) {
      // Rewrites attr id in lookups
      const [aid, value] = part;
      rewritten.push([attrIdMap[aid], value]);
    } else {
      rewritten.push(part);
    }
  }
  const [action] = txStep;
  if (
    (action === 'add-triple' || action === 'retract-triple') &&
    refSwapAttrIds.has(txStep[2])
  ) {
    // Reverse links if the optimistic link attr is backwards
    const tmp = rewritten[1];
    rewritten[1] = rewritten[3];
    rewritten[3] = tmp;
  }
  return rewritten;
}

export function getAttrByFwdIdentName(attrs, inputEtype, inputIdentName) {
  return Object.values(attrs).find((attr) => {
    const [_id, etype, label] = attr['forward-identity'];
    return etype === inputEtype && label === inputIdentName;
  });
}

export function getAttrByReverseIdentName(attrs, inputEtype, inputIdentName) {
  return Object.values(attrs).find((attr) => {
    const revIdent = attr['reverse-identity'];
    if (!revIdent) return false;
    const [_id, etype, label] = revIdent;
    return etype === inputEtype && label === inputIdentName;
  });
}

function explodeLookupRef(eid) {
  if (Array.isArray(eid)) {
    return eid;
  }
  const entries = Object.entries(eid);
  if (entries.length !== 1) {
    throw new Error(
      'lookup must be an object with a single unique attr and value.',
    );
  }
  return entries[0];
}

function isRefLookupIdent(attrs, etype, identName) {
  return (
    identName.indexOf('.') !== -1 &&
    // attr names can have `.` in them, so use the attr we find with a `.`
    // before assuming it's a ref lookup.
    !getAttrByFwdIdentName(attrs, etype, identName)
  );
}

function extractRefLookupFwdName(identName) {
  const [fwdName, idIdent, ...rest] = identName.split('.');
  if (rest.length > 0 || idIdent !== 'id') {
    throw new Error(`${identName} is not a valid lookup attribute.`);
  }

  return fwdName;
}

function lookupIdentToAttr(attrs, etype, identName) {
  if (!isRefLookupIdent(attrs, etype, identName)) {
    return getAttrByFwdIdentName(attrs, etype, identName);
  }

  const fwdName = extractRefLookupFwdName(identName);

  const refAttr =
    getAttrByFwdIdentName(attrs, etype, fwdName) ||
    getAttrByReverseIdentName(attrs, etype, fwdName);
  if (refAttr && refAttr['value-type'] !== 'ref') {
    throw new Error(`${identName} does not reference a valid link attribute.`);
  }
  return refAttr;
}

// Returns [attr, value] for the eid if the eid is a lookup.
// If it's a regular eid, returns null
function lookupPairOfEid(eid) {
  if (typeof eid === 'string' && !isLookup(eid)) {
    return null;
  }
  return typeof eid === 'string' && isLookup(eid)
    ? parseLookup(eid)
    : explodeLookupRef(eid);
}

function extractLookup(attrs, etype, eid) {
  const lookupPair = lookupPairOfEid(eid);

  if (lookupPair === null) {
    return eid;
  }

  const [identName, value] = lookupPair;
  const attr = lookupIdentToAttr(attrs, etype, identName);
  if (!attr || !attr['unique?']) {
    throw new Error(`${identName} is not a unique attribute.`);
  }
  return [attr.id, value];
}

function expandLink(attrs, [etype, eidA, obj]) {
  const addTriples = Object.entries(obj).flatMap(([label, eidOrEids]) => {
    const eids = Array.isArray(eidOrEids) ? eidOrEids : [eidOrEids];
    const fwdAttr = getAttrByFwdIdentName(attrs, etype, label);
    const revAttr = getAttrByReverseIdentName(attrs, etype, label);
    return eids.map((eidB) => {
      const txStep = fwdAttr
        ? [
            'add-triple',
            extractLookup(attrs, etype, eidA),
            fwdAttr.id,
            extractLookup(attrs, fwdAttr['reverse-identity'][1], eidB),
          ]
        : [
            'add-triple',
            extractLookup(attrs, revAttr['forward-identity'][1], eidB),
            revAttr.id,
            extractLookup(attrs, etype, eidA),
          ];
      return txStep;
    });
  });
  return addTriples;
}

function expandUnlink(attrs, [etype, eidA, obj]) {
  const retractTriples = Object.entries(obj).flatMap(([label, eidOrEids]) => {
    const eids = Array.isArray(eidOrEids) ? eidOrEids : [eidOrEids];
    const fwdAttr = getAttrByFwdIdentName(attrs, etype, label);
    const revAttr = getAttrByReverseIdentName(attrs, etype, label);
    return eids.map((eidB) => {
      const txStep = fwdAttr
        ? [
            'retract-triple',
            extractLookup(attrs, etype, eidA),
            fwdAttr.id,
            extractLookup(attrs, fwdAttr['reverse-identity'][1], eidB),
          ]
        : [
            'retract-triple',
            extractLookup(attrs, revAttr['forward-identity'][1], eidB),
            revAttr.id,
            extractLookup(attrs, etype, eidA),
          ];
      return txStep;
    });
  });
  return retractTriples;
}

function expandUpdate(attrs, [etype, eid, obj]) {
  const lookup = extractLookup(attrs, etype, eid);
  // id first so that we don't clobber updates on the lookup field
  const attrTuples = [['id', extractLookup(attrs, etype, eid)]]
    .concat(Object.entries(obj))
    .map(([identName, value]) => {
      const attr = getAttrByFwdIdentName(attrs, etype, identName);
      return ['add-triple', lookup, attr.id, value];
    });
  return attrTuples;
}

function expandDelete(attrs, [etype, eid]) {
  const lookup = extractLookup(attrs, etype, eid);
  return [['delete-entity', lookup, etype]];
}

function expandDeepMerge(attrs, [etype, eid, obj]) {
  const lookup = extractLookup(attrs, etype, eid);
  const attrTuples = Object.entries(obj).map(([identName, value]) => {
    const attr = getAttrByFwdIdentName(attrs, etype, identName);
    const coercedValue = immutableDeepReplace(value, undefined, null);
    return ['deep-merge-triple', lookup, attr.id, coercedValue];
  });

  const idTuple = [
    'add-triple',
    lookup,
    getAttrByFwdIdentName(attrs, etype, 'id').id,
    lookup,
  ];

  // id first so that we don't clobber updates on the lookup field
  return [idTuple].concat(attrTuples);
}
function removeIdFromArgs(step) {
  const [op, etype, eid, obj] = step;
  if (!obj) {
    return step;
  }
  const newObj = { ...obj };
  delete newObj.id;
  return [op, etype, eid, newObj];
}

function toTxSteps(attrs, step) {
  const [action, ...args] = removeIdFromArgs(step);
  switch (action) {
    case 'merge':
      return expandDeepMerge(attrs, args);
    case 'update':
      return expandUpdate(attrs, args);
    case 'link':
      return expandLink(attrs, args);
    case 'unlink':
      return expandUnlink(attrs, args);
    case 'delete':
      return expandDelete(attrs, args);
    default:
      throw new Error(`unsupported action ${action}`);
  }
}

// ---------
// transform

function checkedDataTypeOfValueType(valueType) {
  switch (valueType) {
    case 'string':
    case 'date':
    case 'boolean':
    case 'number':
      return valueType;
    default:
      return undefined;
  }
}

function objectPropsFromSchema(schema, etype, label) {
  const attr = schema.entities[etype]?.attrs?.[label];
  if (label === 'id') return null;
  if (!attr) {
    throw new Error(`${etype}.${label} does not exist in your schema`);
  }
  const { unique, indexed } = attr?.config;
  const checkedDataType = checkedDataTypeOfValueType(attr?.valueType);

  return {
    'index?': indexed,
    'unique?': unique,
    'checked-data-type': checkedDataType,
  };
}

function createObjectAttr(schema, etype, label, props) {
  const schemaObjectProps = schema
    ? objectPropsFromSchema(schema, etype, label)
    : null;
  const attrId = uuid();
  const fwdIdentId = uuid();
  const fwdIdent = [fwdIdentId, etype, label];
  return {
    id: attrId,
    'forward-identity': fwdIdent,
    'value-type': 'blob',
    cardinality: 'one',
    'unique?': false,
    'index?': false,
    isUnsynced: true,
    ...(schemaObjectProps || {}),
    ...(props || {}),
  };
}

function findSchemaLink(schema, etype, label) {
  const found = Object.values(schema.links).find((x) => {
    return (
      (x.forward.on === etype && x.forward.label === label) ||
      (x.reverse.on === etype && x.reverse.label === label)
    );
  });
  return found;
}

function refPropsFromSchema(schema, etype, label) {
  const found = findSchemaLink(schema, etype, label);
  if (!found) {
    throw new Error(`Couldn't find the link ${etype}.${label} in your schema`);
  }
  const { forward, reverse } = found;
  return {
    'forward-identity': [uuid(), forward.on, forward.label],
    'reverse-identity': [uuid(), reverse.on, reverse.label],
    cardinality: forward.has === 'one' ? 'one' : 'many',
    'unique?': reverse.has === 'one',
  };
}

function createRefAttr(schema, etype, label, props) {
  const schemaRefProps = schema
    ? refPropsFromSchema(schema, etype, label)
    : null;
  const attrId = uuid();
  const fwdIdent = [uuid(), etype, label];
  const revIdent = [uuid(), label, etype];
  return {
    id: attrId,
    'forward-identity': fwdIdent,
    'reverse-identity': revIdent,
    'value-type': 'ref',
    cardinality: 'many',
    'unique?': false,
    'index?': false,
    isUnsynced: true,
    ...(schemaRefProps || {}),
    ...(props || {}),
  };
}

// Actions that have an object, e.g. not delete
const OBJ_ACTIONS = new Set(['update', 'merge', 'link', 'unlink']);
const REF_ACTIONS = new Set(['link', 'unlink']);
const UPDATE_ACTIONS = new Set(['update', 'merge']);
const SUPPORTS_LOOKUP_ACTIONS = new Set([
  'link',
  'unlink',
  'update',
  'merge',
  'delete',
]);

const lookupProps = { 'unique?': true, 'index?': true };
const refLookupProps = { ...lookupProps, cardinality: 'one' };

function lookupPairsOfOp(op) {
  const res = [];
  const [action, etype, eid, obj] = op;
  if (!SUPPORTS_LOOKUP_ACTIONS.has(action)) {
    return res;
  }

  const eidLookupPair = lookupPairOfEid(eid);
  if (eidLookupPair) {
    res.push({ etype: etype, lookupPair: eidLookupPair });
  }
  if (action === 'link') {
    for (const [label, eidOrEids] of Object.entries(obj)) {
      const eids = Array.isArray(eidOrEids) ? eidOrEids : [eidOrEids];
      for (const linkEid of eids) {
        const linkEidLookupPair = lookupPairOfEid(linkEid);
        if (linkEidLookupPair) {
          res.push({
            etype: etype,
            lookupPair: linkEidLookupPair,
            linkLabel: label,
          });
        }
      }
    }
  }
  return res;
}

function createMissingAttrs({ attrs: existingAttrs, schema }, ops) {
  const [addedIds, attrs, addOps] = [new Set(), { ...existingAttrs }, []];
  function addAttr(attr) {
    attrs[attr.id] = attr;
    addOps.push(['add-attr', attr]);
    addedIds.add(attr.id);
  }
  function addUnsynced(attr) {
    if (attr?.isUnsynced && !addedIds.has(attr.id)) {
      addOps.push(['add-attr', attr]);
      addedIds.add(attr.id);
    }
  }

  // Adds attrs needed for a ref lookup
  function addForRef(etype, label) {
    const fwdAttr = getAttrByFwdIdentName(attrs, etype, label);
    const revAttr = getAttrByReverseIdentName(attrs, etype, label);
    addUnsynced(fwdAttr);
    addUnsynced(revAttr);
    if (!fwdAttr && !revAttr) {
      addAttr(createRefAttr(schema, etype, label, refLookupProps));
    }
  }

  // Create attrs for lookups if we need to
  // Do these first because otherwise we might add a non-unique attr
  // before we get to it
  for (const op of ops) {
    for (const { etype, lookupPair, linkLabel } of lookupPairsOfOp(op)) {
      const identName = lookupPair[0];
      // We got a link eid that's a lookup, linkLabel is the label of the ident,
      // e.g. `posts` in `link({posts: postIds})`
      if (linkLabel) {
        // Add our ref attr, e.g. users.posts
        addForRef(etype, linkLabel);

        // Figure out the link etype so we can make sure we have the attrs
        // for the link lookup
        const fwdAttr = getAttrByFwdIdentName(attrs, etype, linkLabel);
        const revAttr = getAttrByReverseIdentName(attrs, etype, linkLabel);
        addUnsynced(fwdAttr);
        addUnsynced(revAttr);
        const linkEtype =
          fwdAttr?.['reverse-identity']?.[1] ||
          revAttr?.['forward-identity']?.[1] ||
          linkLabel;
        if (isRefLookupIdent(attrs, linkEtype, identName)) {
          addForRef(linkEtype, extractRefLookupFwdName(identName));
        } else {
          const attr = getAttrByFwdIdentName(attrs, linkEtype, identName);
          if (!attr) {
            addAttr(
              createObjectAttr(schema, linkEtype, identName, lookupProps),
            );
          }
          addUnsynced(attr);
        }
      } else if (isRefLookupIdent(attrs, etype, identName)) {
        addForRef(etype, extractRefLookupFwdName(identName));
      } else {
        const attr = getAttrByFwdIdentName(attrs, etype, identName);
        if (!attr) {
          addAttr(createObjectAttr(schema, etype, identName, lookupProps));
        }
        addUnsynced(attr);
      }
    }
  }

  // Create object and ref attrs
  for (const op of ops) {
    const [action, etype, eid, obj] = op;
    if (OBJ_ACTIONS.has(action)) {
      const labels = Object.keys(obj);
      labels.push('id');
      for (const label of labels) {
        const fwdAttr = getAttrByFwdIdentName(attrs, etype, label);
        addUnsynced(fwdAttr);
        if (UPDATE_ACTIONS.has(action)) {
          if (!fwdAttr) {
            addAttr(
              createObjectAttr(
                schema,
                etype,
                label,
                label === 'id' ? { 'unique?': true } : null,
              ),
            );
          }
        }
        if (REF_ACTIONS.has(action)) {
          const revAttr = getAttrByReverseIdentName(attrs, etype, label);
          if (!fwdAttr && !revAttr) {
            addAttr(createRefAttr(schema, etype, label));
          }
          addUnsynced(revAttr);
        }
      }
    }
  }
  return [attrs, addOps];
}

export function transform(ctx, inputChunks) {
  const chunks = Array.isArray(inputChunks) ? inputChunks : [inputChunks];
  const ops = chunks.flatMap((tx) => getOps(tx));
  const [newAttrs, addAttrTxSteps] = createMissingAttrs(ctx, ops);
  const txSteps = ops.flatMap((op) => toTxSteps(newAttrs, op));
  return [...addAttrTxSteps, ...txSteps];
}
</file>

<file path="client/packages/core/src/instaql.js">
import { query as datalogQuery } from './datalog';
import { uuidCompare } from './utils/uuid';
import * as s from './store';

// Pattern variables
// -----------------

let _seed = 0;

function wildcard(friendlyName) {
  return makeVarImpl(`_${friendlyName}`, _seed++);
}

function makeVarImpl(x, level) {
  return `?${x}-${level}`;
}

// Where
// -----------------

class AttrNotFoundError extends Error {
  constructor(message) {
    super(message);
    this.name = 'AttrNotFoundError';
  }
}

function idAttr(store, ns) {
  const attr = s.getPrimaryKeyAttr(store, ns);

  if (!attr) {
    throw new AttrNotFoundError(`Could not find id attr for ${ns}`);
  }
  return attr;
}

function defaultWhere(makeVar, store, etype, level) {
  return [eidWhere(makeVar, store, etype, level)];
}

function eidWhere(makeVar, store, etype, level) {
  return [
    makeVar(etype, level),
    idAttr(store, etype).id,
    makeVar(etype, level),
    makeVar('time', level),
  ];
}

function replaceInAttrPat(attrPat, needle, v) {
  return attrPat.map((x) => (x === needle ? v : x));
}

function refAttrPat(makeVar, store, etype, level, label) {
  const fwdAttr = s.getAttrByFwdIdentName(store, etype, label);
  const revAttr = s.getAttrByReverseIdentName(store, etype, label);
  const attr = fwdAttr || revAttr;

  if (!attr) {
    throw new AttrNotFoundError(`Could not find attr for ${[etype, label]}`);
  }

  if (attr['value-type'] !== 'ref') {
    throw new Error(`Attr ${attr.id} is not a ref`);
  }

  const [_f, fwdEtype] = attr['forward-identity'];
  const [_r, revEtype] = attr['reverse-identity'];
  const nextLevel = level + 1;
  const attrPat = fwdAttr
    ? [
        makeVar(fwdEtype, level),
        attr.id,
        makeVar(revEtype, nextLevel),
        wildcard('time'),
      ]
    : [
        makeVar(fwdEtype, nextLevel),
        attr.id,
        makeVar(revEtype, level),
        wildcard('time'),
      ];

  const nextEtype = fwdAttr ? revEtype : fwdEtype;

  const isForward = Boolean(fwdAttr);

  return [nextEtype, nextLevel, attrPat, attr, isForward];
}

function makeLikeMatcher(caseSensitive, pattern) {
  if (typeof pattern !== 'string') {
    return function likeMatcher(_value) {
      return false;
    };
  }

  const escapedPattern = pattern.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
  const regexPattern = escapedPattern.replace(/%/g, '.*').replace(/_/g, '.');

  const regex = new RegExp(
    `^${regexPattern}$`,
    caseSensitive ? undefined : 'i',
  );

  return function likeMatcher(value) {
    if (typeof value !== 'string') {
      return false;
    }
    return regex.test(value);
  };
}

function parseValue(attr, v) {
  if (
    typeof v !== 'object' ||
    v.hasOwnProperty('$in') ||
    v.hasOwnProperty('in')
  ) {
    return v;
  }

  const isDate = attr['checked-data-type'] === 'date';

  if (v.hasOwnProperty('$gt')) {
    return {
      $comparator: true,
      $op: isDate
        ? function gtDate(triple) {
            return new Date(triple[2]) > new Date(v.$gt);
          }
        : function gt(triple) {
            return triple[2] > v.$gt;
          },
    };
  }
  if (v.hasOwnProperty('$gte')) {
    return {
      $comparator: true,
      $op: isDate
        ? function gteDate(triple) {
            return new Date(triple[2]) >= new Date(v.$gte);
          }
        : function gte(triple) {
            return triple[2] >= v.$gte;
          },
    };
  }

  if (v.hasOwnProperty('$lt')) {
    return {
      $comparator: true,
      $op: isDate
        ? function ltDate(triple) {
            return new Date(triple[2]) < new Date(v.$lt);
          }
        : function lt(triple) {
            return triple[2] < v.$lt;
          },
    };
  }
  if (v.hasOwnProperty('$lte')) {
    return {
      $comparator: true,
      $op: isDate
        ? function lteDate(triple) {
            return new Date(triple[2]) <= new Date(v.$lte);
          }
        : function lte(triple) {
            return triple[2] <= v.$lte;
          },
    };
  }

  if (v.hasOwnProperty('$like')) {
    const matcher = makeLikeMatcher(true, v.$like);
    return {
      $comparator: true,
      $op: function like(triple) {
        return matcher(triple[2]);
      },
    };
  }

  if (v.hasOwnProperty('$ilike')) {
    const matcher = makeLikeMatcher(false, v.$ilike);
    return {
      $comparator: true,
      $op: function ilike(triple) {
        return matcher(triple[2]);
      },
    };
  }

  return v;
}

function valueAttrPat(makeVar, store, valueEtype, valueLevel, valueLabel, v) {
  const fwdAttr = s.getAttrByFwdIdentName(store, valueEtype, valueLabel);
  const revAttr = s.getAttrByReverseIdentName(store, valueEtype, valueLabel);
  const attr = fwdAttr || revAttr;

  if (!attr) {
    throw new AttrNotFoundError(
      `No attr for etype = ${valueEtype} label = ${valueLabel}`,
    );
  }

  if (v?.hasOwnProperty('$isNull')) {
    const idAttr = s.getAttrByFwdIdentName(store, valueEtype, 'id');
    if (!idAttr) {
      throw new AttrNotFoundError(
        `No attr for etype = ${valueEtype} label = id`,
      );
    }

    return [
      makeVar(valueEtype, valueLevel),
      idAttr.id,
      { $isNull: { attrId: attr.id, isNull: v.$isNull, reverse: !fwdAttr } },
      wildcard('time'),
    ];
  }

  if (fwdAttr) {
    return [
      makeVar(valueEtype, valueLevel),
      attr.id,
      parseValue(attr, v),
      wildcard('time'),
    ];
  }
  return [v, attr.id, makeVar(valueEtype, valueLevel), wildcard('time')];
}

function refAttrPats(makeVar, store, etype, level, refsPath) {
  const [lastEtype, lastLevel, attrPats] = refsPath.reduce(
    (acc, label) => {
      const [etype, level, attrPats] = acc;
      const [nextEtype, nextLevel, attrPat] = refAttrPat(
        makeVar,
        store,
        etype,
        level,
        label,
      );
      return [nextEtype, nextLevel, [...attrPats, attrPat]];
    },
    [etype, level, []],
  );

  return [lastEtype, lastLevel, attrPats];
}

function whereCondAttrPats(makeVar, store, etype, level, path, v) {
  const refsPath = path.slice(0, path.length - 1);
  const valueLabel = path[path.length - 1];
  const [lastEtype, lastLevel, refPats] = refAttrPats(
    makeVar,
    store,
    etype,
    level,
    refsPath,
  );
  const valuePat = valueAttrPat(
    makeVar,
    store,
    lastEtype,
    lastLevel,
    valueLabel,
    v,
  );

  return refPats.concat([valuePat]);
}

function withJoin(where, join) {
  return join ? [join].concat(where) : where;
}

function isOrClauses([k, v]) {
  return k === 'or' && Array.isArray(v);
}

function isAndClauses([k, v]) {
  return k === 'and' && Array.isArray(v);
}

// Creates a makeVar that will namespace symbols for or clauses
// to prevent conflicts, except for the base etype
function genMakeVar(baseMakeVar, joinSym, orIdx) {
  return (x, lvl) => {
    const base = baseMakeVar(x, lvl);
    if (joinSym == base) {
      return base;
    }
    return `${base}-${orIdx}`;
  };
}

function parseWhereClauses(
  makeVar,
  clauseType /* 'or' | 'and' */,
  store,
  etype,
  level,
  whereValue,
) {
  const joinSym = makeVar(etype, level);
  const patterns = whereValue.map((w, i) => {
    const makeNamespacedVar = genMakeVar(makeVar, joinSym, i);
    return parseWhere(makeNamespacedVar, store, etype, level, w);
  });
  return { [clauseType]: { patterns, joinSym } };
}

// Given a path, returns a list of paths leading up to this path:
// growPath([1, 2, 3]) -> [[1], [1, 2], [1, 2, 3]]
function growPath(path) {
  const ret = [];
  for (let i = 1; i <= path.length; i++) {
    ret.push(path.slice(0, i));
  }
  return ret;
}

// Returns array of pattern arrays that should be grouped in OR
// to capture any intermediate nulls
function whereCondAttrPatsForNullIsTrue(makeVar, store, etype, level, path) {
  return growPath(path).map((path) =>
    whereCondAttrPats(makeVar, store, etype, level, path, { $isNull: true }),
  );
}

function parseWhere(makeVar, store, etype, level, where) {
  return Object.entries(where).flatMap(([k, v]) => {
    if (isOrClauses([k, v])) {
      return parseWhereClauses(makeVar, 'or', store, etype, level, v);
    }
    if (isAndClauses([k, v])) {
      return parseWhereClauses(makeVar, 'and', store, etype, level, v);
    }

    // Temporary hack until we have support for a uuid index on `id`
    if (k === '$entityIdStartsWith') {
      return [];
    }

    const path = k.split('.');

    if (v?.hasOwnProperty('$not')) {
      // `$not` won't pick up entities that are missing the attr, so we
      // add in a `$isNull` to catch those too.
      const notPats = whereCondAttrPats(makeVar, store, etype, level, path, v);
      const nilPats = whereCondAttrPatsForNullIsTrue(
        makeVar,
        store,
        etype,
        level,
        path,
      );
      return [
        {
          or: {
            patterns: [notPats, ...nilPats],
            joinSym: makeVar(etype, level),
          },
        },
      ];
    }

    if (v?.hasOwnProperty('$isNull') && v.$isNull === true && path.length > 1) {
      // Make sure we're capturing all of the intermediate paths that might be null
      // by checking for null at each step along the path
      return [
        {
          or: {
            patterns: whereCondAttrPatsForNullIsTrue(
              makeVar,
              store,
              etype,
              level,
              path,
            ),
            joinSym: makeVar(etype, level),
          },
        },
      ];
    }

    return whereCondAttrPats(makeVar, store, etype, level, path, v);
  });
}

function makeWhere(store, etype, level, where) {
  const makeVar = makeVarImpl;
  if (!where) {
    return defaultWhere(makeVar, store, etype, level);
  }
  const parsedWhere = parseWhere(makeVar, store, etype, level, where);
  return parsedWhere.concat(defaultWhere(makeVar, store, etype, level));
}

// Find
// -----------------

function makeFind(makeVar, etype, level) {
  return [makeVar(etype, level), makeVar('time', level)];
}

// extendObjects
// -----------------

function makeJoin(makeVar, store, etype, level, label, eid) {
  const [nextEtype, nextLevel, pat, attr, isForward] = refAttrPat(
    makeVar,
    store,
    etype,
    level,
    label,
  );
  const actualized = replaceInAttrPat(pat, makeVar(etype, level), eid);
  return [nextEtype, nextLevel, actualized, attr, isForward];
}

function extendObjects(makeVar, store, { etype, level, form }, objects) {
  const childQueries = Object.keys(form).filter((c) => c !== '$');
  if (!childQueries.length) {
    return Object.values(objects);
  }
  return Object.entries(objects).map(function extendChildren([eid, parent]) {
    const childResults = childQueries.map(function getChildResult(label) {
      const isSingular = Boolean(
        store.cardinalityInference &&
          store.linkIndex?.[etype]?.[label]?.isSingular,
      );

      try {
        const [nextEtype, nextLevel, join] = makeJoin(
          makeVar,
          store,
          etype,
          level,
          label,
          eid,
        );

        const childrenArray = queryOne(store, {
          etype: nextEtype,
          level: nextLevel,
          form: form[label],
          join,
        });

        const childOrChildren = isSingular ? childrenArray[0] : childrenArray;

        return { [label]: childOrChildren };
      } catch (e) {
        if (e instanceof AttrNotFoundError) {
          return { [label]: isSingular ? undefined : [] };
        }
        throw e;
      }
    });

    return childResults.reduce(function reduceChildren(parent, child) {
      return { ...parent, ...child };
    }, parent);
  });
}

// resolveObjects
// -----------------

function shouldIgnoreAttr(attrs, id) {
  const attr = attrs[id];
  return attr['value-type'] === 'ref' && attr['forward-identity'][2] !== 'id';
}

function compareOrder([id_a, v_a], [id_b, v_b]) {
  if (v_a === v_b || (v_a == null && v_b == null)) {
    return uuidCompare(id_a, id_b);
  }

  if (v_b == null) {
    return 1;
  }
  if (v_a == null) {
    return -1;
  }
  if (v_a > v_b) {
    return 1;
  }
  return -1;
}

function comparableDate(x) {
  if (x == null) {
    return x;
  }
  return new Date(x).getTime();
}

function isBefore(startCursor, orderAttr, direction, idVec) {
  const [c_e, _c_a, c_v, c_t] = startCursor;
  const compareVal = direction === 'desc' ? 1 : -1;
  if (orderAttr['forward-identity']?.[2] === 'id') {
    return compareOrder(idVec, [c_e, c_t]) === compareVal;
  }
  const [e, v] = idVec;
  const v_new =
    orderAttr['checked-data-type'] === 'date' ? comparableDate(v) : v;
  const c_v_new =
    orderAttr['checked-data-type'] === 'date' ? comparableDate(c_v) : c_v;
  return compareOrder([e, v_new], [c_e, c_v_new]) === compareVal;
}

function orderAttrFromCursor(store, cursor) {
  const cursorAttrId = cursor[1];
  return store.attrs[cursorAttrId];
}

function orderAttrFromOrder(store, etype, order) {
  const label = Object.keys(order)[0];
  return s.getAttrByFwdIdentName(store, etype, label);
}

function getOrderAttr(store, etype, cursor, order) {
  if (cursor) {
    return orderAttrFromCursor(store, cursor);
  }
  if (order) {
    return orderAttrFromOrder(store, etype, order);
  }
}

function runDataloadAndReturnObjects(
  store,
  etype,
  direction,
  pageInfo,
  order,
  dq,
) {
  let idVecs = datalogQuery(store, dq);

  const startCursor = pageInfo?.['start-cursor'];
  const orderAttr = getOrderAttr(store, etype, startCursor, order);

  if (orderAttr && orderAttr?.['forward-identity']?.[2] !== 'id') {
    const isDate = orderAttr['checked-data-type'] === 'date';
    const a = orderAttr.id;
    idVecs = idVecs.map(([id]) => {
      // order attr is required to be cardinality one, so there will
      // be at most one value here
      let v = store.eav.get(id)?.get(a)?.values()?.next()?.value?.[2];
      if (isDate) {
        v = comparableDate(v);
      }
      return [id, v];
    });
  }

  idVecs.sort(
    direction === 'asc'
      ? function compareIdVecs(a, b) {
          return compareOrder(a, b);
        }
      : function compareIdVecs(a, b) {
          return compareOrder(b, a);
        },
  );

  let objects = {};

  for (const idVec of idVecs) {
    const [id] = idVec;
    if (objects[id]) {
      continue;
    }
    if (
      startCursor &&
      orderAttr &&
      isBefore(startCursor, orderAttr, direction, idVec)
    ) {
      continue;
    }

    const obj = s.getAsObject(store, etype, id);
    if (obj) {
      objects[id] = obj;
    }
  }
  return objects;
}

function determineOrder(form) {
  const orderOpts = form.$?.order;
  if (!orderOpts) {
    return 'asc';
  }

  return orderOpts[Object.keys(orderOpts)[0]] || 'asc';
}

/**
 * Given a query like:
 *
 * {
 *   users: {
 *     $: { where: { name: "Joe" } },
 *   },
 * };
 *
 * `resolveObjects`, turns where clause: `{ name: "Joe" }`
 * into a datalog query. We then run the datalog query,
 * and reduce all the triples into objects.
 */
function resolveObjects(store, { etype, level, form, join, pageInfo }) {
  const limit = form.$?.limit || form.$?.first || form.$?.last;
  const offset = form.$?.offset;
  const before = form.$?.before;
  const after = form.$?.after;
  const order = form.$?.order;

  // Wait for server to tell us where we start if we don't start from the beginning
  if ((offset || before || after) && (!pageInfo || !pageInfo['start-cursor'])) {
    return [];
  }
  const where = withJoin(makeWhere(store, etype, level, form.$?.where), join);

  const find = makeFind(makeVarImpl, etype, level);

  const objs = runDataloadAndReturnObjects(
    store,
    etype,
    determineOrder(form),
    pageInfo,
    order,
    { where, find },
  );

  if (limit != null) {
    const entries = Object.entries(objs);
    if (entries.length <= limit) {
      return objs;
    }
    return Object.fromEntries(entries.slice(0, limit));
  }
  return objs;
}

/**
 * It's possible that we query
 * for an attribute that doesn't exist yet.
 *
 * { users: { $: { where: { nonExistentProperty: "foo" } } } }
 *
 * This swallows the missing attr error and returns
 * an empty result instead
 */
function guardedResolveObjects(store, opts) {
  try {
    return resolveObjects(store, opts);
  } catch (e) {
    if (e instanceof AttrNotFoundError) {
      return {};
    }
    throw e;
  }
}
/**
 * Given a query like:
 *
 * {
 *   users: {
 *     $: { where: { name: "Joe" } },
 *     posts: {},
 *   },
 * };
 *
 * `guardResolveObjects` will return the relevant `users` objects
 * `extendObjects` will then extend each `user` object with relevant `posts`.
 */
function queryOne(store, opts) {
  const objects = guardedResolveObjects(store, opts);
  return extendObjects(makeVarImpl, store, opts, objects);
}

function formatPageInfo(pageInfo) {
  const res = {};
  for (const [k, v] of Object.entries(pageInfo)) {
    res[k] = {
      startCursor: v['start-cursor'],
      endCursor: v['end-cursor'],
      hasNextPage: v['has-next-page?'],
      hasPreviousPage: v['has-previous-page?'],
    };
  }
  return res;
}

export default function query({ store, pageInfo, aggregate }, q) {
  const data = Object.keys(q).reduce(function reduceResult(res, k) {
    if (aggregate?.[k]) {
      // Aggregate doesn't return any join rows and has no children,
      // so don't bother querying further
      return res;
    }
    res[k] = queryOne(store, {
      etype: k,
      form: q[k],
      level: 0,
      pageInfo: pageInfo?.[k],
    });
    return res;
  }, {});

  const result = { data };
  if (pageInfo) {
    result.pageInfo = formatPageInfo(pageInfo);
  }

  if (aggregate) {
    result.aggregate = aggregate;
  }

  return result;
}
</file>

<file path="client/packages/core/src/instatx.ts">
import type {
  IContainEntitiesAndLinks,
  LinkParams,
  UpdateParams,
} from './schemaTypes';

type Action = 'update' | 'link' | 'unlink' | 'delete' | 'merge';
type EType = string;
type Id = string;
type Args = any;
type LookupRef = [string, any];
type Lookup = string;
export type Op = [Action, EType, Id | LookupRef, Args];

export interface TransactionChunk<
  Schema extends IContainEntitiesAndLinks<any, any>,
  EntityName extends keyof Schema['entities'],
> {
  __ops: Op[];
  /**
   * Create and update objects:
   *
   * @example
   *  const goalId = id();
   *  tx.goals[goalId].update({title: "Get fit", difficulty: 5})
   */
  update: (
    args: UpdateParams<Schema, EntityName>,
  ) => TransactionChunk<Schema, EntityName>;
  /**
   * Link two objects together
   *
   * @example
   * const goalId = id();
   * const todoId = id();
   * db.transact([
   *   tx.goals[goalId].update({title: "Get fit"}),
   *   tx.todos[todoId].update({title: "Go on a run"}),
   *   tx.goals[goalId].link({todos: todoId}),
   * ])
   *
   * // Now, if you query:
   * useQuery({ goals: { todos: {} } })
   * // You'll get back:
   *
   * // { goals: [{ title: "Get fit", todos: [{ title: "Go on a run" }]}
   */
  link: (
    args: LinkParams<Schema, EntityName>,
  ) => TransactionChunk<Schema, EntityName>;
  /**
   * Unlink two objects
   * @example
   *  // to "unlink" a todo from a goal:
   *  tx.goals[goalId].unlink({todos: todoId})
   */
  unlink: (
    args: LinkParams<Schema, EntityName>,
  ) => TransactionChunk<Schema, EntityName>;
  /**
   * Delete an object, alongside all of its links.
   *
   * @example
   *   tx.goals[goalId].delete()
   */
  delete: () => TransactionChunk<Schema, EntityName>;

  /**
   *
   * Similar to `update`, but instead of overwriting the current value, it will merge the provided values into the current value.
   *
   * This is useful for deeply nested, document-style values, or for updating a single attribute at an arbitrary depth without overwriting the rest of the object.
   *
   * For example, if you have a goal with a nested `metrics` object:
   *
   * ```js
   * goal = { name: "Get fit", metrics: { progress: 0.3 } }
   * ```
   *
   * You can update the `progress` attribute like so:
   *
   * ```js
   * tx.goals[goalId].merge({ metrics: { progress: 0.5 }, category: "Fitness" })
   * ```
   *
   * And the resulting object will be:
   *
   * ```js
   * goal = { name: "Get fit", metrics: { progress: 0.5 }, category: "Fitness"  }
   *  ```
   *
   * @example
   *  const goalId = id();
   *  tx.goals[goalId].merge({title: "Get fitter"})
   */
  merge: (args: {
    [attribute: string]: any;
  }) => TransactionChunk<Schema, EntityName>;
}

export interface ETypeChunk<
  Schema extends IContainEntitiesAndLinks<any, any>,
  EntityName extends keyof Schema['entities'],
> {
  [id: Id]: TransactionChunk<Schema, EntityName>;
}

export type TxChunk<Schema extends IContainEntitiesAndLinks<any, any>> = {
  [EntityName in keyof Schema['entities']]: ETypeChunk<Schema, EntityName>;
};

function transactionChunk(
  etype: EType,
  id: Id | LookupRef,
  prevOps: Op[],
): TransactionChunk<any, any> {
  return new Proxy({} as TransactionChunk<any, any>, {
    get: (_target, cmd: keyof TransactionChunk<any, any>) => {
      if (cmd === '__ops') return prevOps;
      return (args: Args) => {
        return transactionChunk(etype, id, [
          ...prevOps,
          [cmd, etype, id, args],
        ]);
      };
    },
  });
}

/**
 * Creates a lookup to use in place of an id in a transaction
 *
 * @example
 * tx.users[lookup('email', 'lyndon@example.com')].update({name: 'Lyndon'})
 */
export function lookup(attribute: string, value: any): Lookup {
  return `lookup__${attribute}__${JSON.stringify(value)}`;
}

export function isLookup(k: string): boolean {
  return k.startsWith('lookup__');
}

export function parseLookup(k: string): LookupRef {
  const [_, attribute, ...vJSON] = k.split('__');
  return [attribute, JSON.parse(vJSON.join('__'))];
}

function etypeChunk(etype: EType): ETypeChunk<any, EType> {
  return new Proxy(
    {},
    {
      get(_target, id: Id) {
        if (isLookup(id)) {
          return transactionChunk(etype, parseLookup(id), []);
        }
        return transactionChunk(etype, id, []);
      },
    },
  );
}

export function txInit<
  Schema extends IContainEntitiesAndLinks<any, any>,
>(): TxChunk<Schema> {
  return new Proxy(
    {},
    {
      get(_target, ns: EType) {
        return etypeChunk(ns);
      },
    },
  ) as any;
}

/**
 * A handy builder for changes.
 *
 * You must start with the `namespace` you want to change:
 *
 * @example
 *   tx.goals[goalId].update({title: "Get fit"})
 *   // Note: you don't need to create `goals` ahead of time.
 */
export const tx = txInit();

export function getOps(x: TransactionChunk<any, any>): Op[] {
  return x.__ops;
}
</file>

<file path="client/packages/core/src/presence.ts">
import { pick } from './utils/pick';
import { areObjectsShallowEqual, areObjectKeysEqual } from './utils/object';

export type RoomSchemaShape = {
  [k: string]: {
    presence?: { [k: string]: any };
    topics?: {
      [k: string]: {
        [k: string]: any;
      };
    };
  };
};

export type PresenceOpts<PresenceShape, Keys extends keyof PresenceShape> = {
  user?: boolean;
  peers?: string[];
  keys?: Keys[];
};

type PresencePeer<PresenceShape, Keys extends keyof PresenceShape> = Pick<
  PresenceShape,
  Keys
> & {
  peerId: string;
};

export type PresenceSlice<PresenceShape, Keys extends keyof PresenceShape> = {
  user?: PresencePeer<PresenceShape, Keys>;
  peers: {
    [peerId: string]: PresencePeer<PresenceShape, Keys>;
  };
};

export type PresenceResponse<
  PresenceShape,
  Keys extends keyof PresenceShape,
> = PresenceSlice<PresenceShape, Keys> & {
  isLoading: boolean;
  error?: string;
};

export function buildPresenceSlice<
  PresenceShape,
  Keys extends keyof PresenceShape,
>(
  data: {
    user?: PresenceShape;
    peers: Record<string, PresenceShape>;
  },
  opts: PresenceOpts<PresenceShape, Keys>,
  userPeerId: string,
): PresenceSlice<PresenceShape, Keys> {
  const slice: PresenceSlice<PresenceShape, Keys> = {
    peers: {},
  };

  const includeUser = opts && 'user' in opts ? opts.user : true;

  if (includeUser) {
    const user = pick(data.user ?? {}, opts?.keys);
    slice.user = { ...user, peerId: userPeerId };
  }

  for (const id of Object.keys(data.peers ?? {})) {
    const shouldIncludeAllPeers = opts?.peers === undefined;
    const isPeerIncluded =
      Array.isArray(opts?.peers) && opts?.peers.includes(id);

    if (shouldIncludeAllPeers || isPeerIncluded) {
      const peer = pick(data.peers[id], opts?.keys);
      slice.peers[id] = { ...peer, peerId: id };
    }
  }

  return slice;
}

/**
 * Compare two presence slices
 * 0. compare isLoading and error
 * 1. shallow compare user
 * 2. compare peers keys
 * 3. shallow compare each peer
 */
export function hasPresenceResponseChanged<
  PresenceShape,
  Keys extends keyof PresenceShape,
>(
  a: PresenceResponse<PresenceShape, Keys>,
  b: PresenceResponse<PresenceShape, Keys>,
) {
  if (a.isLoading !== b.isLoading) return true;
  if (a.error !== b.error) return true;

  if (a.user || b.user) {
    if (!a.user || !b.user) return true;

    const same = areObjectsShallowEqual(a.user, b.user);

    if (!same) return true;
  }

  const sameKeys = areObjectKeysEqual(a.peers, b.peers);

  if (!sameKeys) return true;

  for (const id of Object.keys(a.peers)) {
    const same = areObjectsShallowEqual(a.peers[id], b.peers[id]);

    if (!same) return true;
  }

  return false;
}
</file>

<file path="client/packages/core/src/queryTypes.ts">
// Query
// -----

import type {
  EntitiesDef,
  IContainEntitiesAndLinks,
  InstantGraph,
  LinkAttrDef,
  ResolveAttrs,
  ResolveEntityAttrs,
} from './schemaTypes';

type BuiltIn = Date | Function | Error | RegExp;

type Expand<T> = T extends BuiltIn
  ? T
  : T extends object
    ? T extends infer O
      ? { [K in keyof O]: Expand<O[K]> }
      : never
    : T;

// NonEmpty disallows {}, so that you must provide at least one field
type NonEmpty<T> = {
  [K in keyof T]-?: Required<Pick<T, K>>;
}[keyof T];

type WhereArgs = {
  /** @deprecated use `$in` instead of `in` */
  in?: (string | number | boolean)[];
  $in?: (string | number | boolean)[];
  $not?: string | number | boolean;
  $isNull?: boolean;
  $gt?: string | number | boolean;
  $lt?: string | number | boolean;
  $gte?: string | number | boolean;
  $lte?: string | number | boolean;
  $like?: string;
  $ilike?: string;
};

type WhereClauseValue = string | number | boolean | NonEmpty<WhereArgs>;

type BaseWhereClause = {
  [key: string]: WhereClauseValue;
};

type WhereClauseWithCombination = {
  or?: WhereClause[] | WhereClauseValue;
  and?: WhereClause[] | WhereClauseValue;
};

type WhereClause =
  | WhereClauseWithCombination
  | (WhereClauseWithCombination & BaseWhereClause);

/**
 * A tuple representing a cursor.
 * These should not be constructed manually. The current format
 * is an implementation detail that may change in the future.
 * Use the `endCursor` or `startCursor` from the PageInfoResponse as the
 * `before` or `after` field in the query options.
 */
type Cursor = [string, string, any, number];

type Direction = 'asc' | 'desc';

type Order = { [key: string]: Direction };

type $Option = {
  $?: {
    where?: WhereClause;
    order?: Order;
    limit?: number;
    last?: number;
    first?: number;
    offset?: number;
    after?: Cursor;
    before?: Cursor;
  };
};

type Subquery = { [namespace: string]: NamespaceVal };

type NamespaceVal = $Option | ($Option & Subquery);

interface Query {
  [namespace: string]: NamespaceVal;
}

type InstantObject = {
  id: string;
  [prop: string]: any;
};

type ResponseObject<K, Schema> = K extends keyof Schema
  ? { id: string } & Schema[K]
  : InstantObject;

type IsEmptyObject<T> = T extends Record<string, never> ? true : false;

type ResponseOf<Q, Schema> = {
  [K in keyof Q]: IsEmptyObject<Q[K]> extends true
    ? ResponseObject<K, Schema>[]
    : (ResponseOf<Q[K], Schema> & ResponseObject<K, Schema>)[];
};

type Remove$<T> = T extends object
  ? { [K in keyof T as Exclude<K, '$'>]: Remove$<T[K]> }
  : T;

type QueryResponse<
  Q,
  Schema,
  WithCardinalityInference extends boolean = false,
> =
  Schema extends InstantGraph<infer E, any>
    ? InstaQLQueryResult<E, Q, WithCardinalityInference>
    : ResponseOf<{ [K in keyof Q]: Remove$<Q[K]> }, Schema>;

type InstaQLResponse<Schema, Q> =
  Schema extends IContainEntitiesAndLinks<any, any>
    ? InstaQLResult<Schema, Q>
    : never;

type PageInfoResponse<T> = {
  [K in keyof T]: {
    startCursor: Cursor;
    endCursor: Cursor;
    hasNextPage: boolean;
    hasPreviousPage: boolean;
  };
};

/**
 * (XXX)
 * https://github.com/microsoft/TypeScript/issues/26051
 *
 * Typescript can permit extra keys when a generic extends a type.
 *
 * For some reason, it makes it possible to write a query like so:
 *
 * dummyQuery({
 *  users: {
 *    $: { where: { "foo": 1 } },
 *    posts: {
 *      $: { "far": {} }
 *    }
 *  }
 *
 *  The problem: $: { "far": {} }
 *
 *  This passes, when it should in reality fail. I don't know why
 *  adding `Exactly` fixes this, but it does.
 *
 * */
type Exactly<Parent, Child> = Parent & {
  [K in keyof Child]: K extends keyof Parent ? Child[K] : never;
};

// ==========
// InstaQL helpers

type InstaQLEntitySubqueryResult<
  Schema extends IContainEntitiesAndLinks<EntitiesDef, any>,
  EntityName extends keyof Schema['entities'],
  Query extends InstaQLEntitySubquery<Schema, EntityName> = {},
> = {
  [QueryPropName in keyof Query]: Schema['entities'][EntityName]['links'][QueryPropName] extends LinkAttrDef<
    infer Cardinality,
    infer LinkedEntityName
  >
    ? LinkedEntityName extends keyof Schema['entities']
      ? Cardinality extends 'one'
        ?
            | InstaQLEntity<Schema, LinkedEntityName, Query[QueryPropName]>
            | undefined
        : InstaQLEntity<Schema, LinkedEntityName, Query[QueryPropName]>[]
      : never
    : never;
};

type InstaQLQueryEntityLinksResult<
  Entities extends EntitiesDef,
  EntityName extends keyof Entities,
  Query extends {
    [LinkAttrName in keyof Entities[EntityName]['links']]?: any;
  },
  WithCardinalityInference extends boolean,
> = {
  [QueryPropName in keyof Query]: Entities[EntityName]['links'][QueryPropName] extends LinkAttrDef<
    infer Cardinality,
    infer LinkedEntityName
  >
    ? LinkedEntityName extends keyof Entities
      ? WithCardinalityInference extends true
        ? Cardinality extends 'one'
          ?
              | InstaQLQueryEntityResult<
                  Entities,
                  LinkedEntityName,
                  Query[QueryPropName],
                  WithCardinalityInference
                >
              | undefined
          : InstaQLQueryEntityResult<
              Entities,
              LinkedEntityName,
              Query[QueryPropName],
              WithCardinalityInference
            >[]
        : InstaQLQueryEntityResult<
            Entities,
            LinkedEntityName,
            Query[QueryPropName],
            WithCardinalityInference
          >[]
      : never
    : never;
};

type InstaQLEntity<
  Schema extends IContainEntitiesAndLinks<EntitiesDef, any>,
  EntityName extends keyof Schema['entities'],
  Subquery extends InstaQLEntitySubquery<Schema, EntityName> = {},
> = Expand<
  { id: string } & ResolveEntityAttrs<Schema['entities'][EntityName]> &
    InstaQLEntitySubqueryResult<Schema, EntityName, Subquery>
>;

type InstaQLQueryEntityResult<
  Entities extends EntitiesDef,
  EntityName extends keyof Entities,
  Query extends {
    [QueryPropName in keyof Entities[EntityName]['links']]?: any;
  },
  WithCardinalityInference extends boolean,
> = { id: string } & ResolveAttrs<Entities, EntityName> &
  InstaQLQueryEntityLinksResult<
    Entities,
    EntityName,
    Query,
    WithCardinalityInference
  >;

type InstaQLQueryResult<
  Entities extends EntitiesDef,
  Query,
  WithCardinalityInference extends boolean,
> = {
  [QueryPropName in keyof Query]: QueryPropName extends keyof Entities
    ? InstaQLQueryEntityResult<
        Entities,
        QueryPropName,
        Query[QueryPropName],
        WithCardinalityInference
      >[]
    : never;
};

type InstaQLResult<
  Schema extends IContainEntitiesAndLinks<EntitiesDef, any>,
  Query extends InstaQLParams<Schema>,
> = Expand<{
  [QueryPropName in keyof Query]: QueryPropName extends keyof Schema['entities']
    ? InstaQLEntity<Schema, QueryPropName, Remove$<Query[QueryPropName]>>[]
    : never;
}>;

type InstaQLEntitySubquery<
  Schema extends IContainEntitiesAndLinks<EntitiesDef, any>,
  EntityName extends keyof Schema['entities'],
> = {
  [QueryPropName in keyof Schema['entities'][EntityName]['links']]?: InstaQLEntitySubquery<
    Schema,
    Schema['entities'][EntityName]['links'][QueryPropName]['entityName']
  >;
};

type InstaQLQuerySubqueryParams<
  S extends IContainEntitiesAndLinks<any, any>,
  E extends keyof S['entities'],
> = {
  [K in keyof S['entities'][E]['links']]?:
    | $Option
    | ($Option &
        InstaQLQuerySubqueryParams<
          S,
          S['entities'][E]['links'][K]['entityName']
        >);
};

type InstaQLParams<S extends IContainEntitiesAndLinks<any, any>> = {
  [K in keyof S['entities']]?:
    | $Option
    | ($Option & InstaQLQuerySubqueryParams<S, K>);
};

/**
 * @deprecated
 * `InstaQLQueryParams` is deprecated. Use `InstaQLParams` instead.
 *
 * @example
 * // Before
 * const myQuery = {...} satisfies InstaQLQueryParams<Schema>
 * // After
 * const myQuery = {...} satisfies InstaQLParams<Schema>
 */
type InstaQLQueryParams<S extends IContainEntitiesAndLinks<any, any>> =
  InstaQLParams<S>;

export {
  Query,
  QueryResponse,
  InstaQLResponse,
  PageInfoResponse,
  InstantObject,
  Exactly,
  Remove$,
  InstaQLQueryResult,
  InstaQLParams,
  InstaQLQueryEntityResult,
  InstaQLEntity,
  InstaQLResult,
  Cursor,
  InstaQLQueryParams,
};
</file>

<file path="client/packages/core/src/Reactor.js">
// @ts-check
import log from './utils/log';
import weakHash from './utils/weakHash';
import instaql from './instaql';
import * as instaml from './instaml';
import * as s from './store';
import uuid from './utils/uuid';
import IndexedDBStorage from './IndexedDBStorage';
import WindowNetworkListener from './WindowNetworkListener';
import * as authAPI from './authAPI';
import * as StorageApi from './StorageAPI';
import { buildPresenceSlice, hasPresenceResponseChanged } from './presence';
import { Deferred } from './utils/Deferred';
import { PersistedObject } from './utils/PersistedObject';
import { extractTriples } from './model/instaqlResult';
import { areObjectsDeepEqual, assocIn, dissocIn } from './utils/object';
import { createLinkIndex } from './utils/linkIndex';
import version from './version';

const STATUS = {
  CONNECTING: 'connecting',
  OPENED: 'opened',
  AUTHENTICATED: 'authenticated',
  CLOSED: 'closed',
  ERRORED: 'errored',
};

const QUERY_ONCE_TIMEOUT = 30_000;

const WS_CONNECTING_STATUS = 0;
const WS_OPEN_STATUS = 1;

const defaultConfig = {
  apiURI: 'https://api.instantdb.com',
  websocketURI: 'wss://api.instantdb.com/runtime/session',
};

// Param that the backend adds if this is an oauth redirect
const OAUTH_REDIRECT_PARAM = '_instant_oauth_redirect';

const currentUserKey = `currentUser`;

let _wsId = 0;
function createWebSocket(uri) {
  const ws = new WebSocket(uri);
  // @ts-ignore
  ws._id = _wsId++;
  return ws;
}

function isClient() {
  const hasWindow = typeof window !== 'undefined';
  // this checks if we are running in a chrome extension
  // @ts-expect-error
  const isChrome = typeof chrome !== 'undefined';

  return hasWindow || isChrome;
}

const ignoreLogging = {
  'set-presence': true,
  'set-presence-ok': true,
  'refresh-presence': true,
  'patch-presence': true,
};

function querySubsFromJSON(str) {
  const parsed = JSON.parse(str);
  for (const key in parsed) {
    const v = parsed[key];
    if (v?.result?.store) {
      v.result.store = s.fromJSON(v.result.store);
    }
  }
  return parsed;
}

function querySubsToJSON(querySubs) {
  const jsonSubs = {};
  for (const key in querySubs) {
    const sub = querySubs[key];
    const jsonSub = { ...sub };
    if (sub.result?.store) {
      jsonSub.result = {
        ...sub.result,
        store: s.toJSON(sub.result.store),
      };
    }
    jsonSubs[key] = jsonSub;
  }
  return JSON.stringify(jsonSubs);
}

/**
 * @template {import('./presence').RoomSchemaShape} [RoomSchema = {}]
 */
export default class Reactor {
  attrs;
  _isOnline = true;
  _isShutdown = false;
  status = STATUS.CONNECTING;

  /** @type {PersistedObject} */
  querySubs;
  /** @type {PersistedObject} */
  pendingMutations;

  /** @type {Record<string, Array<{ q: any, cb: (data: any) => any }>>} */
  queryCbs = {};
  /** @type {Record<string, Array<{ q: any, eventId: string, dfd: Deferred }>>} */
  queryOnceDfds = {};
  authCbs = [];
  attrsCbs = [];
  mutationErrorCbs = [];
  connectionStatusCbs = [];
  config;
  _persister;
  mutationDeferredStore = new Map();
  _reconnectTimeoutId = null;
  _reconnectTimeoutMs = 0;
  _ws;
  _localIdPromises = {};
  _errorMessage = null;
  /** @type {Promise<null | {error: {message: string}}>}**/
  _oauthCallbackResponse = null;

  /** @type {null | import('./utils/linkIndex').LinkIndex}} */
  _linkIndex = null;

  /** @type BroadcastChannel | undefined */
  _broadcastChannel;

  /** @type {Record<string, {isConnected: boolean; error: any}>} */
  _rooms = {};
  /** @type {Record<string, boolean>} */
  _roomsPendingLeave = {};
  _presence = {};
  _broadcastQueue = [];
  _broadcastSubs = {};
  _currentUserCached = { isLoading: true, error: undefined, user: undefined };
  _beforeUnloadCbs = [];
  _dataForQueryCache = {};

  constructor(
    config,
    Storage = IndexedDBStorage,
    NetworkListener = WindowNetworkListener,
    versions,
  ) {
    this.config = { ...defaultConfig, ...config };
    this.versions = { ...(versions || {}), '@instantdb/core': version };

    if (this.config.schema) {
      this._linkIndex = createLinkIndex(this.config.schema);
    }

    // This is to protect us against running
    // server-side.
    if (!isClient()) {
      return;
    }
    if (typeof BroadcastChannel === 'function') {
      this._broadcastChannel = new BroadcastChannel('@instantdb');
      this._broadcastChannel.addEventListener('message', async (e) => {
        if (e.data?.type === 'auth') {
          const res = await this.getCurrentUser();
          this.updateUser(res.user);
        }
      });
    }

    this._oauthCallbackResponse = this._oauthLoginInit();

    this._initStorage(Storage);

    // kick off a request to cache it
    this.getCurrentUser();

    NetworkListener.getIsOnline().then((isOnline) => {
      this._isOnline = isOnline;
      this._startSocket();
      NetworkListener.listen((isOnline) => {
        // We do this because react native's NetInfo
        // fires multiple online events.
        // We only want to handle one state change
        if (isOnline === this._isOnline) {
          return;
        }
        log.info('[network] online =', isOnline);
        this._isOnline = isOnline;
        if (this._isOnline) {
          this._startSocket();
        } else {
          log.info('Changing status from', this.status, 'to', STATUS.CLOSED);
          this._setStatus(STATUS.CLOSED);
        }
      });
    });

    if (typeof addEventListener !== 'undefined') {
      this._beforeUnload = this._beforeUnload.bind(this);
      addEventListener('beforeunload', this._beforeUnload);
    }
  }

  _initStorage(Storage) {
    this._persister = new Storage(`instant_${this.config.appId}_5`);
    this.querySubs = new PersistedObject(
      this._persister,
      'querySubs',
      {},
      this._onMergeQuerySubs,
      querySubsToJSON,
      querySubsFromJSON,
    );
    this.pendingMutations = new PersistedObject(
      this._persister,
      'pendingMutations',
      new Map(),
      this._onMergePendingMutations,
      (x) => {
        return JSON.stringify([...x.entries()]);
      },
      (x) => {
        return new Map(JSON.parse(x));
      },
    );
    this._beforeUnloadCbs.push(() => {
      this.pendingMutations.flush();
      this.querySubs.flush();
    });
  }

  _beforeUnload() {
    for (const cb of this._beforeUnloadCbs) {
      cb();
    }
  }

  /**
   * @param {'enqueued' | 'pending' | 'synced' | 'timeout' |  'error' } status
   * @param string clientId
   * @param {{message?: string, hint?: string, error?: Error}} [errDetails]
   */
  _finishTransaction(status, clientId, errDetails) {
    const dfd = this.mutationDeferredStore.get(clientId);
    this.mutationDeferredStore.delete(clientId);
    const ok = status !== 'error' && status !== 'timeout';

    if (!dfd && !ok) {
      // console.erroring here, as there are no listeners to let know
      console.error('Mutation failed', { status, clientId, ...errDetails });
    }
    if (!dfd) {
      return;
    }
    if (ok) {
      dfd.resolve({ status, clientId });
    } else {
      dfd.reject({ status, clientId, ...errDetails });
    }
  }

  _setStatus(status, err) {
    this.status = status;
    this._errorMessage = err;
    this.notifyConnectionStatusSubs(status);
  }

  /**
   *  merge querySubs from storage and in memory. Has the following side
   *  effects:
   *  - We notify all queryCbs because results may been added during merge
   */
  _onMergeQuerySubs = (_storageSubs, inMemorySubs) => {
    const storageSubs = _storageSubs || {};
    const ret = { ...inMemorySubs };

    // Consider an inMemorySub with no result;
    // If we have a result from storageSubs, let's add it
    Object.entries(inMemorySubs).forEach(([hash, querySub]) => {
      const storageResult = storageSubs?.[hash]?.result;
      const memoryResult = querySub.result;
      if (storageResult && !memoryResult) {
        ret[hash].result = storageResult;
      }
    });

    // Consider a storageSub with no corresponding inMemorySub
    // This means that at least at this point,
    // the user has not asked to subscribe to the query.
    // We may _still_ want to add it, because in just a
    // few milliseconds, the user will ask to subscribe to the
    // query.
    // For now, we can't really tell if the user will ask to subscribe
    // or not. So for now let's just add the first 10 queries from storage.
    // Eventually, we could be smarter about this. For example,
    // we can keep usage information about which queries are popular.
    const storageKsToAdd = Object.keys(storageSubs)
      .filter((k) => !inMemorySubs[k])
      .slice(0, 10);

    storageKsToAdd.forEach((k) => {
      ret[k] = storageSubs[k];
    });

    // Okay, now we have merged our querySubs
    this.querySubs.set((_) => ret);

    this.loadedNotifyAll();
  };

  /**
   * merge pendingMutations from storage and in memory. Has a side effect of
   * sending mutations that were stored but not acked
   */
  _onMergePendingMutations = (storageMuts, inMemoryMuts) => {
    const ret = new Map([...storageMuts.entries(), ...inMemoryMuts.entries()]);
    this.pendingMutations.set((_) => ret);
    this.loadedNotifyAll();
    const rewrittenStorageMuts = this._rewriteMutations(
      this.attrs,
      storageMuts,
    );
    rewrittenStorageMuts.forEach((mut, k) => {
      if (!inMemoryMuts.has(k) && !mut['tx-id']) {
        this._sendMutation(k, mut);
      }
    });
  };

  _flushEnqueuedRoomData(roomId) {
    const enqueuedUserPresence = this._presence[roomId]?.result?.user;
    const enqueuedBroadcasts = this._broadcastQueue[roomId];

    this._broadcastQueue[roomId] = [];

    if (enqueuedUserPresence) {
      this._trySetPresence(roomId, enqueuedUserPresence);
    }

    if (enqueuedBroadcasts) {
      for (const item of enqueuedBroadcasts) {
        const { topic, roomType, data } = item;
        this._tryBroadcast(roomId, roomType, topic, data);
      }
    }
  }

  _handleReceive(wsId, msg) {
    // opt-out, enabled by default if schema
    const enableCardinalityInference =
      Boolean(this.config.schema) &&
      ('cardinalityInference' in this.config
        ? Boolean(this.config.cardinalityInference)
        : true);
    if (!ignoreLogging[msg.op]) {
      log.info('[receive]', wsId, msg.op, msg);
    }
    switch (msg.op) {
      case 'init-ok':
        this._setStatus(STATUS.AUTHENTICATED);
        this._reconnectTimeoutMs = 0;
        this._setAttrs(msg.attrs);
        this._flushPendingMessages();
        // (EPH): set session-id, so we know
        // which item is us
        this._sessionId = msg['session-id'];

        for (const roomId of Object.keys(this._rooms)) {
          this._tryJoinRoom(roomId);
        }
        break;
      case 'add-query-exists':
        this.notifyOneQueryOnce(weakHash(msg.q));
        break;
      case 'add-query-ok':
        const { q, result } = msg;
        const hash = weakHash(q);
        const pageInfo = result?.[0]?.data?.['page-info'];
        const aggregate = result?.[0]?.data?.['aggregate'];
        const triples = extractTriples(result);
        const store = s.createStore(
          this.attrs,
          triples,
          enableCardinalityInference,
          this._linkIndex,
        );
        this.querySubs.set((prev) => {
          prev[hash].result = { store, pageInfo, aggregate };
          return prev;
        });
        this.notifyOne(hash);
        this.notifyOneQueryOnce(hash);
        break;
      case 'refresh-ok':
        const { computations, attrs } = msg;
        this._setAttrs(attrs);
        const updates = computations.map((x) => {
          const q = x['instaql-query'];
          const result = x['instaql-result'];
          const hash = weakHash(q);
          const triples = extractTriples(result);
          const store = s.createStore(
            this.attrs,
            triples,
            enableCardinalityInference,
            this._linkIndex,
          );
          const pageInfo = result?.[0]?.data?.['page-info'];
          const aggregate = result?.[0]?.data?.['aggregate'];
          return { hash, store, pageInfo, aggregate };
        });
        updates.forEach(({ hash, store, pageInfo, aggregate }) => {
          this.querySubs.set((prev) => {
            prev[hash].result = { store, pageInfo, aggregate };
            return prev;
          });
        });
        updates.forEach(({ hash }) => {
          this.notifyOne(hash);
        });
        break;
      case 'transact-ok':
        const { 'client-event-id': eventId, 'tx-id': txId } = msg;
        const muts = this._rewriteMutations(
          this.attrs,
          this.pendingMutations.currentValue,
        );
        const prevMutation = muts.get(eventId);
        if (!prevMutation) {
          break;
        }

        // Now that this transaction is accepted,
        // We can delete it from our queue.
        this.pendingMutations.set((prev) => {
          prev.delete(eventId);
          return prev;
        });

        // We apply this transaction to all our existing queries
        const txStepsToApply = prevMutation['tx-steps'];
        this.querySubs.set((prev) => {
          for (const [hash, sub] of Object.entries(prev)) {
            const store = sub?.result?.store;
            if (!store) {
              continue;
            }
            const newStore = s.transact(store, txStepsToApply);
            prev[hash].result.store = newStore;
          }
          return prev;
        });

        const newAttrs = prevMutation['tx-steps']
          .filter(([action, ..._args]) => action === 'add-attr')
          .map(([_action, attr]) => attr)
          .concat(Object.values(this.attrs));

        this._setAttrs(newAttrs);

        this._finishTransaction('synced', eventId);
        break;
      case 'patch-presence': {
        const roomId = msg['room-id'];
        this._patchPresencePeers(roomId, msg['edits']);
        this._notifyPresenceSubs(roomId);
        break;
      }
      case 'refresh-presence': {
        const roomId = msg['room-id'];
        this._setPresencePeers(roomId, msg['data']);
        this._notifyPresenceSubs(roomId);
        break;
      }
      case 'server-broadcast':
        const room = msg['room-id'];
        const topic = msg.topic;
        this._notifyBroadcastSubs(room, topic, msg);
        break;
      case 'join-room-ok':
        const loadingRoomId = msg['room-id'];
        const joinedRoom = this._rooms[loadingRoomId];

        if (!joinedRoom) {
          if (this._roomsPendingLeave[loadingRoomId]) {
            this._tryLeaveRoom(loadingRoomId);
            delete this._roomsPendingLeave[loadingRoomId];
          }

          break;
        }

        joinedRoom.isConnected = true;
        this._notifyPresenceSubs(loadingRoomId);
        this._flushEnqueuedRoomData(loadingRoomId);
        break;
      case 'join-room-error':
        const errorRoomId = msg['room-id'];
        const errorRoom = this._rooms[errorRoomId];
        if (errorRoom) {
          errorRoom.error = msg['error'];
        }
        this._notifyPresenceSubs(errorRoomId);
        break;
      case 'error':
        this._handleReceiveError(msg);
        break;
      default:
        break;
    }
  }

  /**
   * @param {'timeout' | 'error'} status
   * @param {string} eventId
   * @param {{message?: string, hint?: string, error?: Error}} errDetails
   */
  _handleMutationError(status, eventId, errDetails) {
    const mut = this.pendingMutations.currentValue.get(eventId);

    if (mut && (status !== 'timeout' || !mut['tx-id'])) {
      this.pendingMutations.set((prev) => {
        prev.delete(eventId);
        return prev;
      });
      this.notifyAll();
      this.notifyAttrsSubs();
      this.notifyMutationErrorSubs(errDetails);
      this._finishTransaction(status, eventId, errDetails);
    }
  }

  _handleReceiveError(msg) {
    const eventId = msg['client-event-id'];
    const prevMutation = this.pendingMutations.currentValue.get(eventId);
    const errorMessage = {
      message: msg.message || 'Uh-oh, something went wrong. Ping Joe & Stopa.',
    };

    if (msg.hint) {
      errorMessage.hint = msg.hint;
    }

    if (prevMutation) {
      // This must be a transaction error
      const errDetails = {
        message: msg.message,
        hint: msg.hint,
      };
      this._handleMutationError('error', eventId, errDetails);
      return;
    }

    if (
      msg['original-event']?.hasOwnProperty('q') &&
      msg['original-event']?.op === 'add-query'
    ) {
      const q = msg['original-event']?.q;
      const hash = weakHash(q);
      this.notifyQueryError(weakHash(q), errorMessage);
      this.notifyQueryOnceError(q, hash, eventId, errorMessage);
      return;
    }

    const isInitError = msg['original-event']?.op === 'init';
    if (isInitError) {
      if (
        msg.type === 'record-not-found' &&
        msg.hint?.['record-type'] === 'app-user'
      ) {
        // User has been logged out
        this.changeCurrentUser(null);
        return;
      }

      // We failed to init

      this._setStatus(STATUS.ERRORED, errorMessage);
      this.notifyAll();
      return;
    }
    // We've caught some error which has no corresponding listener.
    // Let's console.error to let the user know.
    const errorObj = { ...msg };
    delete errorObj.message;
    delete errorObj.hint;
    console.error(msg.message, errorObj);
    if (msg.hint) {
      console.error(
        'This error comes with some debugging information. Here it is: \n',
        msg.hint,
      );
    }
  }

  notifyQueryOnceError(q, hash, eventId, e) {
    const r = this.queryOnceDfds[hash]?.find((r) => r.eventId === eventId);
    if (!r) return;
    r.dfd.reject(e);
    this._completeQueryOnce(q, hash, r.dfd);
  }

  _setAttrs(attrs) {
    this.attrs = attrs.reduce((acc, attr) => {
      acc[attr.id] = attr;
      return acc;
    }, {});

    this.notifyAttrsSubs();
  }

  // ---------------------------
  // Queries

  getPreviousResult = (q) => {
    const hash = weakHash(q);
    return this.dataForQuery(hash);
  };

  _startQuerySub(q, hash) {
    const eventId = uuid();
    this.querySubs.set((prev) => {
      prev[hash] = prev[hash] || { q, result: null, eventId };
      return prev;
    });
    this._trySendAuthed(eventId, { op: 'add-query', q });

    return eventId;
  }

  /**
   *  When a user subscribes to a query the following side effects occur:
   *
   *  - We update querySubs to include the new query
   *  - We update queryCbs to include the new cb
   *  - If we already have a result for the query we call cb immediately
   *  - We send the server an `add-query` message
   *
   *  Returns an unsubscribe function
   */
  subscribeQuery(q, cb) {
    const hash = weakHash(q);

    const prevResult = this.getPreviousResult(q);
    if (prevResult) {
      cb(prevResult);
    }

    this.queryCbs[hash] = this.queryCbs[hash] ?? [];
    this.queryCbs[hash].push({ q, cb });

    this._startQuerySub(q, hash);

    return () => {
      this._unsubQuery(q, hash, cb);
    };
  }

  queryOnce(q) {
    const dfd = new Deferred();

    if (!this._isOnline) {
      dfd.reject(
        new Error("We can't run `queryOnce`, because the device is offline."),
      );
      return dfd.promise;
    }

    if (!this.querySubs) {
      dfd.reject(
        new Error(
          "We can't run `queryOnce` on the backend. Use adminAPI.query instead: https://www.instantdb.com/docs/backend#query",
        ),
      );
      return dfd.promise;
    }

    const hash = weakHash(q);

    const eventId = this._startQuerySub(q, hash);

    this.queryOnceDfds[hash] = this.queryOnceDfds[hash] ?? [];
    this.queryOnceDfds[hash].push({ q, dfd, eventId });

    setTimeout(
      () => dfd.reject(new Error('Query timed out')),
      QUERY_ONCE_TIMEOUT,
    );

    return dfd.promise;
  }

  _completeQueryOnce(q, hash, dfd) {
    if (!this.queryOnceDfds[hash]) return;

    this.queryOnceDfds[hash] = this.queryOnceDfds[hash].filter(
      (r) => r.dfd !== dfd,
    );

    this._cleanupQuery(q, hash);
  }

  _unsubQuery(q, hash, cb) {
    if (!this.queryCbs[hash]) return;

    this.queryCbs[hash] = this.queryCbs[hash].filter((r) => r.cb !== cb);

    this._cleanupQuery(q, hash);
  }

  _cleanupQuery(q, hash) {
    const hasListeners =
      this.queryCbs[hash]?.length || this.queryOnceDfds[hash]?.length;

    if (hasListeners) return;

    delete this.queryCbs[hash];
    delete this.queryOnceDfds[hash];

    this._trySendAuthed(uuid(), { op: 'remove-query', q });
  }

  // When we `pushTx`, it's possible that we don't yet have `this.attrs`
  // This means that `tx-steps` in `pendingMutations` will include `add-attr`
  // commands for attrs that already exist.
  //
  // This will also affect `add-triple` and `retract-triple` which
  // reference attr-ids that do not match the server.
  //
  // We fix this by rewriting `tx-steps` in each `pendingMutation`.
  // We remove `add-attr` commands for attrs that already exist.
  // We update `add-triple` and `retract-triple` commands to use the
  // server attr-ids.
  _rewriteMutations(attrs, muts) {
    if (!attrs) return muts;
    const findExistingAttr = (attr) => {
      const [_, etype, label] = attr['forward-identity'];
      const existing = instaml.getAttrByFwdIdentName(attrs, etype, label);
      return existing;
    };
    const findReverseAttr = (attr) => {
      const [_, etype, label] = attr['forward-identity'];
      const revAttr = instaml.getAttrByReverseIdentName(attrs, etype, label);
      return revAttr;
    };
    const mapping = { attrIdMap: {}, refSwapAttrIds: new Set() };
    const rewriteTxSteps = (txSteps) => {
      const retTxSteps = [];
      for (const txStep of txSteps) {
        const [action] = txStep;

        // Handles add-attr
        // If existing, we drop it, and track it
        // to update add/retract triples
        if (action === 'add-attr') {
          const [_action, attr] = txStep;
          const existing = findExistingAttr(attr);
          if (existing) {
            mapping.attrIdMap[attr.id] = existing.id;
            continue;
          }
          if (attr['value-type'] === 'ref') {
            const revAttr = findReverseAttr(attr);
            if (revAttr) {
              mapping.attrIdMap[attr.id] = revAttr.id;
              mapping.refSwapAttrIds.add(attr.id);
              continue;
            }
          }
        }

        // Handles add-triple|retract-triple
        // If in mapping, we update the attr-id
        const newTxStep = instaml.rewriteStep(mapping, txStep);

        retTxSteps.push(newTxStep);
      }
      return retTxSteps;
    };
    const rewritten = new Map();
    for (const [k, mut] of muts.entries()) {
      rewritten.set(k, { ...mut, 'tx-steps': rewriteTxSteps(mut['tx-steps']) });
    }
    return rewritten;
  }

  // ---------------------------
  // Transact

  optimisticAttrs() {
    const pendingMutationSteps = [
      ...this.pendingMutations.currentValue.values(),
    ] // hack due to Map()
      .flatMap((x) => x['tx-steps']);

    const deletedAttrIds = new Set(
      pendingMutationSteps
        .filter(([action, _attr]) => action === 'delete-attr')
        .map(([_action, id]) => id),
    );

    const pendingAttrs = [];
    for (const [_action, attr] of pendingMutationSteps) {
      if (_action === 'add-attr') {
        pendingAttrs.push(attr);
      } else if (
        _action === 'update-attr' &&
        attr.id &&
        this.attrs?.[attr.id]
      ) {
        const fullAttr = { ...this.attrs[attr.id], ...attr };
        pendingAttrs.push(fullAttr);
      }
    }

    const attrsWithoutDeleted = [
      ...Object.values(this.attrs || {}),
      ...pendingAttrs,
    ].filter((a) => !deletedAttrIds.has(a.id));

    const attrsRecord = Object.fromEntries(
      attrsWithoutDeleted.map((a) => [a.id, a]),
    );

    return attrsRecord;
  }

  /** Runs instaql on a query and a store */
  dataForQuery(hash) {
    const errorMessage = this._errorMessage;
    if (errorMessage) {
      return { error: errorMessage };
    }
    if (!this.querySubs) return;
    if (!this.pendingMutations) return;
    const querySubVersion = this.querySubs.version();
    const querySubs = this.querySubs.currentValue;
    const pendingMutationsVersion = this.pendingMutations.version();
    const pendingMutations = this.pendingMutations.currentValue;

    const { q, result } = querySubs[hash] || {};
    if (!result) return;

    const cached = this._dataForQueryCache[hash];
    if (
      cached &&
      querySubVersion === cached.querySubVersion &&
      pendingMutationsVersion === cached.pendingMutationsVersion
    ) {
      return cached.data;
    }

    const { store, pageInfo, aggregate } = result;
    const muts = this._rewriteMutations(store.attrs, pendingMutations);

    const txSteps = [...muts.values()].flatMap((x) => x['tx-steps']);
    const newStore = s.transact(store, txSteps);
    const resp = instaql({ store: newStore, pageInfo, aggregate }, q);

    this._dataForQueryCache[hash] = {
      querySubVersion,
      pendingMutationsVersion,
      data: resp,
    };

    return resp;
  }

  /** Re-run instaql and call all callbacks with new data */
  notifyOne = (hash) => {
    const cbs = this.queryCbs[hash] ?? [];
    const prevData = this._dataForQueryCache[hash]?.data;
    const data = this.dataForQuery(hash);

    if (!data) return;
    if (areObjectsDeepEqual(data, prevData)) return;

    cbs.forEach((r) => r.cb(data));
  };

  notifyOneQueryOnce = (hash) => {
    const dfds = this.queryOnceDfds[hash] ?? [];
    const data = this.dataForQuery(hash);

    dfds.forEach((r) => {
      this._completeQueryOnce(r.q, hash, r.dfd);
      r.dfd.resolve(data);
    });
  };

  notifyQueryError = (hash, error) => {
    const cbs = this.queryCbs[hash] || [];
    cbs.forEach((r) => r.cb({ error }));
  };

  /** Re-compute all subscriptions */
  notifyAll() {
    Object.keys(this.queryCbs).forEach((hash) => {
      this.notifyOne(hash);
    });
  }

  loadedNotifyAll() {
    if (this.pendingMutations.isLoading() || this.querySubs.isLoading()) return;
    this.notifyAll();
  }

  /** Applies transactions locally and sends transact message to server */
  pushTx = (chunks) => {
    try {
      const txSteps = instaml.transform(
        { attrs: this.optimisticAttrs(), schema: this.config.schema },
        chunks,
      );
      return this.pushOps(txSteps);
    } catch (e) {
      return this.pushOps([], e);
    }
  };

  /**
   * @param {*} txSteps
   * @param {*} [error]
   * @returns
   */
  pushOps = (txSteps, error) => {
    const eventId = uuid();
    const mutation = {
      op: 'transact',
      'tx-steps': txSteps,
      error,
    };
    this.pendingMutations.set((prev) => {
      prev.set(eventId, mutation);
      return prev;
    });

    const dfd = new Deferred();
    this.mutationDeferredStore.set(eventId, dfd);
    this._sendMutation(eventId, mutation);

    this.notifyAll();

    return dfd.promise;
  };

  shutdown() {
    this._isShutdown = true;
    this._ws?.close();
  }

  /**
   * Sends mutation to server and schedules a timeout to cancel it if
   * we don't hear back in time.
   * Note: If we're offline we don't schedule a timeout, we'll schedule it
   * later once we're back online and send the mutation again
   *
   */
  _sendMutation(eventId, mutation) {
    if (mutation.error) {
      this._handleMutationError('error', eventId, {
        error: mutation.error,
        message: mutation.error.message,
      });
      return;
    }
    if (this.status !== STATUS.AUTHENTICATED) {
      this._finishTransaction('enqueued', eventId);
      return;
    }
    const timeoutMs = Math.max(
      5000,
      this.pendingMutations.currentValue.size * 5000,
    );

    if (!this._isOnline) {
      this._finishTransaction('enqueued', eventId);
    } else {
      this._trySend(eventId, mutation);

      // If a transaction is pending for over 3 seconds,
      // we want to unblock the UX, so mark it as pending
      // and keep trying to process the transaction in the background
      setTimeout(() => {
        this._finishTransaction('pending', eventId);
      }, 3_000);

      setTimeout(() => {
        if (!this._isOnline) {
          return;
        }
        // If we are here, this means that we have sent this mutation, we are online
        // but we have not received a response. If it's this long, something must be wrong,
        // so we error with a timeout.
        this._handleMutationError('timeout', eventId, {
          message: 'transaction timed out',
        });
      }, timeoutMs);
    }
  }

  // ---------------------------
  // Websocket

  /** Send messages we accumulated while we were connecting */
  _flushPendingMessages() {
    const subs = Object.keys(this.queryCbs).map((hash) => {
      return this.querySubs.currentValue[hash];
    });
    // Note: we should not have any nulls in subs, but we're
    // doing this defensively just in case.
    const safeSubs = subs.filter((x) => x);
    safeSubs.forEach(({ eventId, q }) => {
      this._trySendAuthed(eventId, { op: 'add-query', q });
    });

    Object.values(this.queryOnceDfds)
      .flat()
      .forEach(({ eventId, q }) => {
        this._trySendAuthed(eventId, { op: 'add-query', q });
      });

    const muts = this._rewriteMutations(
      this.attrs,
      this.pendingMutations.currentValue,
    );
    muts.forEach((mut, eventId) => {
      if (!mut['tx-id']) {
        this._sendMutation(eventId, mut);
      }
    });
  }

  _trySendAuthed(...args) {
    if (this.status !== STATUS.AUTHENTICATED) {
      return;
    }
    this._trySend(...args);
  }

  _trySend(eventId, msg, opts) {
    if (this._ws.readyState !== WS_OPEN_STATUS) {
      return;
    }
    if (!ignoreLogging[msg.op]) {
      log.info('[send]', this._ws._id, msg.op, msg);
    }
    this._ws.send(JSON.stringify({ 'client-event-id': eventId, ...msg }));
  }

  _wsOnOpen = (e) => {
    const targetWs = e.target;
    if (this._ws !== targetWs) {
      log.info(
        '[socket][open]',
        targetWs._id,
        'skip; this is no longer the current ws',
      );
      return;
    }
    log.info('[socket][open]', this._ws._id);
    this._setStatus(STATUS.OPENED);
    this.getCurrentUser().then((resp) => {
      this._trySend(uuid(), {
        op: 'init',
        'app-id': this.config.appId,
        'refresh-token': resp.user?.['refresh_token'],
        versions: this.versions,
        // If an admin token is provided for an app, we will
        // skip all permission checks. This is an advanced feature,
        // to let users write internal tools
        // This option is not exposed in `Config`, as it's
        // not ready for prime time
        '__admin-token': this.config.__adminToken,
      });
    });
  };

  _wsOnMessage = (e) => {
    const targetWs = e.target;
    const m = JSON.parse(e.data.toString());
    if (this._ws !== targetWs) {
      log.info(
        '[socket][message]',
        targetWs._id,
        m,
        'skip; this is no longer the current ws',
      );
      return;
    }
    this._handleReceive(targetWs._id, JSON.parse(e.data.toString()));
  };

  _wsOnError = (e) => {
    const targetWs = e.target;
    if (this._ws !== targetWs) {
      log.info(
        '[socket][error]',
        targetWs._id,
        'skip; this is no longer the current ws',
      );
      return;
    }
    log.error('[socket][error]', targetWs._id, e);
  };

  _wsOnClose = (e) => {
    const targetWs = e.target;
    if (this._ws !== targetWs) {
      log.info(
        '[socket][close]',
        targetWs._id,
        'skip; this is no longer the current ws',
      );
      return;
    }

    this._setStatus(STATUS.CLOSED);

    for (const room of Object.values(this._rooms)) {
      room.isConnected = false;
    }

    if (this._isShutdown) {
      log.info(
        '[socket][close]',
        targetWs._id,
        'Reactor has been shut down and will not reconnect',
      );
      return;
    }
    log.info(
      '[socket][close]',
      targetWs._id,
      'schedule reconnect, ms =',
      this._reconnectTimeoutMs,
    );
    setTimeout(() => {
      this._reconnectTimeoutMs = Math.min(
        this._reconnectTimeoutMs + 1000,
        10000,
      );
      if (!this._isOnline) {
        log.info(
          '[socket][close]',
          targetWs._id,
          'we are offline, no need to start socket',
        );
        return;
      }
      this._startSocket();
    }, this._reconnectTimeoutMs);
  };

  _startSocket() {
    if (this._ws && this._ws.readyState == WS_CONNECTING_STATUS) {
      // Our current websocket is in a 'connecting' state.
      // There's no need to start another one, as the socket is
      // effectively fresh.
      log.info(
        '[socket][start]',
        this._ws._id,
        'maintained as current ws, we were still in a connecting state',
      );
      return;
    }
    const prevWs = this._ws;
    this._ws = createWebSocket(
      `${this.config.websocketURI}?app_id=${this.config.appId}`,
    );
    this._ws.onopen = this._wsOnOpen;
    this._ws.onmessage = this._wsOnMessage;
    this._ws.onclose = this._wsOnClose;
    this._ws.onerror = this._wsOnError;
    log.info('[socket][start]', this._ws._id);
    if (prevWs?.readyState === WS_OPEN_STATUS) {
      // When the network dies, it doesn't always mean that our
      // socket connection will fire a close event.
      //
      // We _could_ re-use the old socket, if the network drop was a
      // few seconds. But, to be safe right now we always create a new socket.
      //
      // This means that we have to make sure to kill the previous one ourselves.
      // c.f https://issues.chromium.org/issues/41343684
      log.info(
        '[socket][start]',
        this._ws._id,
        'close previous ws id = ',
        prevWs._id,
      );
      prevWs.close();
    }
  }

  /**
   * Given a key, returns a stable local id, unique to this device and app.
   *
   * This can be useful if you want to create guest ids for example.
   *
   * Note: If the user deletes their local storage, this id will change.
   *
   * We use this._localIdPromises to ensure that we only generate a local
   * id once, even if multiple callers call this function concurrently.
   */
  async getLocalId(name) {
    const k = `localToken_${name}`;
    const id = await this._persister.getItem(k);
    if (id) return id;
    if (this._localIdPromises[k]) {
      return this._localIdPromises[k];
    }
    const newId = uuid();
    this._localIdPromises[k] = this._persister
      .setItem(k, newId)
      .then(() => newId);
    return this._localIdPromises[k];
  }

  // ----
  // Auth
  _replaceUrlAfterOAuth() {
    if (typeof URL === 'undefined') {
      return;
    }
    const url = new URL(window.location.href);
    if (url.searchParams.get(OAUTH_REDIRECT_PARAM)) {
      const startUrl = url.toString();
      url.searchParams.delete(OAUTH_REDIRECT_PARAM);
      url.searchParams.delete('code');
      url.searchParams.delete('error');
      const newPath =
        url.pathname +
        (url.searchParams.size ? '?' + url.searchParams : '') +
        url.hash;
      // Note: In next.js, this will revert to the old state if user navigates
      //       back. We would need to allow framework specific routing to work
      //       around that problem.
      history.replaceState(history.state, '', newPath);

      // navigation is part of the HTML spec, but not supported by Safari
      // or Firefox yet:
      // https://developer.mozilla.org/en-US/docs/Web/API/Navigation_API#browser_compatibility
      if (
        // @ts-ignore (waiting for ts support)
        typeof navigation === 'object' &&
        // @ts-ignore (waiting for ts support)
        typeof navigation.addEventListener === 'function' &&
        // @ts-ignore (waiting for ts support)
        typeof navigation.removeEventListener === 'function'
      ) {
        let ran = false;

        // The next.js app router will reset the URL when the router loads.
        // This puts it back after the router loads.
        const listener = (e) => {
          if (!ran) {
            ran = true;
            // @ts-ignore (waiting for ts support)
            navigation.removeEventListener('navigate', listener);
            if (
              !e.userInitiated &&
              e.navigationType === 'replace' &&
              e.destination?.url === startUrl
            ) {
              history.replaceState(history.state, '', newPath);
            }
          }
        };
        // @ts-ignore (waiting for ts support)
        navigation.addEventListener('navigate', listener);
      }
    }
  }

  /**
   *
   * @returns Promise<null | {error: {message: string}}>
   */
  async _oauthLoginInit() {
    if (
      typeof window === 'undefined' ||
      typeof window.location === 'undefined' ||
      typeof URLSearchParams === 'undefined'
    ) {
      return null;
    }
    const params = new URLSearchParams(window.location.search);
    if (!params.get(OAUTH_REDIRECT_PARAM)) {
      return null;
    }

    const error = params.get('error');
    if (error) {
      this._replaceUrlAfterOAuth();
      return { error: { message: error } };
    }
    const code = params.get('code');
    if (!code) {
      return null;
    }
    this._replaceUrlAfterOAuth();
    try {
      const { user } = await authAPI.exchangeCodeForToken({
        apiURI: this.config.apiURI,
        appId: this.config.appId,
        code,
      });
      this.setCurrentUser(user);
      return null;
    } catch (e) {
      if (
        e?.body?.type === 'record-not-found' &&
        e?.body?.hint?.['record-type'] === 'app-oauth-code' &&
        (await this._hasCurrentUser())
      ) {
        // We probably just weren't able to clean up the URL, so
        // let's just ignore this error
        return null;
      }
      const message = e?.body?.message || 'Error logging in.';
      return { error: { message } };
    }
  }

  async _waitForOAuthCallbackResponse() {
    return await this._oauthCallbackResponse;
  }

  __subscribeMutationErrors(cb) {
    this.mutationErrorCbs.push(cb);

    return () => {
      this.mutationErrorCbs = this.mutationErrorCbs.filter((x) => x !== cb);
    };
  }

  subscribeAuth(cb) {
    this.authCbs.push(cb);
    const currUserCached = this._currentUserCached;
    if (!currUserCached.isLoading) {
      cb(this._currentUserCached);
    }
    let unsubbed = false;
    this.getCurrentUser().then((resp) => {
      if (unsubbed) return;
      if (areObjectsDeepEqual(resp, currUserCached)) return;
      cb(resp);
    });
    return () => {
      unsubbed = true;
      this.authCbs = this.authCbs.filter((x) => x !== cb);
    };
  }

  async getAuth() {
    const { user, error } = await this.getCurrentUser();
    if (error) {
      throw error;
    }
    return user;
  }

  subscribeConnectionStatus(cb) {
    this.connectionStatusCbs.push(cb);

    return () => {
      this.connectionStatusCbs = this.connectionStatusCbs.filter(
        (x) => x !== cb,
      );
    };
  }

  subscribeAttrs(cb) {
    this.attrsCbs.push(cb);

    if (this.attrs) {
      cb(this.attrs);
    }

    return () => {
      this.attrsCbs = this.attrsCbs.filter((x) => x !== cb);
    };
  }

  notifyAuthSubs(user) {
    this.authCbs.forEach((cb) => cb(user));
  }

  notifyMutationErrorSubs(error) {
    this.mutationErrorCbs.forEach((cb) => cb(error));
  }

  notifyAttrsSubs() {
    if (!this.attrs) return;
    const oas = this.optimisticAttrs();
    this.attrsCbs.forEach((cb) => cb(oas));
  }

  notifyConnectionStatusSubs(status) {
    this.connectionStatusCbs.forEach((cb) => cb(status));
  }

  async setCurrentUser(user) {
    await this._persister.setItem(currentUserKey, JSON.stringify(user));
  }

  getCurrentUserCached() {
    return this._currentUserCached;
  }

  async getCurrentUser() {
    const oauthResp = await this._waitForOAuthCallbackResponse();
    if (oauthResp?.error) {
      const errorV = { error: oauthResp.error, user: undefined };
      this._currentUserCached = { isLoading: false, ...errorV };
      return errorV;
    }
    const user = await this._persister.getItem(currentUserKey);
    const userV = { user: JSON.parse(user), error: undefined };
    this._currentUserCached = {
      isLoading: false,
      ...userV,
    };
    return userV;
  }

  async _hasCurrentUser() {
    const user = await this._persister.getItem(currentUserKey);
    return JSON.parse(user) != null;
  }

  async changeCurrentUser(newUser) {
    const { user: oldUser } = await this.getCurrentUser();
    if (areObjectsDeepEqual(oldUser, newUser)) {
      // We were already logged in as the newUser, don't
      // bother updating
      return;
    }
    await this.setCurrentUser(newUser);
    // We need to remove all `result` from querySubs,
    // as they are no longer valid for the new user
    this.updateUser(newUser);

    try {
      this._broadcastChannel?.postMessage({ type: 'auth' });
    } catch (error) {
      console.error('Error posting message to broadcast channel', error);
    }
  }

  updateUser(newUser) {
    const newV = { error: undefined, user: newUser };
    this._currentUserCached = { isLoading: false, ...newV };
    this._dataForQueryCache = {};
    this.querySubs.set((prev) => {
      Object.keys(prev).forEach((k) => {
        delete prev[k].result;
      });
      return prev;
    });
    this._reconnectTimeoutMs = 0;
    this._ws.close();
    this._oauthCallbackResponse = null;
    this.notifyAuthSubs(newV);
  }

  sendMagicCode({ email }) {
    return authAPI.sendMagicCode({
      apiURI: this.config.apiURI,
      appId: this.config.appId,
      email: email,
    });
  }

  async signInWithMagicCode({ email, code }) {
    const res = await authAPI.verifyMagicCode({
      apiURI: this.config.apiURI,
      appId: this.config.appId,
      email,
      code,
    });
    await this.changeCurrentUser(res.user);
    return res;
  }

  async signInWithCustomToken(authToken) {
    const res = await authAPI.verifyRefreshToken({
      apiURI: this.config.apiURI,
      appId: this.config.appId,
      refreshToken: authToken,
    });
    await this.changeCurrentUser(res.user);
    return res;
  }

  async signOut() {
    const currentUser = await this.getCurrentUser();
    const refreshToken = currentUser?.user?.refresh_token;
    if (refreshToken) {
      try {
        await authAPI.signOut({
          apiURI: this.config.apiURI,
          appId: this.config.appId,
          refreshToken,
        });
      } catch (e) {}
    }
    await this.changeCurrentUser(null);
  }

  /**
   * Creates an OAuth authorization URL.
   * @param {Object} params - The parameters to create the authorization URL.
   * @param {string} params.clientName - The name of the client requesting authorization.
   * @param {string} params.redirectURL - The URL to redirect users to after authorization.
   * @returns {string} The created authorization URL.
   */
  createAuthorizationURL({ clientName, redirectURL }) {
    const { apiURI, appId } = this.config;
    return `${apiURI}/runtime/oauth/start?app_id=${appId}&client_name=${clientName}&redirect_uri=${redirectURL}`;
  }

  /**
   * @param {Object} params
   * @param {string} params.code - The code received from the OAuth service.
   * @param {string} [params.codeVerifier] - The code verifier used to generate the code challenge.
   */
  async exchangeCodeForToken({ code, codeVerifier }) {
    const res = await authAPI.exchangeCodeForToken({
      apiURI: this.config.apiURI,
      appId: this.config.appId,
      code: code,
      codeVerifier,
    });
    await this.changeCurrentUser(res.user);
    return res;
  }

  issuerURI() {
    const { apiURI, appId } = this.config;
    return `${apiURI}/runtime/${appId}`;
  }

  /**
   * @param {Object} params
   * @param {string} params.clientName - The name of the client requesting authorization.
   * @param {string} params.idToken - The id_token from the external service
   * @param {string | null | undefined} [params.nonce] - The nonce used when requesting the id_token from the external service
   */
  async signInWithIdToken({ idToken, clientName, nonce }) {
    const currentUser = await this.getCurrentUser();
    const refreshToken = currentUser?.user?.refresh_token;

    const res = await authAPI.signInWithIdToken({
      apiURI: this.config.apiURI,
      appId: this.config.appId,
      idToken,
      clientName,
      nonce,
      refreshToken,
    });
    await this.changeCurrentUser(res.user);
    return res;
  }

  // --------
  // Rooms

  joinRoom(roomId) {
    if (!this._rooms[roomId]) {
      this._rooms[roomId] = {
        isConnected: false,
        error: undefined,
      };
    }

    this._presence[roomId] = this._presence[roomId] || {};

    this._tryJoinRoom(roomId);

    return () => {
      this._cleanupRoom(roomId);
    };
  }

  _cleanupRoom(roomId) {
    if (
      !this._presence[roomId]?.handlers?.length &&
      !Object.keys(this._broadcastSubs[roomId] ?? {}).length
    ) {
      const isConnected = this._rooms[roomId]?.isConnected;

      delete this._rooms[roomId];
      delete this._presence[roomId];
      delete this._broadcastSubs[roomId];

      if (isConnected) {
        this._tryLeaveRoom(roomId);
      } else {
        this._roomsPendingLeave[roomId] = true;
      }
    }
  }

  // --------
  // Presence

  // TODO: look into typing again
  getPresence(roomType, roomId, opts = {}) {
    const room = this._rooms[roomId];
    const presence = this._presence[roomId];
    if (!room || !presence || !presence.result) return null;

    return {
      ...buildPresenceSlice(presence.result, opts, this._sessionId),
      isLoading: !room.isConnected,
      error: room.error,
    };
  }

  // TODO: look into typing again
  publishPresence(roomType, roomId, partialData) {
    const room = this._rooms[roomId];
    const presence = this._presence[roomId];

    if (!room || !presence) {
      return;
    }

    presence.result = presence.result || {};
    const data = {
      ...presence.result.user,
      ...partialData,
    };

    presence.result.user = data;

    if (!room.isConnected) {
      return;
    }

    this._trySetPresence(roomId, data);
    this._notifyPresenceSubs(roomId);
  }

  _trySetPresence(roomId, data) {
    this._trySendAuthed(uuid(), {
      op: 'set-presence',
      'room-id': roomId,
      data,
    });
  }

  _tryJoinRoom(roomId) {
    this._trySendAuthed(uuid(), { op: 'join-room', 'room-id': roomId });
    delete this._roomsPendingLeave[roomId];
  }

  _tryLeaveRoom(roomId) {
    this._trySendAuthed(uuid(), { op: 'leave-room', 'room-id': roomId });
  }

  // TODO: look into typing again
  subscribePresence(roomType, roomId, opts, cb) {
    const leaveRoom = this.joinRoom(roomId);

    const handler = { ...opts, roomId, cb, prev: null };

    this._presence[roomId] = this._presence[roomId] || {};
    this._presence[roomId].handlers = this._presence[roomId].handlers || [];
    this._presence[roomId].handlers.push(handler);

    this._notifyPresenceSub(roomId, handler);

    return () => {
      this._presence[roomId].handlers =
        this._presence[roomId]?.handlers?.filter((x) => x !== handler) ?? [];

      leaveRoom();
    };
  }

  _notifyPresenceSubs(roomId) {
    this._presence[roomId]?.handlers?.forEach((handler) => {
      this._notifyPresenceSub(roomId, handler);
    });
  }

  _notifyPresenceSub(roomId, handler) {
    const slice = this.getPresence('', roomId, handler);

    if (!slice) {
      return;
    }

    if (handler.prev && !hasPresenceResponseChanged(slice, handler.prev)) {
      return;
    }

    handler.prev = slice;
    handler.cb(slice);
  }

  _patchPresencePeers(roomId, edits) {
    const peers = this._presence[roomId]?.result?.peers || {};
    let sessions = Object.fromEntries(
      Object.entries(peers).map(([k, v]) => [k, { data: v }]),
    );
    sessions[this._sessionId] = { data: this._presence[roomId]?.result?.user };
    for (let [path, op, value] of edits) {
      if (op === '+' || op === 'r') {
        sessions = assocIn(sessions, path, value);
      }
      if (op === '-') {
        sessions = dissocIn(sessions, path);
      }
    }

    this._setPresencePeers(roomId, sessions);
  }

  _setPresencePeers(roomId, data) {
    const sessions = { ...data };
    // no need to keep track of `user`
    delete sessions[this._sessionId];
    const peers = Object.fromEntries(
      Object.entries(sessions).map(([k, v]) => [k, v.data]),
    );

    this._presence = assocIn(
      this._presence,
      [roomId, 'result', 'peers'],
      peers,
    );
  }

  // --------
  // Broadcast

  publishTopic({ roomType, roomId, topic, data }) {
    const room = this._rooms[roomId];

    if (!room) {
      return;
    }

    if (!room.isConnected) {
      this._broadcastQueue[roomId] = this._broadcastQueue[roomId] ?? [];
      this._broadcastQueue[roomId].push({ topic, roomType, data });

      return;
    }

    this._tryBroadcast(roomId, roomType, topic, data);
  }

  _tryBroadcast(roomId, roomType, topic, data) {
    this._trySendAuthed(uuid(), {
      op: 'client-broadcast',
      'room-id': roomId,
      roomType,
      topic,
      data,
    });
  }

  subscribeTopic(roomId, topic, cb) {
    const leaveRoom = this.joinRoom(roomId);

    this._broadcastSubs[roomId] = this._broadcastSubs[roomId] || {};
    this._broadcastSubs[roomId][topic] =
      this._broadcastSubs[roomId][topic] || [];
    this._broadcastSubs[roomId][topic].push(cb);
    this._presence[roomId] = this._presence[roomId] || {};

    return () => {
      this._broadcastSubs[roomId][topic] = this._broadcastSubs[roomId][
        topic
      ].filter((x) => x !== cb);

      if (!this._broadcastSubs[roomId][topic].length) {
        delete this._broadcastSubs[roomId][topic];
      }

      leaveRoom();
    };
  }

  _notifyBroadcastSubs(room, topic, msg) {
    this._broadcastSubs?.[room]?.[topic]?.forEach((cb) => {
      const data = msg.data?.data;

      const peer =
        msg.data['peer-id'] === this._sessionId
          ? this._presence[room]?.result?.user
          : this._presence[room]?.result?.peers?.[msg.data['peer-id']];

      return cb(data, peer);
    });
  }

  // --------
  // Storage

  async uploadFile(path, file, opts) {
    const currentUser = await this.getCurrentUser();
    const refreshToken = currentUser?.user?.refresh_token;
    return StorageApi.uploadFile({
      ...opts,
      apiURI: this.config.apiURI,
      appId: this.config.appId,
      path: path,
      file,
      refreshToken: refreshToken,
    });
  }

  async deleteFile(path) {
    const currentUser = await this.getCurrentUser();
    const refreshToken = currentUser?.user?.refresh_token;
    const result = await StorageApi.deleteFile({
      apiURI: this.config.apiURI,
      appId: this.config.appId,
      path,
      refreshToken: refreshToken,
    });

    return result;
  }

  // Deprecated Storage API (Jan 2025)
  // ---------------------------------

  async upload(path, file) {
    const currentUser = await this.getCurrentUser();
    const refreshToken = currentUser?.user?.refresh_token;
    const fileName = path || file.name;
    const url = await StorageApi.getSignedUploadUrl({
      apiURI: this.config.apiURI,
      appId: this.config.appId,
      fileName: fileName,
      refreshToken: refreshToken,
    });
    const isSuccess = await StorageApi.upload(url, file);

    return isSuccess;
  }

  async getDownloadUrl(path) {
    const currentUser = await this.getCurrentUser();
    const refreshToken = currentUser?.user?.refresh_token;
    const url = await StorageApi.getDownloadUrl({
      apiURI: this.config.apiURI,
      appId: this.config.appId,
      path: path,
      refreshToken: refreshToken,
    });

    return url;
  }
}
</file>

<file path="client/packages/core/src/sanityCheckQueries.ts">
// --------
// Sanity check tests

import type {
  Cursor,
  Exactly,
  InstantObject,
  Query,
  QueryResponse,
} from './queryTypes';

/**
 * The purpose of these sanity checks:
 * If we make changes and something breaks, our build will fail.
 *
 * AFAIK we _could_ write this in our `tests` folder.
 * The latest version of `vitest` does support `assertType`, but:
 *  * it's easy to get false positives if configured incorrectly
 *  * the api is more vebose than this
 */

export function dummyQuery<Q extends Query>(
  _query: Exactly<Query, Q>,
): QueryResponse<Q, unknown> {
  return 1 as any;
}

export interface ExUser {
  name: string;
}

export interface ExPost {
  title: string;
}

interface ExSchema {
  users: ExUser;
  posts: ExPost;
}

export function dummySchemaQuery<Q extends Query>(
  _query: Exactly<Query, Q>,
): QueryResponse<Q, ExSchema> {
  return 1 as any;
}

const sanityCheckQueries = () => {
  // -----------
  // Basic good inputs succeed
  const r = dummyQuery({ users: {} });

  // -----------
  // Basic bad inputs fails
  // @ts-expect-error
  const r2 = dummyQuery({ users: 1 });
  // @ts-expect-error
  const r3 = dummyQuery({ users: '' });

  // ----------------------
  // Good $ clauses succeed
  const r4 = dummyQuery({ users: { $: { where: { foo: 1 } } } });
  const r5 = dummyQuery({ users: { $: { where: { foo: 'str' } } } });
  const r6 = dummyQuery({ users: { $: { where: { foo: true } } } });
  const r7 = dummyQuery({ users: { $: { where: { 'foo.bar.baz': 1 } } } });
  const s1 = dummyQuery({
    users: { $: { where: { foo: { in: [1, 2, 3] } } } },
  });
  const s1_5 = dummyQuery({
    users: { $: { where: { foo: { $in: [1, 2, 3] } } } },
  });
  const t1 = dummyQuery({
    users: { $: { where: { or: [{ foo: 1 }] } } },
  });
  // You can have a field named or
  const t2 = dummyQuery({
    users: { $: { where: { or: 'fieldNamedOr' } } },
  });
  const t3 = dummyQuery({
    users: { $: { where: { and: [{ foo: 1 }] } } },
  });
  // You can have a field named and
  const t4 = dummyQuery({
    users: { $: { where: { and: 'fieldNamedAnd' } } },
  });
  const t5 = dummyQuery({
    users: { $: { where: { and: [{ or: [{ foo: 1 }] }] } } },
  });
  // Pagination
  const t6 = dummyQuery({
    users: { $: { limit: 10 } },
  });
  const t7 = dummyQuery({
    users: { $: { limit: 10, offset: 10 } },
  });
  const t8 = dummyQuery({
    users: { $: { where: { foo: 1 }, limit: 10, offset: 10 } },
  });
  const cursor: Cursor = [
    '61935703-bec6-4ade-ad9b-8bf382b92f69',
    '995f5a9b-9ae1-4e59-97d1-df33afb44aee',
    '61935703-bec6-4ade-ad9b-8bf382b92f69',
    10,
  ];
  const t9 = dummyQuery({
    users: {
      $: { where: { foo: 1 }, after: cursor },
    },
  });

  const t10 = dummyQuery({
    users: { $: { before: cursor } },
  });

  const t12 = dummyQuery({
    users: { $: { where: { val: { $isNull: true } } } },
  });

  const t13 = dummyQuery({
    users: { $: { where: { val: { $not: 'a' } } } },
  });

  // ------------------
  // Bad $ clauses fail
  // @ts-expect-error
  const r8 = dummyQuery({ users: { $: { where: 'foo' } } });
  // @ts-expect-error
  const r9 = dummyQuery({ users: { $: { where: { foo: {} } } } });
  // @ts-expect-error
  const r10 = dummyQuery({ users: { $: { where2: 1 } } });
  const s2 = dummyQuery({
    // @ts-expect-error
    users: { $: { where: { foo: { ini: [1, 2, 3] } } } },
  });
  const s3 = dummyQuery({
    // @ts-expect-error
    users: { $: { where: { foo: [] } } },
  });

  const s4 = dummyQuery({
    // @ts-expect-error
    users: { $: { where: { val: { $isNull: 'a' } } } },
  });

  const s5 = dummyQuery({
    // @ts-expect-error
    users: { $: { where: { val: { $not: { val: 'a' } } } } },
  });

  // ----------------
  // Good Nested queries succeed
  const r11 = dummyQuery({ users: { posts: {} } });
  const r12 = dummyQuery({ users: {}, posts: {} });
  const r13 = dummyQuery({
    users: {
      $: { where: { foo: 1 } },
      posts: { $: { where: { foo: 1 } } },
    },
  });

  // ----------
  // Bad nested queries fail
  // @ts-expect-error
  const r14 = dummyQuery({ users: { foo: 1 } });
};
const sanityCheckSchemalessResponses = () => {
  // Simple Response
  const r1: { users: InstantObject[] } = dummyQuery({ users: {} });
  // Nested Response
  const r2: { users: ({ posts: InstantObject[] } & InstantObject)[] } =
    dummyQuery({ users: { posts: {} } });
  // $ are ignored
  const r3: { users: ({ posts: InstantObject[] } & InstantObject)[] } =
    dummyQuery({
      users: {
        $: { where: { foo: 1 } },
        posts: {},
      },
    });
  // @ts-expect-error
  r3.$;
};
function sanityCheckSchemadResponses() {
  // simple response
  const r1: { users: ExUser[] } = dummySchemaQuery({ users: {} });
  // nested response
  const r2: { users: ({ posts: ExPost[] } & ExUser)[] } = dummySchemaQuery({
    users: { posts: {} },
  });
  // id included, but no other keys are allowed
  const r3 = dummySchemaQuery({ users: {} });
  const u = r3.users[0];
  const id: string = u.id;
  const name: string = u.name;
  // @ts-expect-error
  const title: string = u.title;
}
</file>

<file path="client/packages/core/src/schema.ts">
import {
  EntityDef,
  DataAttrDef,
  InstantSchemaDef,
  type EntitiesDef,
  type AttrsDefs,
  type EntitiesWithLinks,
  type LinksDef,
  type RoomsDef,
  type UnknownRooms,
} from './schemaTypes';

// ==========
// API

/**
 * @deprecated
 * `i.graph` is deprecated. Use `i.schema` instead.
 *
 * @example
 * // Before
 * i.graph(entities, links).withRoomSchema<RoomType>();
 *
 * // After
 * i.schema({ entities, links, rooms })
 *
 * @see
 * https://instantdb.com/docs/schema
 */
function graph<
  EntitiesWithoutLinks extends EntitiesDef,
  const Links extends LinksDef<EntitiesWithoutLinks>,
>(entities: EntitiesWithoutLinks, links: Links) {
  return new InstantSchemaDef(
    enrichEntitiesWithLinks<EntitiesWithoutLinks, Links>(entities, links),
    // (XXX): LinksDef<any> stems from TypeScript’s inability to reconcile the
    // type EntitiesWithLinks<EntitiesWithoutLinks, Links> with
    // EntitiesWithoutLinks. TypeScript is strict about ensuring that types are
    // correctly aligned and does not allow for substituting a type that might
    // be broader or have additional properties.
    links as LinksDef<any>,
    undefined as UnknownRooms,
  );
}

/**
 * Creates an entity definition, to be used in conjunction with `i.graph`.
 *
 * @see https://instantdb.com/docs/schema
 * @example
 *   {
 *     posts: i.entity({
 *       title: i.string(),
 *       body: i.string(),
 *     }),
 *     comments: i.entity({
 *       body: i.string(),
 *     })
 *   }
 */
function entity<Attrs extends AttrsDefs>(
  attrs: Attrs,
): EntityDef<Attrs, {}, void> {
  return new EntityDef(attrs, {});
}

function string<StringEnum extends string = string>(): DataAttrDef<
  StringEnum,
  true
> {
  return new DataAttrDef('string', true);
}

function number(): DataAttrDef<number, true> {
  return new DataAttrDef('number', true);
}

function boolean(): DataAttrDef<boolean, true> {
  return new DataAttrDef('boolean', true);
}

function date(): DataAttrDef<string | number, true> {
  return new DataAttrDef('date', true);
}

function json<T = any>(): DataAttrDef<T, true> {
  return new DataAttrDef('json', true);
}

function any(): DataAttrDef<any, true> {
  return new DataAttrDef('json', true);
}

// ==========
// internal

function enrichEntitiesWithLinks<
  EntitiesWithoutLinks extends EntitiesDef,
  Links extends LinksDef<any>,
  EnrichedEntities = EntitiesWithLinks<EntitiesWithoutLinks, Links>,
>(entities: EntitiesWithoutLinks, links: Links): EnrichedEntities {
  const linksIndex: LinksIndex = { fwd: {}, rev: {} };

  for (const linkDef of Object.values(links)) {
    linksIndex.fwd[linkDef.forward.on as string] ||= {};
    linksIndex.rev[linkDef.reverse.on as string] ||= {};

    linksIndex.fwd[linkDef.forward.on as string][linkDef.forward.label] = {
      entityName: linkDef.reverse.on as string,
      cardinality: linkDef.forward.has,
    };

    linksIndex.rev[linkDef.reverse.on as string][linkDef.reverse.label] = {
      entityName: linkDef.forward.on as string,
      cardinality: linkDef.reverse.has,
    };
  }

  const enrichedEntities = Object.fromEntries(
    Object.entries(entities).map(([name, def]) => [
      name,
      new EntityDef(def.attrs, {
        ...linksIndex.fwd[name],
        ...linksIndex.rev[name],
      }),
    ]),
  );

  return enrichedEntities as EnrichedEntities;
}

type LinksIndex = Record<
  'fwd' | 'rev',
  Record<string, Record<string, { entityName: string; cardinality: string }>>
>;

/**
 * Lets you define a schema for your database.
 *
 * You can define entities, links between entities, and if you use
 * presence, you can define rooms.
 *
 * You can push this schema to your database with the CLI,
 * or use it inside `init`, to get typesafety and autocompletion.
 *
 * @see https://instantdb.com/docs/schema
 * @example
 *   i.schema({
 *     entities: { },
 *     links: { },
 *     rooms: { }
 *   });
 */
function schema<
  EntitiesWithoutLinks extends EntitiesDef,
  const Links extends LinksDef<EntitiesWithoutLinks>,
  Rooms extends RoomsDef,
>({
  entities,
  links,
  rooms,
}: {
  entities: EntitiesWithoutLinks;
  links?: Links;
  rooms?: Rooms;
}) {
  const linksDef = links ?? ({} as Links);
  const roomsDef = rooms ?? ({} as Rooms);
  return new InstantSchemaDef(
    enrichEntitiesWithLinks<EntitiesWithoutLinks, Links>(entities, linksDef),
    // (XXX): LinksDef<any> stems from TypeScript’s inability to reconcile the
    // type EntitiesWithLinks<EntitiesWithoutLinks, Links> with
    // EntitiesWithoutLinks. TypeScript is strict about ensuring that types are
    // correctly aligned and does not allow for substituting a type that might
    // be broader or have additional properties.
    linksDef as LinksDef<any>,
    roomsDef,
  );
}

export const i = {
  // constructs
  graph,
  schema,
  entity,
  // value types
  string,
  number,
  boolean,
  date,
  json,
  any,
};
</file>

<file path="client/packages/core/src/schemaTypes.ts">
import type { RoomSchemaShape } from './presence';

export class DataAttrDef<ValueType, IsRequired extends boolean> {
  constructor(
    public valueType: ValueTypes,
    public required: IsRequired,
    public config: {
      indexed: boolean;
      unique: boolean;
      // clientValidator?: (value: ValueType) => boolean;
    } = { indexed: false, unique: false },
  ) {}

  optional() {
    return new DataAttrDef<ValueType, false>(this.valueType, false);
  }

  unique() {
    return new DataAttrDef<ValueType, IsRequired>(
      this.valueType,
      this.required,
      {
        ...this.config,
        unique: true,
      },
    );
  }

  indexed() {
    return new DataAttrDef<ValueType, IsRequired>(
      this.valueType,
      this.required,
      {
        ...this.config,
        indexed: true,
      },
    );
  }

  // clientValidate(clientValidator: (value: ValueType) => boolean) {
  //   return new DataAttrDef(this.valueType, this.required, {
  //     ...this.config,
  //     clientValidator,
  //   });
  // }
}

export class LinkAttrDef<
  Cardinality extends CardinalityKind,
  EntityName extends string,
> {
  constructor(
    public cardinality: Cardinality,
    public entityName: EntityName,
  ) {}
}

export interface IContainEntitiesAndLinks<
  Entities extends EntitiesDef,
  Links extends LinksDef<Entities>,
> {
  entities: Entities;
  links: Links;
}

// ==========
// base types

export type ValueTypes = 'string' | 'number' | 'boolean' | 'date' | 'json';

export type CardinalityKind = 'one' | 'many';

export type AttrsDefs = Record<string, DataAttrDef<any, any>>;

export class EntityDef<
  Attrs extends AttrsDefs,
  Links extends Record<string, LinkAttrDef<any, any>>,
  AsType,
> {
  constructor(
    public attrs: Attrs,
    public links: Links,
  ) {}

  asType<_AsType extends Partial<MappedAttrs<Attrs>>>() {
    return new EntityDef<Attrs, Links, _AsType>(this.attrs, this.links);
  }
}

export type EntitiesDef = Record<string, EntityDef<any, any, any>>;

export type LinksDef<Entities extends EntitiesDef> = Record<
  string,
  LinkDef<
    Entities,
    keyof Entities,
    string,
    CardinalityKind,
    keyof Entities,
    string,
    CardinalityKind
  >
>;

export type LinkDef<
  Entities extends EntitiesDef,
  FwdEntity extends keyof Entities,
  FwdAttr extends string,
  FwdCardinality extends CardinalityKind,
  RevEntity extends keyof Entities,
  RevAttr extends string,
  RevCardinality extends CardinalityKind,
> = {
  forward: {
    on: FwdEntity;
    label: FwdAttr;
    has: FwdCardinality;
    onDelete?: 'cascade';
  };
  reverse: {
    on: RevEntity;
    label: RevAttr;
    has: RevCardinality;
    onDelete?: 'cascade';
  };
};

// ==========
// derived types

export type EntitiesWithLinks<
  Entities extends EntitiesDef,
  Links extends LinksDef<Entities>,
> = {
  [EntityName in keyof Entities]: EntityDef<
    Entities[EntityName]['attrs'],
    EntityForwardLinksMap<EntityName, Entities, Links> &
      EntityReverseLinksMap<EntityName, Entities, Links>,
    Entities[EntityName] extends EntityDef<any, any, infer O>
      ? O extends void
        ? void
        : O
      : void
  >;
};

type EntityForwardLinksMap<
  EntityName extends keyof Entities,
  Entities extends EntitiesDef,
  Links extends LinksDef<Entities>,
  LinkIndexFwd = LinksIndexedByEntity<Entities, Links, 'reverse'>,
> = EntityName extends keyof LinkIndexFwd
  ? {
      [LinkName in keyof LinkIndexFwd[EntityName]]: LinkIndexFwd[EntityName][LinkName] extends LinkDef<
        Entities,
        infer RelatedEntityName,
        any,
        any,
        any,
        any,
        infer Cardinality
      >
        ? {
            entityName: RelatedEntityName;
            cardinality: Cardinality;
          }
        : never;
    }
  : {};

type EntityReverseLinksMap<
  EntityName extends keyof Entities,
  Entities extends EntitiesDef,
  Links extends LinksDef<Entities>,
  RevLinkIndex = LinksIndexedByEntity<Entities, Links, 'forward'>,
> = EntityName extends keyof RevLinkIndex
  ? {
      [LinkName in keyof RevLinkIndex[EntityName]]: RevLinkIndex[EntityName][LinkName] extends LinkDef<
        Entities,
        any,
        any,
        infer Cardinality,
        infer RelatedEntityName,
        any,
        any
      >
        ? {
            entityName: RelatedEntityName;
            cardinality: Cardinality;
          }
        : never;
    }
  : {};

type LinksIndexedByEntity<
  Entities extends EntitiesDef,
  Links extends LinksDef<Entities>,
  Direction extends 'forward' | 'reverse',
> = {
  [FwdEntity in keyof Entities]: {
    [LinkName in keyof Links as Links[LinkName][Direction]['on'] extends FwdEntity
      ? Links[LinkName][Direction]['label']
      : never]: Links[LinkName] extends LinkDef<
      Entities,
      infer FwdEntity,
      infer FwdAttr,
      infer FwdCardinality,
      infer RevEntity,
      infer RevAttr,
      infer RevCardinality
    >
      ? LinkDef<
          Entities,
          FwdEntity,
          FwdAttr,
          FwdCardinality,
          RevEntity,
          RevAttr,
          RevCardinality
        >
      : never;
  };
};

type RequiredKeys<Attrs extends AttrsDefs> = {
  [K in keyof Attrs]: Attrs[K] extends DataAttrDef<any, infer R>
    ? R extends true
      ? K
      : never
    : never;
}[keyof Attrs];

type OptionalKeys<Attrs extends AttrsDefs> = {
  [K in keyof Attrs]: Attrs[K] extends DataAttrDef<any, infer R>
    ? R extends false
      ? K
      : never
    : never;
}[keyof Attrs];

/**
 * MappedAttrs:
 *   - Required keys => `key: ValueType`
 *   - Optional keys => `key?: ValueType`
 */
type MappedAttrs<Attrs extends AttrsDefs> = {
  [K in RequiredKeys<Attrs>]: Attrs[K] extends DataAttrDef<infer V, any>
    ? V
    : never;
} & {
  [K in OptionalKeys<Attrs>]?: Attrs[K] extends DataAttrDef<infer V, any>
    ? V
    : never;
};

export type ResolveEntityAttrs<
  EDef extends EntityDef<any, any, any>,
  ResolvedAttrs = MappedAttrs<EDef['attrs']>,
> =
  EDef extends EntityDef<any, any, infer AsType>
    ? AsType extends void
      ? ResolvedAttrs
      : Omit<ResolvedAttrs, keyof AsType> & AsType
    : ResolvedAttrs;

export type ResolveAttrs<
  Entities extends EntitiesDef,
  EntityName extends keyof Entities,
> = ResolveEntityAttrs<Entities[EntityName]>;

export type RoomsFromDef<RDef extends RoomsDef> = {
  [RoomName in keyof RDef]: {
    presence: ResolveEntityAttrs<RDef[RoomName]['presence']>;
    topics: {
      [TopicName in keyof RDef[RoomName]['topics']]: ResolveEntityAttrs<
        RDef[RoomName]['topics'][TopicName]
      >;
    };
  };
};

export type RoomsOf<S> =
  S extends InstantSchemaDef<any, any, infer RDef> ? RoomsFromDef<RDef> : never;

export type PresenceOf<
  S,
  RoomType extends keyof RoomsOf<S>,
> = RoomsOf<S>[RoomType] extends { presence: infer P } ? P : {};

export type TopicsOf<
  S,
  RoomType extends keyof RoomsOf<S>,
> = RoomsOf<S>[RoomType] extends { topics: infer T } ? T : {};

export type TopicOf<
  S,
  RoomType extends keyof RoomsOf<S>,
  TopicType extends keyof TopicsOf<S, RoomType>,
> = TopicsOf<S, RoomType>[TopicType];

interface RoomDef {
  presence: EntityDef<any, any, any>;
  topics?: {
    [TopicName: string]: EntityDef<any, any, any>;
  };
}

export interface RoomsDef {
  [RoomType: string]: RoomDef;
}

export class InstantSchemaDef<
  Entities extends EntitiesDef,
  Links extends LinksDef<Entities>,
  Rooms extends RoomsDef,
> implements IContainEntitiesAndLinks<Entities, Links>
{
  constructor(
    public entities: Entities,
    public links: Links,
    public rooms: Rooms,
  ) {}

  /**
   * @deprecated
   * `withRoomSchema` is deprecated. Define your schema in `rooms` directly:
   *
   * @example
   * // Before:
   * const schema = i.schema({
   *   // ...
   * }).withRoomSchema<RoomSchema>()
   *
   * // After
   * const schema = i.schema({
   *  rooms: {
   *    // ...
   *  }
   * })
   *
   * @see https://instantdb.com/docs/presence-and-topics#typesafety
   */
  withRoomSchema<_RoomSchema extends RoomSchemaShape>() {
    type RDef = RoomDefFromShape<_RoomSchema>;
    return new InstantSchemaDef<Entities, Links, RDef>(
      this.entities,
      this.links,
      {} as RDef,
    );
  }
}

/**
 * @deprecated
 * `i.graph` is deprecated. Use `i.schema` instead.
 *
 * @see https://instantdb.com/docs/modeling-data
 */
export class InstantGraph<
  Entities extends EntitiesDef,
  Links extends LinksDef<Entities>,
  RoomSchema extends RoomSchemaShape = {},
> implements IContainEntitiesAndLinks<Entities, Links>
{
  constructor(
    public entities: Entities,
    public links: Links,
  ) {}

  withRoomSchema<_RoomSchema extends RoomSchemaShape>() {
    return new InstantGraph<Entities, Links, _RoomSchema>(
      this.entities,
      this.links,
    );
  }
}

type EntityDefFromRoomSlice<Shape extends { [k: string]: any }> = EntityDef<
  {
    [AttrName in keyof Shape]: DataAttrDef<
      Shape[AttrName],
      Shape[AttrName] extends undefined ? false : true
    >;
  },
  any,
  void
>;

type RoomDefFromShape<RoomSchema extends RoomSchemaShape> = {
  [RoomName in keyof RoomSchema]: {
    presence: EntityDefFromRoomSlice<RoomSchema[RoomName]['presence']>;
    topics: {
      [TopicName in keyof RoomSchema[RoomName]['topics']]: EntityDefFromRoomSlice<
        RoomSchema[RoomName]['topics'][TopicName]
      >;
    };
  };
};

type EntityDefFromShape<Shape, K extends keyof Shape> = EntityDef<
  {
    [AttrName in keyof Shape[K]]: DataAttrDef<
      Shape[K][AttrName],
      Shape[K][AttrName] extends undefined ? false : true
    >;
  },
  {
    [LinkName in keyof Shape]: LinkAttrDef<
      'many',
      LinkName extends string ? LinkName : string
    >;
  },
  void
>;

/**
 * If you were using the old `schema` types, you can use this to help you
 * migrate.
 *
 * @example
 * // Before
 * const db = init<Schema, Rooms>({...})
 *
 * // After
 * const db = init<BackwardsCompatibleSchema<Schema, Rooms>>({...})
 */
export type BackwardsCompatibleSchema<
  Shape extends { [k: string]: any },
  RoomSchema extends RoomSchemaShape = {},
> = InstantSchemaDef<
  { [K in keyof Shape]: EntityDefFromShape<Shape, K> },
  UnknownLinks<EntitiesDef>,
  RoomDefFromShape<RoomSchema>
>;

// ----------
// InstantUnknownSchema

export type UnknownEntity = EntityDef<
  {
    id: DataAttrDef<string, true>;
    [AttrName: string]: DataAttrDef<any, any>;
  },
  { [LinkName: string]: LinkAttrDef<'many', string> },
  void
>;

export type UnknownEntities = {
  [EntityName: string]: UnknownEntity;
};

export interface UnknownLinks<Entities extends EntitiesDef> {
  [LinkName: string]: LinkDef<
    Entities,
    string,
    string,
    'many',
    string,
    string,
    'many'
  >;
}

export interface UnknownRooms {
  [RoomName: string]: {
    presence: EntityDef<any, any, any>;
    topics: {
      [TopicName: string]: EntityDef<any, any, any>;
    };
  };
}

export type InstantUnknownSchema = InstantSchemaDef<
  UnknownEntities,
  UnknownLinks<UnknownEntities>,
  UnknownRooms
>;

export type UpdateParams<
  Schema extends IContainEntitiesAndLinks<any, any>,
  EntityName extends keyof Schema['entities'],
> = {
  [AttrName in keyof Schema['entities'][EntityName]['attrs']]?: Schema['entities'][EntityName]['attrs'][AttrName] extends DataAttrDef<
    infer ValueType,
    infer IsRequired
  >
    ? IsRequired extends true
      ? ValueType
      : ValueType | null
    : never;
};

export type LinkParams<
  Schema extends IContainEntitiesAndLinks<any, any>,
  EntityName extends keyof Schema['entities'],
> = {
  [LinkName in keyof Schema['entities'][EntityName]['links']]?: Schema['entities'][EntityName]['links'][LinkName] extends LinkAttrDef<
    infer Cardinality,
    any
  >
    ? Cardinality extends 'one'
      ? string
      : string | string[]
    : never;
};
</file>

<file path="client/packages/core/src/StorageAPI.ts">
import { jsonFetch } from './utils/fetch';

export type UploadFileResponse = {
  data: {
    id: string;
  };
};

export type DeleteFileResponse = {
  data: {
    id: string | null;
  };
};

export async function uploadFile({
  apiURI,
  appId,
  path,
  file,
  refreshToken,
  contentType,
  contentDisposition,
}: {
  apiURI: string;
  appId: string;
  path: string;
  file: File;
  refreshToken?: string;
  contentType?: string;
  contentDisposition?: string;
}): Promise<UploadFileResponse> {
  const headers = {
    app_id: appId,
    path,
    authorization: `Bearer ${refreshToken}`,
    'content-type': contentType || file.type,
  };
  if (contentDisposition) {
    headers['content-disposition'] = contentDisposition;
  }

  const data = await jsonFetch(`${apiURI}/storage/upload`, {
    method: 'PUT',
    headers,
    body: file,
  });

  return data;
}

export async function deleteFile({
  apiURI,
  appId,
  path,
  refreshToken,
}: {
  apiURI: string;
  appId: string;
  path: string;
  refreshToken?: string;
}): Promise<DeleteFileResponse> {
  const { data } = await jsonFetch(
    `${apiURI}/storage/files?app_id=${appId}&filename=${encodeURIComponent(path)}`,
    {
      method: 'DELETE',
      headers: {
        'content-type': 'application/json',
        authorization: `Bearer ${refreshToken}`,
      },
    },
  );

  return data;
}

// Deprecated Storage API (Jan 2025)
// ---------------------------------

export async function getSignedUploadUrl({
  apiURI,
  appId,
  fileName,
  refreshToken,
  metadata = {},
}: {
  apiURI: string;
  appId: string;
  fileName: string;
  refreshToken?: string;
  metadata?: Record<string, any>;
}) {
  const { data } = await jsonFetch(`${apiURI}/storage/signed-upload-url`, {
    method: 'POST',
    headers: {
      'content-type': 'application/json',
      authorization: `Bearer ${refreshToken}`,
    },
    body: JSON.stringify({
      app_id: appId,
      filename: fileName,
    }),
  });

  return data;
}

export async function upload(presignedUrl, file) {
  console.log('presignedUrl', presignedUrl);
  const response = await fetch(presignedUrl, {
    method: 'PUT',
    body: file,
    headers: {
      'Content-Type': file.type,
    },
  });

  return response.ok;
}

export async function getDownloadUrl({
  apiURI,
  appId,
  path,
  refreshToken,
}: {
  apiURI: string;
  appId: string;
  path: string;
  refreshToken?: string;
}) {
  const { data } = await jsonFetch(
    `${apiURI}/storage/signed-download-url?app_id=${appId}&filename=${encodeURIComponent(
      path,
    )}`,
    {
      method: 'GET',
      headers: {
        'content-type': 'application/json',
        authorization: `Bearer ${refreshToken}`,
      },
    },
  );

  return data;
}
</file>

<file path="client/packages/core/src/store.js">
import { create } from 'mutative';
import { immutableDeepMerge } from './utils/object';

function hasEA(attr) {
  return attr['cardinality'] === 'one';
}

function isRef(attr) {
  return attr['value-type'] === 'ref';
}

function isBlob(attr) {
  return attr['value-type'] === 'blob';
}

function getAttr(attrs, attrId) {
  return attrs[attrId];
}

function getInMap(obj, path) {
  return path.reduce((acc, key) => acc && acc.get(key), obj);
}

function deleteInMap(m, path) {
  if (path.length === 0) throw new Error('path must have at least one element');
  if (path.length === 1) {
    m.delete(path[0]);
    return;
  }
  const [head, ...tail] = path;
  if (!m.has(head)) return;
  deleteInMap(m.get(head), tail);
}

function setInMap(m, path, value) {
  if (path.length === 0) throw new Error('path must have at least one element');
  if (path.length === 1) {
    m.set(path[0], value);
    return;
  }
  const [head, ...tail] = path;
  let nextM = m.get(head);
  if (!nextM) {
    nextM = new Map();
    m.set(head, nextM);
  }
  setInMap(nextM, tail, value);
}

function createTripleIndexes(attrs, triples) {
  const eav = new Map();
  const aev = new Map();
  const vae = new Map();
  for (const triple of triples) {
    const [eid, aid, v, t] = triple;
    const attr = getAttr(attrs, aid);
    if (!attr) {
      console.warn('no such attr', eid, attrs);
      continue;
    }

    if (isRef(attr)) {
      setInMap(vae, [v, aid, eid], triple);
    }

    setInMap(eav, [eid, aid, v], triple);
    setInMap(aev, [aid, eid, v], triple);
  }
  return { eav, aev, vae };
}

function createAttrIndexes(attrs) {
  const blobAttrs = new Map();
  const primaryKeys = new Map();
  const forwardIdents = new Map();
  const revIdents = new Map();
  for (const attr of Object.values(attrs)) {
    const fwdIdent = attr['forward-identity'];
    const [_, fwdEtype, fwdLabel] = fwdIdent;
    const revIdent = attr['reverse-identity'];

    setInMap(forwardIdents, [fwdEtype, fwdLabel], attr);
    if (isBlob(attr)) {
      setInMap(blobAttrs, [fwdEtype, fwdLabel], attr);
    }
    if (attr['primary?']) {
      setInMap(primaryKeys, [fwdEtype], attr);
    }
    if (revIdent) {
      const [_, revEtype, revLabel] = revIdent;
      setInMap(revIdents, [revEtype, revLabel], attr);
    }
  }

  return { blobAttrs, primaryKeys, forwardIdents, revIdents };
}

export function toJSON(store) {
  return {
    __type: store.__type,
    attrs: store.attrs,
    triples: allMapValues(store.eav, 3),
    cardinalityInference: store.cardinalityInference,
    linkIndex: store.linkIndex,
  };
}

export function fromJSON(storeJSON) {
  return createStore(
    storeJSON.attrs,
    storeJSON.triples,
    storeJSON.cardinalityInference,
    storeJSON.linkIndex,
  );
}

function resetAttrIndexes(store) {
  store.attrIndexes = createAttrIndexes(store.attrs);
}

export function createStore(
  attrs,
  triples,
  enableCardinalityInference,
  linkIndex,
) {
  const store = createTripleIndexes(attrs, triples);
  store.attrs = attrs;
  store.attrIndexes = createAttrIndexes(attrs);
  store.cardinalityInference = enableCardinalityInference;
  store.linkIndex = linkIndex;
  store.__type = 'store';

  return store;
}

// We may have local triples with lookup refs in them,
// we need to convert those lookup refs to eids to insert them
// into the store. If we can't find the lookup ref locally,
// then we drop the triple and have to wait for the server response
// to see the optimistic updates.
function resolveLookupRefs(store, triple) {
  let eid;

  // Check if `e` is a lookup ref
  if (Array.isArray(triple[0])) {
    const [a, v] = triple[0];
    const eMaps = store.aev.get(a);
    if (!eMaps) {
      // We don't have the attr, so don't try to add the
      // triple to the store
      return null;
    }
    // This would be a lot more efficient with a ave index
    const triples = allMapValues(eMaps, 2);
    eid = triples.find((x) => x[2] === v)?.[0];
  } else {
    eid = triple[0];
  }

  if (!eid) {
    // We don't know the eid that the ref refers to, so
    // we can't add the triple to the store.
    return null;
  }

  // Check if v is a lookup ref
  const lookupV = triple[2];
  if (
    Array.isArray(lookupV) &&
    lookupV.length === 2 &&
    store.aev.get(lookupV[0])
  ) {
    const [a, v] = lookupV;
    const eMaps = store.aev.get(a);
    if (!eMaps) {
      // We don't have the attr, so don't try to add the
      // triple to the store
      return null;
    }
    const triples = allMapValues(eMaps, 2);
    const value = triples.find((x) => x[2] === v)?.[0];
    if (!value) {
      return null;
    }
    const [_e, aid, _v, ...rest] = triple;
    return [eid, aid, value, ...rest];
  } else {
    const [_, ...rest] = triple;
    return [eid, ...rest];
  }
}

function retractTriple(store, rawTriple) {
  const triple = resolveLookupRefs(store, rawTriple);
  if (!triple) {
    return;
  }
  const [eid, aid, v] = triple;
  const attr = getAttr(store.attrs, aid);
  if (!attr) {
    return;
  }

  deleteInMap(store.eav, [eid, aid, v]);
  deleteInMap(store.aev, [aid, eid, v]);
  if (isRef(attr)) {
    deleteInMap(store.vae, [v, aid, eid]);
  }
}

let _seed = 0;
function getCreatedAt(store, attr, triple) {
  const [eid, aid, v] = triple;
  let createdAt;
  const t = getInMap(store.ea, [eid, aid, v]);
  if (t) {
    createdAt = t[3];
  }

  /**
   * (XXX)
   * Two hacks here, for generating a `createdAt`
   *
   * 1. We multiply Date.now() by 10, to make sure that
   *  `createdAt` is always greater than anything the server
   *   could return
   *
   *   We do this because right now we know we _only_ insert
   *   triples as optimistic updates.
   *
   * 2. We increment by `_seed`, to make sure there are no
   *    two triples with the same `createdAt`. This is
   *    done to make tests more predictable.
   *
   * We may need to rethink this. Because we * 10, we can't
   * use this value as an _actual_ `createdAt` timestamp.
   * Eventually we may want too though; For example, we could
   * use `createdAt` for each triple, to infer a `createdAt` and
   * `updatedAt` value for each object.
   */
  return createdAt || Date.now() * 10 + _seed++;
}

function addTriple(store, rawTriple) {
  const triple = resolveLookupRefs(store, rawTriple);
  if (!triple) {
    return;
  }
  const [eid, aid, v] = triple;
  const attr = getAttr(store.attrs, aid);
  if (!attr) {
    // (XXX): Due to the way we're handling attrs, it's
    // possible to enter a state where we receive a triple without an attr.
    // See: https://github.com/jsventures/instant-local/pull/132 for details.
    // For now, if we receive a command without an attr, we no-op.
    return;
  }

  const existingTriple = getInMap(store.eav, [eid, aid, v]);
  // Reuse the created_at for a triple if it's already in the store.
  // Prevents updates from temporarily pushing an entity to the top
  // while waiting for the server response.
  const t = existingTriple?.[3] ?? getCreatedAt(store, attr, triple);
  const enhancedTriple = [eid, aid, v, t];

  if (hasEA(attr)) {
    setInMap(store.eav, [eid, aid], new Map([[v, enhancedTriple]]));
    setInMap(store.aev, [aid, eid], new Map([[v, enhancedTriple]]));
  } else {
    setInMap(store.eav, [eid, aid, v], enhancedTriple);
    setInMap(store.aev, [aid, eid, v], enhancedTriple);
  }

  if (isRef(attr)) {
    setInMap(store.vae, [v, aid, eid], enhancedTriple);
  }
}

function mergeTriple(store, rawTriple) {
  const triple = resolveLookupRefs(store, rawTriple);
  if (!triple) {
    return;
  }

  const [eid, aid, update] = triple;
  const attr = getAttr(store.attrs, aid);

  if (!attr) return;

  if (!isBlob(attr))
    throw new Error('merge operation is not supported for links');

  const eavValuesMap = getInMap(store.eav, [eid, aid]);
  if (!eavValuesMap) return;

  const currentTriple = eavValuesMap.values().next()?.value;
  if (!currentTriple) return;

  const currentValue = currentTriple[2];
  const updatedValue = immutableDeepMerge(currentValue, update);
  const enhancedTriple = [
    eid,
    aid,
    updatedValue,
    getCreatedAt(store, attr, currentTriple),
  ];

  setInMap(store.eav, [eid, aid], new Map([[updatedValue, enhancedTriple]]));
}

function deleteEntity(store, args) {
  const [lookup, etype] = args;
  const triple = resolveLookupRefs(store, [lookup]);

  if (!triple) {
    return;
  }
  const [id] = triple;

  // delete forward links and attributes + cardinality one links
  const eMap = store.eav.get(id);
  if (eMap) {
    for (const a of eMap.keys()) {
      const attr = store.attrs[a];

      // delete cascade refs
      if (attr && attr['on-delete-reverse'] === 'cascade') {
        allMapValues(eMap.get(a), 1).forEach(([e, a, v]) =>
          deleteEntity(store, [v, attr['reverse-identity']?.[1]]),
        );
      }

      if (
        // Fall back to deleting everything if we've rehydrated tx-steps from
        // the store that didn't set `etype` in deleteEntity
        !etype ||
        // If we don't know about the attr, let's just get rid of it
        !attr ||
        // Make sure it matches the etype
        attr['forward-identity']?.[1] === etype
      ) {
        deleteInMap(store.aev, [a, id]);
        deleteInMap(store.eav, [id, a]);
      }
    }
    // Clear out the eav index for `id` if we deleted all of the attributes
    if (eMap.size === 0) {
      deleteInMap(store.eav, [id]);
    }
  }

  // delete reverse links
  const vaeTriples = store.vae.get(id) && allMapValues(store.vae.get(id), 2);

  if (vaeTriples) {
    vaeTriples.forEach((triple) => {
      const [e, a, v] = triple;
      const attr = store.attrs[a];
      if (!etype || !attr || attr['reverse-identity']?.[1] === etype) {
        deleteInMap(store.eav, [e, a, v]);
        deleteInMap(store.aev, [a, e, v]);
        deleteInMap(store.vae, [v, a, e]);
      }
      if (attr && attr['on-delete'] === 'cascade') {
        deleteEntity(store, [e, attr['forward-identity']?.[1]]);
      }
    });
  }
  // Clear out vae index for `id` if we deleted all the reverse attributes
  if (store.vae.get(id)?.size === 0) {
    deleteInMap(store.vae, [id]);
  }
}

// (XXX): Whenever we change/delete attrs,
// We indiscriminately reset the index map.
// There are lots of opportunities for optimization:
// * We _only_ need to run this indexes change. We could detect that
// * We could batch this reset at the end
// * We could add an ave index for all triples, so removing the
//   right triples is easy and fast.
function resetIndexMap(store, newTriples) {
  const newIndexMap = createTripleIndexes(store.attrs, newTriples);
  Object.keys(newIndexMap).forEach((key) => {
    store[key] = newIndexMap[key];
  });
}

function addAttr(store, [attr]) {
  store.attrs[attr.id] = attr;
  resetAttrIndexes(store);
}

function getAllTriples(store) {
  return allMapValues(store.eav, 3);
}

function deleteAttr(store, [id]) {
  if (!store.attrs[id]) return;
  const newTriples = getAllTriples(store).filter(([_, aid]) => aid !== id);
  delete store.attrs[id];
  resetAttrIndexes(store);
  resetIndexMap(store, newTriples);
}

function updateAttr(store, [partialAttr]) {
  const attr = store.attrs[partialAttr.id];
  if (!attr) return;
  store.attrs[partialAttr.id] = { ...attr, ...partialAttr };
  resetAttrIndexes(store);
  resetIndexMap(store, getAllTriples(store));
}

function applyTxStep(store, txStep) {
  const [action, ...args] = txStep;
  switch (action) {
    case 'add-triple':
      addTriple(store, args);
      break;
    case 'deep-merge-triple':
      mergeTriple(store, args);
      break;
    case 'retract-triple':
      retractTriple(store, args);
      break;
    case 'delete-entity':
      deleteEntity(store, args);
      break;
    case 'add-attr':
      addAttr(store, args);
      break;
    case 'delete-attr':
      deleteAttr(store, args);
      break;
    case 'update-attr':
      updateAttr(store, args);
      break;
    default:
      throw new Error(`unhandled transaction action: ${action}`);
  }
}

export function allMapValues(m, level, res = []) {
  if (!m) {
    return res;
  }
  if (level === 0) {
    return res;
  }
  if (level === 1) {
    for (const v of m.values()) {
      res.push(v);
    }
    return res;
  }
  for (const v of m.values()) {
    allMapValues(v, level - 1, res);
  }

  return res;
}

function triplesByValue(store, m, v) {
  const res = [];
  if (v?.hasOwnProperty('$not')) {
    for (const candidate of m.keys()) {
      if (v.$not !== candidate) {
        res.push(m.get(candidate));
      }
    }
    return res;
  }

  if (v?.hasOwnProperty('$isNull')) {
    const { attrId, isNull, reverse } = v.$isNull;

    if (reverse) {
      for (const candidate of m.keys()) {
        const vMap = store.vae.get(candidate);
        const isValNull =
          !vMap || vMap.get(attrId)?.get(null) || !vMap.get(attrId);
        if (isNull ? isValNull : !isValNull) {
          res.push(m.get(candidate));
        }
      }
    } else {
      const aMap = store.aev.get(attrId);
      for (const candidate of m.keys()) {
        const isValNull =
          !aMap || aMap.get(candidate)?.get(null) || !aMap.get(candidate);
        if (isNull ? isValNull : !isValNull) {
          res.push(m.get(candidate));
        }
      }
    }
    return res;
  }

  if (v?.$comparator) {
    // TODO: A sorted index would be nice here
    return allMapValues(m, 1).filter(v.$op);
  }

  const values = v.in || v.$in || [v];

  for (const value of values) {
    const triple = m.get(value);
    if (triple) {
      res.push(triple);
    }
  }

  return res;
}

// A poor man's pattern matching
// Returns either eav, ea, ev, av, v, or ''
function whichIdx(e, a, v) {
  let res = '';
  if (e !== undefined) {
    res += 'e';
  }
  if (a !== undefined) {
    res += 'a';
  }
  if (v !== undefined) {
    res += 'v';
  }
  return res;
}

export function getTriples(store, [e, a, v]) {
  const idx = whichIdx(e, a, v);
  switch (idx) {
    case 'e': {
      const eMap = store.eav.get(e);
      return allMapValues(eMap, 2);
    }
    case 'ea': {
      const aMap = store.eav.get(e)?.get(a);
      return allMapValues(aMap, 1);
    }
    case 'eav': {
      const aMap = store.eav.get(e)?.get(a);
      if (!aMap) {
        return [];
      }
      return triplesByValue(store, aMap, v);
    }
    case 'ev': {
      const eMap = store.eav.get(e);
      if (!eMap) {
        return [];
      }
      const res = [];
      for (const aMap of eMap.values()) {
        res.push(...triplesByValue(store, aMap, v));
      }
      return res;
    }
    case 'a': {
      const aMap = store.aev.get(a);
      return allMapValues(aMap, 2);
    }
    case 'av': {
      const aMap = store.aev.get(a);
      if (!aMap) {
        return [];
      }
      const res = [];
      for (const eMap of aMap.values()) {
        res.push(...triplesByValue(store, eMap, v));
      }
      return res;
    }
    case 'v': {
      const res = [];
      for (const eMap of store.eav.values()) {
        for (const aMap of eMap.values()) {
          res.push(...triplesByValue(store, aMap, v));
        }
      }
    }
    default: {
      return allMapValues(store.eav, 3);
    }
  }
}

export function getAsObject(store, etype, e) {
  const blobAttrs = store.attrIndexes.blobAttrs.get(etype);
  const obj = {};

  for (const [label, attr] of blobAttrs.entries()) {
    const aMap = store.eav.get(e)?.get(attr.id);
    const triples = allMapValues(aMap, 1);
    for (const triple of triples) {
      obj[label] = triple[2];
    }
  }

  return obj;
}

export function getAttrByFwdIdentName(store, inputEtype, inputLabel) {
  return store.attrIndexes.forwardIdents.get(inputEtype)?.get(inputLabel);
}

export function getAttrByReverseIdentName(store, inputEtype, inputLabel) {
  return store.attrIndexes.revIdents.get(inputEtype)?.get(inputLabel);
}

export function getPrimaryKeyAttr(store, etype) {
  const fromPrimary = store.attrIndexes.primaryKeys.get(etype);
  if (fromPrimary) {
    return fromPrimary;
  }
  return store.attrIndexes.forwardIdents.get(etype)?.get('id');
}

export function transact(store, txSteps) {
  return create(store, (draft) => {
    txSteps.forEach((txStep) => {
      applyTxStep(draft, txStep);
    });
  });
}
</file>

<file path="client/packages/core/src/version.js">
// Autogenerated by publish_packages.clj
const version = 'v0.17.22-dev';

export default version;
</file>

<file path="client/packages/core/src/WindowNetworkListener.js">
export default class WindowNetworkListener {
  static async getIsOnline() {
    return navigator.onLine;
  }
  static listen(f) {
    const onOnline = () => {
      f(true);
    };
    const onOffline = () => {
      f(false);
    };
    addEventListener('online', onOnline);
    addEventListener('offline', onOffline);
    return () => {
      removeEventListener('online', onOnline);
      removeEventListener('offline', onOffline);
    };
  }
}
</file>

<file path="client/packages/core/.npmignore">
.turbo
</file>

<file path="client/packages/core/package.json">
{
  "name": "@instantdb/core",
  "version": "v0.17.22",
  "description": "Instant's core local abstraction",
  "main": "dist/index.js",
  "module": "dist/module/index.js",
  "types": "dist/module/index.d.ts",
  "unpkg": "standalone/index.umd.js",
  "scripts": {
    "test": "vitest",
    "bench": "vitest bench",
    "test:ci": "vitest run",
    "bench:ci": "vitest bench --run",
    "check": "tsc --noEmit",
    "build": "rm -rf dist; npm run build:main && npm run build:module && npm run build:standalone",
    "dev:main": "tsc -p tsconfig.json -w --skipLibCheck",
    "dev:module": "tsc -p tsconfig.module.json -w --skipLibCheck",
    "dev": "run-p dev:main dev:module",
    "build:main": "tsc -p tsconfig.json",
    "build:module": "tsc -p tsconfig.module.json",
    "build:standalone": "vite build",
    "publish-package": "pnpm publish --access public --no-git-checks"
  },
  "devDependencies": {
    "@babel/core": "^7.17.9",
    "@babel/preset-env": "^7.16.11",
    "@types/node": "^18.11.18",
    "@types/uuid": "^8.3.4",
    "@types/websocket": "^1.0.5",
    "fake-indexeddb": "^6.0.0",
    "npm-run-all": "^4.1.5",
    "typescript": "^5.5.4",
    "vite": "^5.2.0",
    "vitest": "^1.6.0"
  },
  "dependencies": {
    "mutative": "^1.0.10",
    "uuid": "^9.0.0"
  }
}
</file>

<file path="client/packages/core/README.md">
<p align="center">
  <a href="https://instantdb.com">
    <img alt="Shows the Instant logo" src="https://instantdb.com/img/icon/android-chrome-512x512.png" width="10%">
  </a>
  <h1 align="center">@instantdb/core</h1>
</p>

<p align="center">
  <a 
    href="https://discord.com/invite/VU53p7uQcE" >
    <img height=20 src="https://img.shields.io/discord/1031957483243188235" />
  </a>
  <img src="https://img.shields.io/github/stars/instantdb/instant" alt="stars">
</p>

<p align="center">
   <a href="https://www.instantdb.com/docs/start-vanilla">Get Started</a> · 
   <a href="https://instantdb.com/examples">Examples</a> · 
   <a href="https://instantdb.com/tutorial">Try the Demo</a> · 
   <a href="https://www.instantdb.com/docs/start-vanilla">Docs</a> · 
   <a href="https://discord.com/invite/VU53p7uQcE">Discord</a>
<p>

Welcome to [Instant's](http://instantdb.com) vanilla javascript SDK.

```javascript
db.subscribeQuery({ todos: {} }, (resp) => {
  if (resp.error) {
    renderError(resp.error.message);
    return;
  }
  if (resp.data) {
    render(resp.data); // wohoo!
  }
});
```

# Get Started

Follow the [getting started in vanilla Javascript](https://www.instantdb.com/docs/start-vanilla) tutorial to set up a live app in under 5 minutes! Or you can try a [demo](https://instantdb.com/tutorial) in your browser :).

# Questions?

If you have any questions, feel free to drop us a line on our [Discord](https://discord.com/invite/VU53p7uQcE)
</file>

<file path="client/packages/core/tsconfig.json">
{
  "extends": "../../tsconfig.base.json",
  "include": ["src"],
  "exclude": ["node_modules", "dist"],
  "compilerOptions": {
    "outDir": "dist",
    "rootDir": "src",
    "checkJs": false
  }
}
</file>

<file path="client/packages/core/tsconfig.module.json">
{
  "extends": "./tsconfig",
  "compilerOptions": {
    "module": "es2015",
    "outDir": "dist/module"
  }
}
</file>

<file path="client/packages/core/vite.config.ts">
import { defineConfig } from 'vite';
import { resolve } from 'path';

export default defineConfig({
  build: {
    outDir: 'dist/standalone',
    lib: {
      formats: ['umd', 'es'],
      // this is the file that exports our components
      entry: resolve(__dirname, 'src', 'index.ts'),
      name: 'instant',
      fileName: 'index',
    },
  },
  define: {
    'process.env': {},
  },
});
</file>

<file path="client/packages/react/__example__/standalone.esm.html">
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Instant React ESM standalone example/test</title>
  </head>
  <body>
    <script type="importmap">
      {
        "imports": {
          "@instant/react": "/dist/standalone/index.mjs",
          "react": "https://esm.sh/react",
          "react-dom": "https://esm.sh/react-dom"
        }
      }
    </script>
    <!-- make sure to run `build:standalone` first! -->
    <!-- easiest way to test this is with `python3 -m http.server` in the root directory of this project -->
    <script type="module">
      import { init } from "@instant/react";

      const query = {};

      const db = init({
        appId: new URL(location.href).searchParams.get("app_id"),
      });

      console.log(await db.getLocalId());
    </script>
  </body>
</html>
</file>

<file path="client/packages/react/__example__/standalone.umd.html">
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Instant React UMD standalone example/test</title>
  </head>
  <body>
    <script
      crossorigin
      src="https://unpkg.com/react@18/umd/react.production.min.js"
    ></script>
    <script
      crossorigin
      src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"
    ></script>
    <!-- make sure to run `build:standalone` first! -->
    <script src="../dist/standalone/index.umd.js"></script>
    <script>
      const query = {};

      const db = instantReact.init({
        appId: new URL(location.href).searchParams.get("app_id"),
      });
    </script>
  </body>
</html>
</file>

<file path="client/packages/react/src/Cursors.tsx">
import {
  createElement,
  type ReactNode,
  type MouseEvent,
  type TouchEvent,
  type CSSProperties,
} from 'react';
import type { InstantReactRoom } from './InstantReactRoom';
import type { RoomSchemaShape } from '@instantdb/core';

export function Cursors<
  RoomSchema extends RoomSchemaShape,
  RoomType extends keyof RoomSchema,
>({
  as = 'div',
  spaceId: _spaceId,
  room,
  className,
  style,
  userCursorColor,
  children,
  renderCursor,
  propagate,
  zIndex,
}: {
  spaceId?: string;
  room: InstantReactRoom<any, RoomSchema, RoomType>;
  style?: React.CSSProperties;
  userCursorColor?: string;
  as?: any;
  className?: string;
  children?: ReactNode;
  renderCursor?: (props: {
    color: string;
    presence: RoomSchema[RoomType]['presence'];
  }) => ReactNode;
  propagate?: boolean;
  zIndex?: number;
}) {
  const spaceId =
    _spaceId || `cursors-space-default--${String(room.type)}-${room.id}`;

  const cursorsPresence = room.usePresence({
    keys: [spaceId],
  });

  const fullPresence = room._core._reactor.getPresence(room.type, room.id);

  function publishCursor(
    rect: DOMRect,
    touch: { clientX: number; clientY: number },
  ) {
    const x = touch.clientX;
    const y = touch.clientY;
    const xPercent = ((x - rect.left) / rect.width) * 100;
    const yPercent = ((y - rect.top) / rect.height) * 100;
    cursorsPresence.publishPresence({
      [spaceId]: {
        x,
        y,
        xPercent,
        yPercent,
        color: userCursorColor,
      },
    } as RoomSchema[RoomType]['presence']);
  }

  function onMouseMove(e: MouseEvent) {
    if (!propagate) {
      e.stopPropagation();
    }

    const rect = e.currentTarget.getBoundingClientRect();
    publishCursor(rect, e);
  }

  function onMouseOut(e: MouseEvent) {
    cursorsPresence.publishPresence({
      [spaceId]: undefined,
    } as RoomSchema[RoomType]['presence']);
  }

  function onTouchMove(e: TouchEvent) {
    if (e.touches.length !== 1) {
      return;
    }

    const touch = e.touches[0];

    if (touch.target instanceof Element) {
      if (!propagate) {
        e.stopPropagation();
      }
      const rect = touch.target.getBoundingClientRect();
      publishCursor(rect, touch);
    }
  }

  function onTouchEnd(e: TouchEvent) {
    cursorsPresence.publishPresence({
      [spaceId]: undefined,
    } as RoomSchema[RoomType]['presence']);
  }

  return createElement(
    as,
    {
      onMouseMove,
      onMouseOut,
      onTouchMove,
      onTouchEnd,
      className,
      style: {
        position: 'relative',
        ...style,
      },
    },
    [
      children,
      <div
        key={spaceId}
        style={{
          ...absStyles,
          ...inertStyles,
          zIndex: zIndex !== undefined ? zIndex : defaultZ,
        }}
      >
        {Object.entries(cursorsPresence.peers).map(([id, presence]) => {
          const cursor = presence[spaceId];
          if (!cursor) return null;

          return (
            <div
              key={id}
              style={{
                ...absStyles,
                transform: `translate(${cursor.xPercent}%, ${cursor.yPercent}%)`,
                transformOrigin: '0 0',
                transition: 'transform 100ms',
              }}
            >
              {renderCursor ? (
                renderCursor({
                  color: cursor.color,
                  presence: fullPresence.peers[id],
                })
              ) : (
                <Cursor {...cursor} />
              )}
            </div>
          );
        })}
      </div>,
    ],
  );
}

function Cursor({ color }: { color: string }) {
  const size = 35;
  const fill = color || 'black';

  return (
    <svg
      style={{ height: size, width: size }}
      viewBox={`0 0 ${size} ${size}`}
      fill="none"
      xmlns="http://www.w3.org/2000/svg"
    >
      <g
        fill="rgba(0,0,0,.2)"
        transform="matrix(1, 0, 0, 1, -11.999999046325684, -8.406899452209473)"
      >
        <path d="m12 24.4219v-16.015l11.591 11.619h-6.781l-.411.124z" />
        <path d="m21.0845 25.0962-3.605 1.535-4.682-11.089 3.686-1.553z" />
      </g>
      <g
        fill="white"
        transform="matrix(1, 0, 0, 1, -11.999999046325684, -8.406899452209473)"
      >
        <path d="m12 24.4219v-16.015l11.591 11.619h-6.781l-.411.124z" />
        <path d="m21.0845 25.0962-3.605 1.535-4.682-11.089 3.686-1.553z" />
      </g>
      <g
        fill={fill}
        transform="matrix(1, 0, 0, 1, -11.999999046325684, -8.406899452209473)"
      >
        <path d="m19.751 24.4155-1.844.774-3.1-7.374 1.841-.775z" />
        <path d="m13 10.814v11.188l2.969-2.866.428-.139h4.768z" />
      </g>
    </svg>
  );
}

const absStyles: CSSProperties = {
  position: 'absolute',
  top: 0,
  left: 0,
  bottom: 0,
  right: 0,
};

const inertStyles: CSSProperties = {
  overflow: 'hidden',
  pointerEvents: 'none',
  userSelect: 'none',
};

const defaultZ = 99999;
</file>

<file path="client/packages/react/src/index.ts">
import {
  id,
  tx,
  lookup,
  i,

  // types
  type QueryResponse,
  type InstantQuery,
  type InstantQueryResult,
  type InstantSchema,
  type InstantObject,
  type InstantEntity,
  type InstantSchemaDatabase,
  type IInstantDatabase,
  type User,
  type AuthState,
  type Query,
  type Config,
  type InstaQLParams,
  type ConnectionStatus,

  // schema types
  type AttrsDefs,
  type CardinalityKind,
  type DataAttrDef,
  type EntitiesDef,
  type EntitiesWithLinks,
  type EntityDef,
  type InstantGraph,
  type LinkAttrDef,
  type LinkDef,
  type LinksDef,
  type ResolveAttrs,
  type ValueTypes,
  type InstaQLEntity,
  type InstaQLResult,
  type InstantUnknownSchema,
  type InstantSchemaDef,
  type BackwardsCompatibleSchema,
  type InstantRules,
  type UpdateParams,
  type LinkParams,
  type ExchangeCodeForTokenParams,
  type SendMagicCodeParams,
  type SendMagicCodeResponse,
  type SignInWithIdTokenParams,
  type VerifyMagicCodeParams,
  type VerifyResponse,

  // storage types
  type FileOpts,
  type UploadFileResponse,
  type DeleteFileResponse,
} from '@instantdb/core';

import InstantReactAbstractDatabase from './InstantReactAbstractDatabase';
import InstantReactWebDatabase from './InstantReactWebDatabase';
import { init, init_experimental } from './init';
import { Cursors } from './Cursors';

export {
  id,
  tx,
  lookup,
  init,
  init_experimental,
  InstantReactWebDatabase,
  Cursors,
  i,

  // internal
  InstantReactAbstractDatabase,

  // types
  type Config,
  type Query,
  type QueryResponse,
  type InstantObject,
  type User,
  type AuthState,
  type ConnectionStatus,
  type InstantQuery,
  type InstantQueryResult,
  type InstantSchema,
  type InstantEntity,
  type InstantSchemaDatabase,
  type IInstantDatabase,
  type InstaQLParams,

  // schema types
  type AttrsDefs,
  type CardinalityKind,
  type DataAttrDef,
  type EntitiesDef,
  type EntitiesWithLinks,
  type EntityDef,
  type InstantGraph,
  type LinkAttrDef,
  type LinkDef,
  type LinksDef,
  type ResolveAttrs,
  type ValueTypes,
  type InstaQLEntity,
  type InstaQLResult,
  type InstantUnknownSchema,
  type InstantSchemaDef,
  type BackwardsCompatibleSchema,
  type InstantRules,
  type UpdateParams,
  type LinkParams,
  type ExchangeCodeForTokenParams,
  type SendMagicCodeParams,
  type SendMagicCodeResponse,
  type SignInWithIdTokenParams,
  type VerifyMagicCodeParams,
  type VerifyResponse,

  // storage types
  type FileOpts,
  type UploadFileResponse,
  type DeleteFileResponse,
};
</file>

<file path="client/packages/react/src/init.ts">
import type {
  InstantConfig,
  InstantSchemaDef,
  InstantUnknownSchema,
} from '@instantdb/core';

import InstantReactWebDatabase from './InstantReactWebDatabase';
import version from './version';

/**
 *
 * The first step: init your application!
 *
 * Visit https://instantdb.com/dash to get your `appId` :)
 *
 * @example
 *  import { init } from "@instantdb/react"
 *
 *  const db = init({ appId: "my-app-id" })
 *
 *  // You can also provide a schema for type safety and editor autocomplete!
 *
 *  import { init } from "@instantdb/react"
 *  import schema from ""../instant.schema.ts";
 *
 *  const db = init({ appId: "my-app-id", schema })
 *
 *  // To learn more: https://instantdb.com/docs/modeling-data
 */
export function init<
  Schema extends InstantSchemaDef<any, any, any> = InstantUnknownSchema,
>(config: InstantConfig<Schema>) {
  return new InstantReactWebDatabase<Schema>(config, {
    '@instantdb/react': version,
  });
}

/**
 * @deprecated
 * `init_experimental` is deprecated. You can replace it with `init`.
 *
 * @example
 *
 * // Before
 * import { init_experimental } from "@instantdb/react"
 * const db = init_experimental({  ...  });
 *
 * // After
 * import { init } from "@instantdb/react"
 * const db = init({ ...  });
 */
export const init_experimental = init;
</file>

<file path="client/packages/react/src/InstantReactAbstractDatabase.ts">
import {
  // types
  Auth,
  Storage,
  txInit,
  type AuthState,
  type User,
  type ConnectionStatus,
  type TransactionChunk,
  type PresenceOpts,
  type PresenceResponse,
  type RoomSchemaShape,
  type InstaQLParams,
  type InstantConfig,
  type PageInfoResponse,
  InstantCoreDatabase,
  init as core_init,
  InstaQLLifecycleState,
  InstaQLResponse,
  RoomsOf,
  InstantSchemaDef,
  IInstantDatabase,
} from '@instantdb/core';
import {
  KeyboardEvent,
  useCallback,
  useEffect,
  useMemo,
  useRef,
  useState,
  useSyncExternalStore,
} from 'react';
import { useQueryInternal } from './useQuery';
import { useTimeout } from './useTimeout';
import { InstantReactRoom, rooms } from './InstantReactRoom';

const defaultAuthState = {
  isLoading: true,
  user: undefined,
  error: undefined,
};

export default abstract class InstantReactAbstractDatabase<
  Schema extends InstantSchemaDef<any, any, any>,
  Rooms extends RoomSchemaShape = RoomsOf<Schema>,
> implements IInstantDatabase<Schema>
{
  public tx = txInit<Schema>();

  public auth: Auth;
  public storage: Storage;
  public _core: InstantCoreDatabase<Schema>;

  static Storage?: any;
  static NetworkListener?: any;

  constructor(
    config: InstantConfig<Schema>,
    versions?: { [key: string]: string },
  ) {
    this._core = core_init<Schema>(
      config,
      // @ts-expect-error because TS can't resolve subclass statics
      this.constructor.Storage,
      // @ts-expect-error because TS can't resolve subclass statics
      this.constructor.NetworkListener,
      versions,
    );
    this.auth = this._core.auth;
    this.storage = this._core.storage;
  }

  getLocalId = (name: string) => {
    return this._core.getLocalId(name);
  };

  /**
   * Obtain a handle to a room, which allows you to listen to topics and presence data
   *
   * If you don't provide a `type` or `id`, Instant will default to `_defaultRoomType` and `_defaultRoomId`
   * as the room type and id, respectively.
   *
   * @see https://instantdb.com/docs/presence-and-topics
   *
   * @example
   *  const room = db.room('chat', roomId);
   *  const { peers } = db.rooms.usePresence(room);
   */
  room<RoomType extends keyof Rooms>(
    type: RoomType = '_defaultRoomType' as RoomType,
    id: string = '_defaultRoomId',
  ) {
    return new InstantReactRoom<Schema, Rooms, RoomType>(this._core, type, id);
  }

  /**
   * Hooks for working with rooms
   *
   * @see https://instantdb.com/docs/presence-and-topics
   *
   * @example
   *  const room = db.room('chat', roomId);
   *  const { peers } = db.rooms.usePresence(room);
   *  const publish = db.rooms.usePublishTopic(room, 'emoji');
   *  // ...
   */
  rooms = rooms;

  /**
   * Use this to write data! You can create, update, delete, and link objects
   *
   * @see https://instantdb.com/docs/instaml
   *
   * @example
   *   // Create a new object in the `goals` namespace
   *   const goalId = id();
   *   db.transact(tx.goals[goalId].update({title: "Get fit"}))
   *
   *   // Update the title
   *   db.transact(tx.goals[goalId].update({title: "Get super fit"}))
   *
   *   // Delete it
   *   db.transact(tx.goals[goalId].delete())
   *
   *   // Or create an association:
   *   todoId = id();
   *   db.transact([
   *    tx.todos[todoId].update({ title: 'Go on a run' }),
   *    tx.goals[goalId].link({todos: todoId}),
   *  ])
   */
  transact = (
    chunks: TransactionChunk<any, any> | TransactionChunk<any, any>[],
  ) => {
    return this._core.transact(chunks);
  };

  /**
   * Use this to query your data!
   *
   * @see https://instantdb.com/docs/instaql
   *
   * @example
   *  // listen to all goals
   *  db.useQuery({ goals: {} })
   *
   *  // goals where the title is "Get Fit"
   *  db.useQuery({ goals: { $: { where: { title: "Get Fit" } } } })
   *
   *  // all goals, _alongside_ their todos
   *  db.useQuery({ goals: { todos: {} } })
   *
   *  // skip if `user` is not logged in
   *  db.useQuery(auth.user ? { goals: {} } : null)
   */
  useQuery = <Q extends InstaQLParams<Schema>>(
    query: null | Q,
  ): InstaQLLifecycleState<Schema, Q> => {
    return useQueryInternal(this._core, query).state;
  };

  /**
   * Listen for the logged in state. This is useful
   * for deciding when to show a login screen.
   *
   * Check out the docs for an example `Login` component too!
   *
   * @see https://instantdb.com/docs/auth
   * @example
   *  function App() {
   *    const { isLoading, user, error } = db.useAuth()
   *    if (isLoading) {
   *      return <div>Loading...</div>
   *    }
   *    if (error) {
   *      return <div>Uh oh! {error.message}</div>
   *    }
   *    if (user) {
   *      return <Main user={user} />
   *    }
   *    return <Login />
   *  }
   *
   */
  useAuth = (): AuthState => {
    // We use a ref to store the result of the query.
    // This is becuase `useSyncExternalStore` uses `Object.is`
    // to compare the previous and next state.
    // If we don't use a ref, the state will always be considered different, so
    // the component will always re-render.
    const resultCacheRef = useRef<AuthState>(
      this._core._reactor._currentUserCached,
    );

    // Similar to `resultCacheRef`, `useSyncExternalStore` will unsubscribe
    // if `subscribe` changes, so we use `useCallback` to memoize the function.
    const subscribe = useCallback((cb: Function) => {
      const unsubscribe = this._core.subscribeAuth((auth) => {
        resultCacheRef.current = { isLoading: false, ...auth };
        cb();
      });

      return unsubscribe;
    }, []);

    const state = useSyncExternalStore<AuthState>(
      subscribe,
      () => resultCacheRef.current,
      () => defaultAuthState,
    );
    return state;
  };

  /**
   * One time query for the logged in state. This is useful
   * for scenarios where you want to know the current auth
   * state without subscribing to changes.
   *
   * @see https://instantdb.com/docs/auth
   * @example
   *   const user = await db.getAuth();
   *   console.log('logged in as', user.email)
   */
  getAuth(): Promise<User | null> {
    return this._core.getAuth();
  }

  /**
   * Listen for connection status changes to Instant. Use this for things like
   * showing connection state to users
   *
   * @see https://www.instantdb.com/docs/patterns#connection-status
   * @example
   *  function App() {
   *    const status = db.useConnectionStatus()
   *    const connectionState =
   *      status === 'connecting' || status === 'opened'
   *        ? 'authenticating'
   *      : status === 'authenticated'
   *        ? 'connected'
   *      : status === 'closed'
   *        ? 'closed'
   *      : status === 'errored'
   *        ? 'errored'
   *      : 'unexpected state';
   *
   *    return <div>Connection state: {connectionState}</div>
   *  }
   */
  useConnectionStatus = (): ConnectionStatus => {
    const statusRef = useRef<ConnectionStatus>(
      this._core._reactor.status as ConnectionStatus,
    );

    const subscribe = useCallback((cb: Function) => {
      const unsubscribe = this._core.subscribeConnectionStatus((newStatus) => {
        if (newStatus !== statusRef.current) {
          statusRef.current = newStatus;
          cb();
        }
      });

      return unsubscribe;
    }, []);

    const status = useSyncExternalStore<ConnectionStatus>(
      subscribe,
      () => statusRef.current,
      // For SSR, always return 'connecting' as the initial state
      () => 'connecting',
    );

    return status;
  };

  /**
   * Use this for one-off queries.
   * Returns local data if available, otherwise fetches from the server.
   * Because we want to avoid stale data, this method will throw an error
   * if the user is offline or there is no active connection to the server.
   *
   * @see https://instantdb.com/docs/instaql
   *
   * @example
   *
   *  const resp = await db.queryOnce({ goals: {} });
   *  console.log(resp.data.goals)
   */
  queryOnce = <Q extends InstaQLParams<Schema>>(
    query: Q,
  ): Promise<{
    data: InstaQLResponse<Schema, Q>;
    pageInfo: PageInfoResponse<Q>;
  }> => {
    return this._core.queryOnce(query);
  };
}
</file>

<file path="client/packages/react/src/InstantReactRoom.ts">
import {
  // types
  type PresenceOpts,
  type PresenceResponse,
  type RoomSchemaShape,
  InstantCoreDatabase,
  InstantSchemaDef,
} from '@instantdb/core';

import {
  KeyboardEvent,
  useCallback,
  useEffect,
  useMemo,
  useState,
} from 'react';

import { useTimeout } from './useTimeout';

export type PresenceHandle<
  PresenceShape,
  Keys extends keyof PresenceShape,
> = PresenceResponse<PresenceShape, Keys> & {
  publishPresence: (data: Partial<PresenceShape>) => void;
};

export type TypingIndicatorOpts = {
  timeout?: number | null;
  stopOnEnter?: boolean;
  // Perf opt - `active` will always be an empty array
  writeOnly?: boolean;
};

export type TypingIndicatorHandle<PresenceShape> = {
  active: PresenceShape[];
  setActive(active: boolean): void;
  inputProps: {
    onKeyDown: (e: KeyboardEvent) => void;
    onBlur: () => void;
  };
};

export const defaultActivityStopTimeout = 1_000;

// ------
// Topics

/**
 * Listen for broadcasted events given a room and topic.
 *
 * @see https://instantdb.com/docs/presence-and-topics
 * @example
 *  function App({ roomId }) {
 *    const room = db.room('chats', roomId);
 *    db.rooms.useTopicEffect(room, 'emoji', (message, peer) => {
 *      console.log(peer.name, 'sent', message);
 *    });
 *    // ...
 *  }
 */
export function useTopicEffect<
  RoomSchema extends RoomSchemaShape,
  RoomType extends keyof RoomSchema,
  TopicType extends keyof RoomSchema[RoomType]['topics'],
>(
  room: InstantReactRoom<any, RoomSchema, RoomType>,
  topic: TopicType,
  onEvent: (
    event: RoomSchema[RoomType]['topics'][TopicType],
    peer: RoomSchema[RoomType]['presence'],
  ) => any,
): void {
  useEffect(() => {
    const unsub = room._core._reactor.subscribeTopic(
      room.id,
      topic,
      (event, peer) => {
        onEvent(event, peer);
      },
    );

    return unsub;
  }, [room.id, topic]);
}

/**
 * Broadcast an event to a room.
 *
 * @see https://instantdb.com/docs/presence-and-topics
 * @example
 * function App({ roomId }) {
 *   const room = db.room('chat', roomId);
 *   const publishTopic = db.rooms.usePublishTopic(room, "emoji");
 *
 *   return (
 *     <button onClick={() => publishTopic({ emoji: "🔥" })}>Send emoji</button>
 *   );
 * }
 *
 */
export function usePublishTopic<
  RoomSchema extends RoomSchemaShape,
  RoomType extends keyof RoomSchema,
  TopicType extends keyof RoomSchema[RoomType]['topics'],
>(
  room: InstantReactRoom<any, RoomSchema, RoomType>,
  topic: TopicType,
): (data: RoomSchema[RoomType]['topics'][TopicType]) => void {
  useEffect(() => room._core._reactor.joinRoom(room.id), [room.id]);

  const publishTopic = useCallback(
    (data) => {
      room._core._reactor.publishTopic({
        roomType: room.type,
        roomId: room.id,
        topic,
        data,
      });
    },
    [room.id, topic],
  );

  return publishTopic;
}

// ---------
// Presence

/**
 * Listen for peer's presence data in a room, and publish the current user's presence.
 *
 * @see https://instantdb.com/docs/presence-and-topics
 * @example
 *  function App({ roomId }) {
 *    const {
 *      peers,
 *      publishPresence
 *    } = db.room(roomType, roomId).usePresence({ keys: ["name", "avatar"] });
 *
 *    // ...
 *  }
 */
export function usePresence<
  RoomSchema extends RoomSchemaShape,
  RoomType extends keyof RoomSchema,
  Keys extends keyof RoomSchema[RoomType]['presence'],
>(
  room: InstantReactRoom<any, RoomSchema, RoomType>,
  opts: PresenceOpts<RoomSchema[RoomType]['presence'], Keys> = {},
): PresenceHandle<RoomSchema[RoomType]['presence'], Keys> {
  const [state, setState] = useState<
    PresenceResponse<RoomSchema[RoomType]['presence'], Keys>
  >(() => {
    return (
      room._core._reactor.getPresence(room.type, room.id, opts) ?? {
        peers: {},
        isLoading: true,
      }
    );
  });

  useEffect(() => {
    const unsub = room._core._reactor.subscribePresence(
      room.type,
      room.id,
      opts,
      (data) => {
        setState(data);
      },
    );

    return unsub;
  }, [room.id, opts.user, opts.peers?.join(), opts.keys?.join()]);

  const publishPresence = useCallback(
    (data) => {
      room._core._reactor.publishPresence(room.type, room.id, data);
    },
    [room.type, room.id],
  );
  const ret = useMemo(() => {
    return {
      ...state,
      publishPresence,
    };
  }, [state, publishPresence]);
  return ret;
}

/**
 * Publishes presence data to a room
 *
 * @see https://instantdb.com/docs/presence-and-topics
 * @example
 *  function App({ roomId, nickname }) {
 *    const room = db.room('chat', roomId);
 *    db.rooms.useSyncPresence(room, { nickname });
 *  }
 */
export function useSyncPresence<
  RoomSchema extends RoomSchemaShape,
  RoomType extends keyof RoomSchema,
>(
  room: InstantReactRoom<any, RoomSchema, RoomType>,
  data: Partial<RoomSchema[RoomType]['presence']>,
  deps?: any[],
): void {
  useEffect(() => room._core._reactor.joinRoom(room.id), [room.id]);
  useEffect(() => {
    return room._core._reactor.publishPresence(room.type, room.id, data);
  }, [room.type, room.id, deps ?? JSON.stringify(data)]);
}

// -----------------
// Typing Indicator

/**
 * Manage typing indicator state
 *
 * @see https://instantdb.com/docs/presence-and-topics
 * @example
 *  function App({ roomId }) {
 *    const room = db.room('chat', roomId);
 *    const {
 *      active,
 *      setActive,
 *      inputProps,
 *    } = db.rooms.useTypingIndicator(room, "chat-input");
 *
 *    return <input {...inputProps} />;
 *  }
 */
export function useTypingIndicator<
  RoomSchema extends RoomSchemaShape,
  RoomType extends keyof RoomSchema,
>(
  room: InstantReactRoom<any, RoomSchema, RoomType>,
  inputName: string,
  opts: TypingIndicatorOpts = {},
): TypingIndicatorHandle<RoomSchema[RoomType]['presence']> {
  const timeout = useTimeout();

  const observedPresence = rooms.usePresence(room, {
    keys: [inputName],
  });

  const active = useMemo(() => {
    const presenceSnapshot = room._core._reactor.getPresence(
      room.type,
      room.id,
    );

    return opts?.writeOnly
      ? []
      : Object.values(presenceSnapshot?.peers ?? {}).filter(
          (p) => p[inputName] === true,
        );
  }, [opts?.writeOnly, observedPresence]);

  const setActive = useCallback(
    (isActive: boolean) => {
      room._core._reactor.publishPresence(room.type, room.id, {
        [inputName]: isActive,
      } as unknown as Partial<RoomSchema[RoomType]>);

      if (!isActive) return;

      if (opts?.timeout === null || opts?.timeout === 0) return;

      timeout.set(opts?.timeout ?? defaultActivityStopTimeout, () => {
        room._core._reactor.publishPresence(room.type, room.id, {
          [inputName]: null,
        } as Partial<RoomSchema[RoomType]>);
      });
    },
    [room.type, room.id, inputName, opts?.timeout, timeout],
  );
  const onKeyDown = useCallback(
    (e: KeyboardEvent) => {
      const isEnter = opts?.stopOnEnter && e.key === 'Enter';
      const isActive = !isEnter;

      setActive(isActive);
    },
    [opts.stopOnEnter, setActive],
  );
  const onBlur = useCallback(() => {
    setActive(false);
  }, [setActive]);

  const inputProps = useMemo(() => {
    return { onKeyDown, onBlur };
  }, [onKeyDown, onBlur]);

  return {
    active,
    setActive,
    inputProps,
  };
}

// --------------
// Hooks

export const rooms = {
  useTopicEffect,
  usePublishTopic,
  usePresence,
  useSyncPresence,
  useTypingIndicator,
};

// ------------
// Class

export class InstantReactRoom<
  Schema extends InstantSchemaDef<any, any, any>,
  RoomSchema extends RoomSchemaShape,
  RoomType extends keyof RoomSchema,
> {
  _core: InstantCoreDatabase<Schema>;
  type: RoomType;
  id: string;

  constructor(_core: InstantCoreDatabase<Schema>, type: RoomType, id: string) {
    this._core = _core;
    this.type = type;
    this.id = id;
  }

  /**
   * @deprecated
   * `db.room(...).useTopicEffect` is deprecated. You can replace it with `db.rooms.useTopicEffect`.
   *
   * @example
   *
   * // Before
   * const room = db.room('chat', 'room-id');
   * room.useTopicEffect('emoji', (message, peer) => {  });
   *
   * // After
   * const room = db.room('chat', 'room-id');
   * db.rooms.useTopicEffect(room, 'emoji', (message, peer) => {  });
   */
  useTopicEffect = <TopicType extends keyof RoomSchema[RoomType]['topics']>(
    topic: TopicType,
    onEvent: (
      event: RoomSchema[RoomType]['topics'][TopicType],
      peer: RoomSchema[RoomType]['presence'],
    ) => any,
  ): void => {
    rooms.useTopicEffect(this, topic, onEvent);
  };

  /**
   * @deprecated
   * `db.room(...).usePublishTopic` is deprecated. You can replace it with `db.rooms.usePublishTopic`.
   *
   * @example
   *
   * // Before
   * const room = db.room('chat', 'room-id');
   * const publish = room.usePublishTopic('emoji');
   *
   * // After
   * const room = db.room('chat', 'room-id');
   * const publish = db.rooms.usePublishTopic(room, 'emoji');
   */
  usePublishTopic = <Topic extends keyof RoomSchema[RoomType]['topics']>(
    topic: Topic,
  ): ((data: RoomSchema[RoomType]['topics'][Topic]) => void) => {
    return rooms.usePublishTopic(this, topic);
  };

  /**
   * @deprecated
   * `db.room(...).usePresence` is deprecated. You can replace it with `db.rooms.usePresence`.
   *
   * @example
   *
   * // Before
   * const room = db.room('chat', 'room-id');
   * const { peers } = room.usePresence({ keys: ["name", "avatar"] });
   *
   * // After
   * const room = db.room('chat', 'room-id');
   * const { peers } = db.rooms.usePresence(room, { keys: ["name", "avatar"] });
   */
  usePresence = <Keys extends keyof RoomSchema[RoomType]['presence']>(
    opts: PresenceOpts<RoomSchema[RoomType]['presence'], Keys> = {},
  ): PresenceHandle<RoomSchema[RoomType]['presence'], Keys> => {
    return rooms.usePresence(this, opts);
  };

  /**
   * @deprecated
   * `db.room(...).useSyncPresence` is deprecated. You can replace it with `db.rooms.useSyncPresence`.
   *
   * @example
   *
   * // Before
   * const room = db.room('chat', 'room-id');
   * room.useSyncPresence(room, { nickname });
   *
   * // After
   * const room = db.room('chat', 'room-id');
   * db.rooms.useSyncPresence(room, { nickname });
   */
  useSyncPresence = (
    data: Partial<RoomSchema[RoomType]['presence']>,
    deps?: any[],
  ): void => {
    return rooms.useSyncPresence(this, data, deps);
  };

  /**
   * @deprecated
   * `db.room(...).useTypingIndicator` is deprecated. You can replace it with `db.rooms.useTypingIndicator`.
   *
   * @example
   *
   * // Before
   * const room = db.room('chat', 'room-id');
   * const typing = room.useTypingIndiactor(room, 'chat-input');
   *
   * // After
   * const room = db.room('chat', 'room-id');
   * const typing = db.rooms.useTypingIndiactor(room, 'chat-input');
   */
  useTypingIndicator = (
    inputName: string,
    opts: TypingIndicatorOpts = {},
  ): TypingIndicatorHandle<RoomSchema[RoomType]['presence']> => {
    return rooms.useTypingIndicator(this, inputName, opts);
  };
}
</file>

<file path="client/packages/react/src/InstantReactWebDatabase.ts">
import type { InstantSchemaDef } from '@instantdb/core';
import InstantReactAbstractDatabase from './InstantReactAbstractDatabase';

export default class InstantReactWebDatabase<
  Schema extends InstantSchemaDef<any, any, any>,
> extends InstantReactAbstractDatabase<Schema> {}
</file>

<file path="client/packages/react/src/useQuery.ts">
import {
  weakHash,
  coerceQuery,
  type Query,
  type Exactly,
  type LifecycleSubscriptionState,
  type InstaQLParams,
  type InstantGraph,
  InstantCoreDatabase,
  InstaQLLifecycleState,
  InstantSchemaDef,
} from '@instantdb/core';
import { useCallback, useRef, useSyncExternalStore } from 'react';

const defaultState = {
  isLoading: true,
  data: undefined,
  pageInfo: undefined,
  error: undefined,
};

function stateForResult(result: any) {
  return {
    isLoading: !Boolean(result),
    data: undefined,
    pageInfo: undefined,
    error: undefined,
    ...(result ? result : {}),
  };
}

export function useQueryInternal<
  Q extends InstaQLParams<Schema>,
  Schema extends InstantSchemaDef<any, any, any>,
>(
  _core: InstantCoreDatabase<Schema>,
  _query: null | Q,
): {
  state: InstaQLLifecycleState<Schema, Q>;
  query: any;
} {
  const query = _query ? coerceQuery(_query) : null;
  const queryHash = weakHash(query);

  // We use a ref to store the result of the query.
  // This is becuase `useSyncExternalStore` uses `Object.is`
  // to compare the previous and next state.
  // If we don't use a ref, the state will always be considered different, so
  // the component will always re-render.
  const resultCacheRef = useRef<InstaQLLifecycleState<Schema, Q>>(
    stateForResult(_core._reactor.getPreviousResult(query)),
  );

  // Similar to `resultCacheRef`, `useSyncExternalStore` will unsubscribe
  // if `subscribe` changes, so we use `useCallback` to memoize the function.
  const subscribe = useCallback(
    (cb) => {
      // Don't subscribe if query is null
      if (!query) {
        const unsubscribe = () => {};
        return unsubscribe;
      }

      const unsubscribe = _core.subscribeQuery<Q>(query, (result) => {
        resultCacheRef.current = {
          isLoading: !Boolean(result),
          data: undefined,
          pageInfo: undefined,
          error: undefined,
          ...result,
        };

        cb();
      });

      return unsubscribe;
    },
    // Build a new subscribe function if the query changes
    [queryHash],
  );

  const state = useSyncExternalStore<InstaQLLifecycleState<Schema, Q>>(
    subscribe,
    () => resultCacheRef.current,
    () => defaultState,
  );
  return { state, query };
}
</file>

<file path="client/packages/react/src/useTimeout.ts">
import { useEffect, useRef } from 'react';

export function useTimeout() {
  const timeoutRef = useRef(null);

  useEffect(() => {
    clear();
  }, []);

  function set(delay: number, fn: () => void) {
    clearTimeout(timeoutRef.current);
    timeoutRef.current = setTimeout(fn, delay);
  }

  function clear() {
    clearTimeout(timeoutRef.current);
  }

  return { set, clear };
}
</file>

<file path="client/packages/react/src/version.js">
// Autogenerated by publish_packages.clj
const version = 'v0.17.22-dev';

export default version;
</file>

<file path="client/packages/react/.npmignore">
.turbo
</file>

<file path="client/packages/react/package.json">
{
  "name": "@instantdb/react",
  "version": "v0.17.22",
  "description": "Instant DB for React",
  "main": "dist/index.js",
  "module": "dist/module/index.js",
  "types": "dist/module/index.d.ts",
  "unpkg": "standalone/index.umd.js",
  "scripts": {
    "test": "vitest",
    "build": "rm -rf dist; npm run build:main && npm run build:module && npm run build:standalone",
    "dev:main": "tsc -p tsconfig.json -w --skipLibCheck",
    "dev:module": "tsc -p tsconfig.module.json -w --skipLibCheck",
    "dev": "run-p dev:main dev:module",
    "build:main": "tsc -p tsconfig.json",
    "build:module": "tsc -p tsconfig.module.json",
    "build:standalone": "vite build",
    "publish-package": "pnpm publish --access public --no-git-checks"
  },
  "devDependencies": {
    "@babel/core": "^7.17.9",
    "@babel/preset-env": "^7.16.11",
    "@types/node": "^22.6.1",
    "@types/react": ">=16",
    "@vitejs/plugin-react": "^4.3.1",
    "npm-run-all": "^4.1.5",
    "typescript": "^5.5.4",
    "vite": "^5.2.0",
    "vitest": "^0.21.0"
  },
  "peerDependencies": {
    "react": ">=16"
  },
  "dependencies": {
    "@instantdb/core": "workspace:*"
  }
}
</file>

<file path="client/packages/react/README.md">
<p align="center">
  <a href="https://instantdb.com">
    <img alt="Shows the Instant logo" src="https://instantdb.com/img/icon/android-chrome-512x512.png" width="10%">
  </a>
  <h1 align="center">@instantdb/react</h1>
</p>

<p align="center">
  <a 
    href="https://discord.com/invite/VU53p7uQcE" >
    <img height=20 src="https://img.shields.io/discord/1031957483243188235" />
  </a>
  <img src="https://img.shields.io/github/stars/instantdb/instant" alt="stars">
</p>

<p align="center">
   <a href="https://instantdb.com/dash">Get Started</a> · 
   <a href="https://instantdb.com/examples">Examples</a> · 
   <a href="https://instantdb.com/tutorial">Try the Demo</a> · 
   <a href="https://instantdb.com/docs">Docs</a> · 
   <a href="https://discord.com/invite/VU53p7uQcE">Discord</a>
<p>

Welcome to [Instant's](http://instantdb.com) React SDK.

```javascript
// ༼ つ ◕_◕ ༽つ Real-time Chat
// ----------------------------------
// * Updates instantly
// * Multiplayer
// * Works offline
function Chat() {
  // 1. Read
  const { isLoading, error, data } = useQuery({
    messages: {},
  });

  // 2. Write
  const addMessage = (message) => {
    transact(tx.messages[id()].update(message));
  };

  // 3. Render!
  return <UI data={data} onAdd={addMessage} />;
}
```

# Get Started

Follow the [getting started](https://www.instantdb.com/docs) tutorial to set up a live React app in under 5 minutes! Or you can try an [interactive demo](https://instantdb.com/tutorial) in your browser :).

# Questions?

If you have any questions, feel free to drop us a line on our [Discord](https://discord.com/invite/VU53p7uQcE)
</file>

<file path="client/packages/react/tsconfig.json">
{
  "extends": "../../tsconfig.base.json",
  "include": ["src"],
  "exclude": ["node_modules", "dist"],
  "compilerOptions": {
    "outDir": "dist",
    "rootDir": "src",
    "jsx": "react-jsx"
  }
}
</file>

<file path="client/packages/react/tsconfig.module.json">
{
  "extends": "./tsconfig",
  "compilerOptions": {
    "module": "es2015",
    "outDir": "dist/module"
  }
}
</file>

<file path="client/packages/react/vite.config.ts">
import { defineConfig } from 'vite';
import react from '@vitejs/plugin-react';
import { resolve } from 'path';

export default defineConfig({
  plugins: [react()],
  build: {
    outDir: 'dist/standalone',
    lib: {
      formats: ['umd', 'es'],
      // this is the file that exports our components
      entry: resolve(__dirname, 'src', 'index.ts'),
      name: 'instantReact',
      fileName: 'index',
    },
    rollupOptions: {
      // don't bundle react libs
      // the user will have provided them already
      // via script tags or import maps
      external: ['react', 'react-dom'],
      output: {
        // Provide global variables to use in the UMD build
        // for externalized deps
        globals: {
          react: 'React',
          'react-dom': 'ReactDOM',
        },
      },
    },
  },
  define: {
    'process.env': {},
  },
});
</file>

<file path="client/packages/react-native/src/cli.ts">
export * from '@instantdb/core';
</file>

<file path="client/packages/react-native/src/index.ts">
import 'react-native-get-random-values';

import Storage from './Storage';
import NetworkListener from './NetworkListener';
import version from './version';

import {
  // react
  InstantReactAbstractDatabase,

  // types
  type BackwardsCompatibleSchema,
  type IInstantDatabase,
  type Config,
  type Query,
  type QueryResponse,
  type InstantObject,
  type AuthState,
  type User,
} from '@instantdb/react';
import {
  i,
  id,
  tx,
  lookup,
  type RoomSchemaShape,
  type InstantQuery,
  type InstantQueryResult,
  type InstantSchema,
  type InstantSchemaDatabase,
  type ConnectionStatus,

  // schema types
  type AttrsDefs,
  type CardinalityKind,
  type DataAttrDef,
  type EntitiesDef,
  type EntitiesWithLinks,
  type EntityDef,
  type InstantGraph,
  type LinkAttrDef,
  type LinkDef,
  type LinksDef,
  type ResolveAttrs,
  type ValueTypes,
  type InstantEntity,
  type ConfigWithSchema,
  type InstaQLEntity,
  type InstaQLResult,
  type InstantConfig,
  type InstantSchemaDef,
  type InstantUnknownSchema,
  type InstantRules,
  type UpdateParams,
  type LinkParams,
  type ExchangeCodeForTokenParams,
  type SendMagicCodeParams,
  type SendMagicCodeResponse,
  type SignInWithIdTokenParams,
  type VerifyMagicCodeParams,
  type VerifyResponse,

  // storage types
  type FileOpts,
  type UploadFileResponse,
  type DeleteFileResponse,
} from '@instantdb/core';

/**
 *
 * The first step: init your application!
 *
 * Visit https://instantdb.com/dash to get your `appId` :)
 *
 * @example
 *  import { init } from "@instantdb/react-native"
 *
 *  const db = init({ appId: "my-app-id" })
 *
 *  // You can also provide a schema for type safety and editor autocomplete!
 *
 *  import { init } from "@instantdb/react-native"
 *  import schema from ""../instant.schema.ts";
 *
 *  const db = init({ appId: "my-app-id", schema })
 *
 *  // To learn more: https://instantdb.com/docs/modeling-data
 */
function init<
  Schema extends InstantSchemaDef<any, any, any> = InstantUnknownSchema,
>(config: InstantConfig<Schema>) {
  return new InstantReactNativeDatabase<Schema>(config, {
    '@instantdb/react-native': version,
  });
}

/**
 * @deprecated
 * `init_experimental` is deprecated. You can replace it with `init`.
 *
 * @example
 *
 * // Before
 * import { init_experimental } from "@instantdb/react-native"
 * const db = init_experimental({  ...  });
 *
 * // After
 * import { init } from "@instantdb/react-native"
 * const db = init({ ...  });
 */
const init_experimental = init;

class InstantReactNativeDatabase<
  Schema extends InstantSchemaDef<any, any, any>,
> extends InstantReactAbstractDatabase<Schema> {
  static Storage = Storage;
  static NetworkListener = NetworkListener;
}

export {
  init,
  init_experimental,
  id,
  tx,
  lookup,
  i,

  // types
  type Config,
  type Query,
  type QueryResponse,
  type InstantObject,
  type User,
  type AuthState,
  type ConnectionStatus,
  type InstantQuery,
  type InstantQueryResult,
  type InstantSchema,
  type InstantSchemaDatabase,
  type IInstantDatabase,
  type InstantEntity,
  type RoomSchemaShape,

  // schema types
  type AttrsDefs,
  type CardinalityKind,
  type DataAttrDef,
  type EntitiesDef,
  type EntitiesWithLinks,
  type EntityDef,
  type InstantGraph,
  type LinkAttrDef,
  type LinkDef,
  type LinksDef,
  type ResolveAttrs,
  type ValueTypes,
  type InstaQLEntity,
  type InstaQLResult,
  type InstantSchemaDef,
  type InstantUnknownSchema,
  type BackwardsCompatibleSchema,
  type InstantRules,
  type UpdateParams,
  type LinkParams,
  type ExchangeCodeForTokenParams,
  type SendMagicCodeParams,
  type SendMagicCodeResponse,
  type SignInWithIdTokenParams,
  type VerifyMagicCodeParams,
  type VerifyResponse,

  // storage types
  type FileOpts,
  type UploadFileResponse,
  type DeleteFileResponse,
};
</file>

<file path="client/packages/react-native/src/NetworkListener.js">
import NetInfo from '@react-native-community/netinfo';

export default class NetworkListener {
  static async getIsOnline() {
    const network = await NetInfo.fetch();
    return network.isConnected;
  }
  static listen(f) {
    return NetInfo.addEventListener((state) => {
      f(state.isConnected);
    });
  }
}
</file>

<file path="client/packages/react-native/src/Storage.js">
import { IndexedDBStorage } from '@instantdb/core';

export default IndexedDBStorage;
</file>

<file path="client/packages/react-native/src/Storage.native.js">
import AsyncStorage from '@react-native-async-storage/async-storage';

export default class Storage {
  constructor(dbName) {
    this.dbName = dbName;
  }

  async getItem(k) {
    return await AsyncStorage.getItem(`${this.dbName}_${k}`);
  }

  async setItem(k, v) {
    await AsyncStorage.setItem(`${this.dbName}_${k}`, v);
  }
}
</file>

<file path="client/packages/react-native/src/version.js">
// Autogenerated by publish_packages.clj
const version = 'v0.17.22-dev';

export default version;
</file>

<file path="client/packages/react-native/.npmignore">
.turbo
</file>

<file path="client/packages/react-native/package.json">
{
  "name": "@instantdb/react-native",
  "version": "v0.17.22",
  "description": "Instant DB for React Native",
  "main": "dist/index.js",
  "module": "dist/module/index.js",
  "types": "dist/module/index.d.ts",
  "unpkg": "dist/index.js",
  "scripts": {
    "test": "vitest",
    "build": "rm -rf dist; npm run build:main && npm run build:module",
    "dev:main": "tsc -p tsconfig.json -w --skipLibCheck",
    "dev:module": "tsc -p tsconfig.module.json -w --skipLibCheck",
    "dev": "run-p dev:main dev:module",
    "build:main": "tsc -p tsconfig.json",
    "build:module": "tsc -p tsconfig.module.json",
    "publish-package": "pnpm publish --access public --no-git-checks"
  },
  "devDependencies": {
    "@babel/core": "^7.17.9",
    "@babel/preset-env": "^7.16.11",
    "@types/node": "^22.6.1",
    "@types/react": ">=16",
    "npm-run-all": "^4.1.5",
    "typescript": "^5.5.4",
    "vitest": "^0.21.0"
  },
  "peerDependencies": {
    "@react-native-async-storage/async-storage": ">=1.15",
    "@react-native-community/netinfo": ">=7.1",
    "react": ">=16",
    "react-native": ">=0.56",
    "react-native-get-random-values": ">=1.5"
  },
  "dependencies": {
    "@instantdb/core": "workspace:*",
    "@instantdb/react": "workspace:*"
  }
}
</file>

<file path="client/packages/react-native/README.md">
<p align="center">
  <a href="https://instantdb.com">
    <img alt="Shows the Instant logo" src="https://instantdb.com/img/icon/android-chrome-512x512.png" width="10%">
  </a>
  <h1 align="center">@instantdb/react-native</h1>
</p>

<p align="center">
  <a 
    href="https://discord.com/invite/VU53p7uQcE" >
    <img height=20 src="https://img.shields.io/discord/1031957483243188235" />
  </a>
  <img src="https://img.shields.io/github/stars/instantdb/instant" alt="stars">
</p>

<p align="center">
   <a href="https://www.instantdb.com/docs/start-rn">Get Started</a> · 
   <a href="https://instantdb.com/examples">Examples</a> · 
   <a href="https://instantdb.com/tutorial">Try the Demo</a> · 
   <a href="https://www.instantdb.com/docs/start-rn">Docs</a> · 
   <a href="https://discord.com/invite/VU53p7uQcE">Discord</a>
<p>

Welcome to [Instant's](http://instantdb.com) React Native SDK.

```javascript
// ༼ つ ◕_◕ ༽つ Real-time Chat
// ----------------------------------
// * Updates instantly
// * Multiplayer
// * Works offline
function Chat() {
  // 1. Read
  const { isLoading, error, data } = useQuery({
    messages: {},
  });

  // 2. Write
  const addMessage = (message) => {
    transact(tx.messages[id()].update(message));
  };

  // 3. Render!
  return <UI data={data} onAdd={addMessage} />;
}
```

# Get Started

Follow the [getting started](https://www.instantdb.com/docs/start-rn) tutorial to set up a live React Native app in under 5 minutes! Or you can try a [demo](https://instantdb.com/tutorial) in your browser :).

# Questions?

If you have any questions, feel free to drop us a line on our [Discord](https://discord.com/invite/VU53p7uQcE)
</file>

<file path="client/packages/react-native/tsconfig.json">
{
  "extends": "../../tsconfig.base.json",
  "include": ["src"],
  "exclude": ["node_modules", "dist"],
  "compilerOptions": {
    "outDir": "dist",
    "rootDir": "src"
  }
}
</file>

<file path="client/packages/react-native/tsconfig.module.json">
{
  "extends": "./tsconfig",
  "compilerOptions": {
    "module": "es2015",
    "outDir": "dist/module"
  }
}
</file>

</files>
